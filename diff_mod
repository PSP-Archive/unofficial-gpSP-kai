diff -ruibwEB --strip-trailing-cr -I RE old/gui.c mod/gui.c
--- old/gui.c	2007-08-26 00:49:55.017782600 +0900
+++ mod/gui.c	2007-10-27 22:41:50.658430400 +0900
@@ -20,43 +20,52 @@
 
 #include "common.h"
 
+
+static int sort_function(const void *dest_str_ptr, const void *src_str_ptr);
+static void print_status(void);
+static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon,
+ u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec);
+static void save_ss_bmp(u16 *image);
+static void get_savestate_snapshot(char *savestate_filename);
+static s8 parse_line(char *current_line, char *current_str);
+
+void _flush_cache(void);
+
+
 // Blatantly stolen and trimmed from MZX (megazeux.sourceforge.net)
 
 #define STATUS_ROWS 0
-#define CURRENT_DIR_ROWS 1
-#define FILE_LIST_ROWS 25
-#define FILE_LIST_POSITION 5
+#define CURRENT_DIR_ROWS 0
+#define CURRENT_DIR_NAME_LENGTH 40
+#define FILE_LIST_ROWS 24
+#define FILE_LIST_POSITION_X 10
+#define FILE_LIST_POSITION_Y 5
 #define DIR_LIST_POSITION 360
 #define PAGE_SCROLL_NUM 5
 
 #define color16(red, green, blue)                                             \
-  (blue << 11) | (green << 5) | red                                           \
+  ((blue << 10) | (green << 5) | red)                                         \
+
+#define COLOR_BG            color16( 2,  4, 10)
+#define COLOR_ROM_INFO      color16(22, 18, 26)
+#define COLOR_ACTIVE_ITEM   color16(31, 31, 31)
+#define COLOR_INACTIVE_ITEM color16(13, 20, 18)
+#define COLOR_FRAMESKIP_BAR color16(15, 15, 31)
+#define COLOR_HELP_TEXT     color16(16, 20, 24)
 
-#define COLOR_BG            color16(2, 8, 10)
-#define COLOR_ROM_INFO      color16(22, 36, 26)
-#define COLOR_ACTIVE_ITEM   color16(31, 63, 31)
-#define COLOR_INACTIVE_ITEM color16(13, 40, 18)
-#define COLOR_FRAMESKIP_BAR color16(15, 31, 31)
-#define COLOR_HELP_TEXT     color16(16, 40, 24)
+char font8[MAX_FILE];
+char font16[MAX_FILE];
 
-char font8[MAX_PATH];
-char font16[MAX_PATH];
 char default_rom_dir[MAX_PATH];
 char default_save_dir[MAX_PATH];
 char default_cfg_dir[MAX_PATH];
 char default_ss_dir[MAX_PATH];
 char default_cheat_dir[MAX_PATH];
 
-u32 menu_cheat_page = 0;
-
-int sort_function(const void *dest_str_ptr, const void *src_str_ptr);
-void _flush_cache();
+static u32 clock_speed_number;
 
 
-
-
-
-int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
+static int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
 {
   char *dest_str = *((char **)dest_str_ptr);
   char *src_str = *((char **)src_str_ptr);
@@ -71,7 +80,7 @@
 }
 
 // �ėp�t�@�C���Ǎ���
-s32 load_file(char **wildcards, char *result,char *default_dir_name)
+s8 load_file(char **wildcards, char *result, char *default_dir_name)
 {
   DIR *current_dir;
   struct dirent *current_file;
@@ -87,7 +96,7 @@
   u32 num_dirs;
   char *file_name;
   u32 file_name_length;
-  u32 ext_pos = -1;
+  s32 ext_pos = -1;
   u32 chosen_file, chosen_dir;
 //  u32 dialog_result = 1;
   s32 return_value = 1;
@@ -213,12 +222,13 @@
 
     current_dir_length = strlen(current_dir_name);
 
-    if(current_dir_length > 80)
+    if(current_dir_length > CURRENT_DIR_NAME_LENGTH)
     {
       memcpy(current_dir_short, "...", 3);
       memcpy(current_dir_short + 3,
-       current_dir_name + current_dir_length - 77, 77);
-      current_dir_short[80] = 0;
+       current_dir_name + current_dir_length - (CURRENT_DIR_NAME_LENGTH - 3),
+       (CURRENT_DIR_NAME_LENGTH - 3));
+      current_dir_short[CURRENT_DIR_NAME_LENGTH] = 0;
     }
     else
     {
@@ -232,15 +242,13 @@
       current_column = 1;
 
     clear_screen(COLOR_BG);
-  {
-//    char print_buffer[81];
 
     while(repeat)
     {
       flip_screen();
 
       print_status();
-      print_string(current_dir_short, COLOR_ACTIVE_ITEM, COLOR_BG, 0, (CURRENT_DIR_ROWS * 10));
+      print_string(current_dir_short, COLOR_ACTIVE_ITEM, COLOR_BG, 2, 1);
       print_string(msg[MSG_RETURN_MENU], COLOR_HELP_TEXT, COLOR_BG, 20, 260);
 
       for(i = 0, current_file_number = i + current_file_scroll_value;
@@ -252,12 +260,14 @@
            (current_column == 0))
           {
             print_string(file_list[current_file_number], COLOR_ACTIVE_ITEM,
-             COLOR_BG, FILE_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10));
+             COLOR_BG, FILE_LIST_POSITION_X, ((i + CURRENT_DIR_ROWS + 1) * 10)
+             + FILE_LIST_POSITION_Y);
           }
           else
           {
             print_string(file_list[current_file_number], COLOR_INACTIVE_ITEM,
-             COLOR_BG, FILE_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10));
+             COLOR_BG, FILE_LIST_POSITION_X, ((i + CURRENT_DIR_ROWS + 1) * 10)
+             + FILE_LIST_POSITION_Y);
           }
         }
       }
@@ -271,12 +281,14 @@
            (current_column == 1))
           {
             print_string(dir_list[current_dir_number], COLOR_ACTIVE_ITEM,
-             COLOR_BG, DIR_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10));
+             COLOR_BG, DIR_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10)
+             + FILE_LIST_POSITION_Y);
           }
           else
           {
             print_string(dir_list[current_dir_number], COLOR_INACTIVE_ITEM,
-             COLOR_BG, DIR_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10));
+             COLOR_BG, DIR_LIST_POSITION, ((i + CURRENT_DIR_ROWS + 1) * 10)
+             + FILE_LIST_POSITION_Y);
           }
         }
       }
@@ -478,13 +488,9 @@
           return_value = -1;
           repeat = 0;
           break;
-
-        default:
-          ;
-          break;
-      }
     }
   }
+
     for(i = 0; i < num_files; i++)
     {
       free(file_list[i]);
@@ -513,16 +519,16 @@
 
 struct _menu_type
 {
-  void (* init_function)();
-  void (* passive_function)();
+  void (* init_function)(void);
+  void (* passive_function)(void);
   struct _menu_option_type *options;
   u32 num_options;
 };
 
 struct _menu_option_type
 {
-  void (* action_function)();
-  void (* passive_function)();
+  void (* action_function)(void);
+  void (* passive_function)(void);
   struct _menu_type *sub_menu;
   char *display_string;
   void *options;
@@ -556,7 +562,7 @@
   sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
   gamepad_help[gamepad_config_map[                                            \
    gamepad_config_line_to_button[number]]],                               \
-  number,                                                                     \
+  number + 1,                                                                 \
   STRING_SELECTION_OPTION                                                     \
 }                                                                             \
 
@@ -570,7 +576,7 @@
   gamepad_config_map + number + 12,                                           \
   sizeof(gamepad_config_buttons) / sizeof(gamepad_config_buttons[0]),         \
   gamepad_help[gamepad_config_map[number + 12]],                              \
-  number + 2,                                                                 \
+  number + 1,                                                                 \
   STRING_SELECTION_OPTION                                                     \
 }                                                                             \
 
@@ -581,10 +587,10 @@
   NULL,                                                                       \
   cheat_format_str[number],                                                   \
   enable_disable_options,                                                     \
-  &(game_config_cheats[number].cheat_active),                                 \
+  &(cheats[number].cheat_active),                                             \
   2,                                                                          \
   msg[MSG_CHEAT_MENU_HELP_0],                                                 \
-  (number) % 10,                                                              \
+  number + 1,                                                                 \
   STRING_SELECTION_OPTION                                                     \
 }                                                                             \
 
@@ -684,18 +690,17 @@
 u32 gamepad_config_line_to_button[] =
  { 8, 6, 7, 9, 1, 2, 3, 0, 4, 5, 11, 10 };
 
-
-// �Q�[�����Ƃ�cfg�t�@�C���̓Ǎ���
-s32 load_game_config_file()
+s8 load_game_config_file(void)
 {
+  FILE_TAG_TYPE game_config_file;
   char game_config_filename[MAX_FILE];
   char game_config_path[MAX_PATH];
-  FILE_ID game_config_file;
   u32 i;
 
   change_ext(gamepak_filename, game_config_filename, ".cfg");
 
-  if (default_cfg_dir != NULL) {
+  if(default_cfg_dir != NULL)
+  {
     sprintf(game_config_path, "%s/%s", default_cfg_dir, game_config_filename);
   }
   else
@@ -707,35 +712,35 @@
 
   if(FILE_CHECK_VALID(game_config_file))
   {
-    u32 file_size = file_length(game_config_path, game_config_file);
+    u32 file_size = file_length(game_config_path);
 
     // Sanity check: File size must be the right size
-    if(file_size == ((4 + MAX_CHEATS) * 4))
+    if(file_size == 56)
     {
       u32 file_options[file_size / 4];
 
       FILE_READ_ARRAY(game_config_file, file_options);
-      game_config_frameskip_type = file_options[0] % 3;
-      game_config_frameskip_value = file_options[1];
-      game_config_random_skip = file_options[2] % 2;
-      game_config_clock_speed = file_options[3];
-
-      if(game_config_clock_speed > 333)
-        game_config_clock_speed = 333;
 
-      if(game_config_clock_speed < 33)
-        game_config_clock_speed = 33;
+      current_frameskip_type = file_options[0] % 3;
+      frameskip_value = file_options[1];
+      random_skip = file_options[2] % 2;
+      clock_speed = file_options[3];
 
-      if(game_config_frameskip_value < 0)
-        game_config_frameskip_value = 0;
+      if(clock_speed > 333)
+        clock_speed = 333;
 
-      if(game_config_frameskip_value > 99)
-        game_config_frameskip_value = 99;
+      if(clock_speed < 33)
+        clock_speed = 33;
 
-      for(i = 0; i < MAX_CHEATS; i++)
+      clock_speed_number = (clock_speed / 33) - 1;
+
+      if(frameskip_value > 99)
+        frameskip_value = 99;
+
+      for(i = 0; i < 10; i++)
       {
-        game_config_cheats[i].cheat_active = file_options[4 + i] % 2;
-        game_config_cheats[i].cheat_name[0] = 0;
+        cheats[i].cheat_active = file_options[3 + i] % 2;
+        cheats[i].cheat_name[0] = 0;
       }
 
       FILE_CLOSE(game_config_file);
@@ -743,25 +749,25 @@
     }
   }
 
-  // �ǂݍ��߂Ȃ��B��ꍇ�̏���l�̐ݒ�
-  game_config_frameskip_type = auto_frameskip;
-  game_config_frameskip_value = 4;
-  game_config_random_skip = 0;
-  game_config_clock_speed = 333;
+  current_frameskip_type = auto_frameskip;
+  frameskip_value = 9;
+  random_skip = 0;
+  clock_speed = 333;
+  clock_speed_number = 9;
 
-  for(i = 0; i < MAX_CHEATS; i++)
+  for(i = 0; i < 10; i++)
   {
-    game_config_cheats[i].cheat_active = 0;
-    game_config_cheats[i].cheat_name[0] = 0;
+    cheats[i].cheat_active = 0;
+    cheats[i].cheat_name[0] = 0;
   }
 
   return -1;
 }
 
-s32 load_config_file()
+s8 load_config_file(void)
 {
-  char config_path[512];
-  FILE_ID config_file;
+  FILE_TAG_TYPE config_file;
+  char config_path[MAX_PATH];
 
   sprintf(config_path, "%s/%s", main_path, GPSP_CONFIG_FILENAME);
 
@@ -769,10 +775,10 @@
 
   if(FILE_CHECK_VALID(config_file))
   {
-    u32 file_size = file_length(config_path, config_file);
+    u32 file_size = file_length(config_path);
 
     // Sanity check: File size must be the right size
-    if(file_size == (23 * 4))
+    if(file_size == (22 * 4))
     {
       u32 file_options[file_size / 4];
       u32 i;
@@ -782,19 +788,16 @@
       screen_scale = file_options[0] % 3;
       screen_filter = file_options[1] % 2;
       global_enable_audio = file_options[2] % 2;
-      audio_buffer_size_number = file_options[3] % 11;
-      update_backup_flag = file_options[4] % 2;
-      global_enable_analog = file_options[5] % 2;
-      analog_sensitivity_level = file_options[6] % 8;
-
-      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+      update_backup_flag = file_options[3] % 2;
+      global_enable_analog = file_options[4] % 2;
+      analog_sensitivity_level = file_options[5] % 10;
 
       // Sanity check: Make sure there's a MENU or FRAMESKIP
       // key, if not assign to triangle
 
       for(i = 0; i < 16; i++)
       {
-        gamepad_config_map[i] = file_options[7 + i] %
+        gamepad_config_map[i] = file_options[6 + i] %
          (BUTTON_ID_NONE + 1);
 
         if(gamepad_config_map[i] == BUTTON_ID_MENU)
@@ -817,18 +820,20 @@
   return -1;
 }
 
-s32 save_game_config_file()
+s8 save_game_config_file(void)
 {
+  FILE_TAG_TYPE game_config_file;
   char game_config_filename[MAX_FILE];
   char game_config_path[MAX_PATH];
   u32 i;
-  FILE_ID game_config_file;
 
-  if(gamepak_filename[0] == 0) return -1;
+  if(gamepak_filename[0] == 0)
+    return -1;
 
   change_ext(gamepak_filename, game_config_filename, ".cfg");
 
-  if (default_cfg_dir != NULL) {
+  if(default_cfg_dir != NULL)
+  {
     sprintf(game_config_path, "%s/%s", default_cfg_dir, game_config_filename);
   }
   else
@@ -837,18 +842,19 @@
   }
 
   FILE_OPEN(game_config_file, game_config_path, WRITE);
+
   if(FILE_CHECK_VALID(game_config_file))
   {
-    u32 file_options[4 + MAX_CHEATS];
+    u32 file_options[14];
 
-    file_options[0] = game_config_frameskip_type;
-    file_options[1] = game_config_frameskip_value;
-    file_options[2] = game_config_random_skip;
-    file_options[3] = game_config_clock_speed;
+    file_options[0] = current_frameskip_type;
+    file_options[1] = frameskip_value;
+    file_options[2] = random_skip;
+    file_options[3] = clock_speed;
 
-    for(i = 0; i < MAX_CHEATS; i++)
+    for(i = 0; i < 10; i++)
     {
-      file_options[4 + i] = game_config_cheats[i].cheat_active;
+      file_options[4 + i] = cheats[i].cheat_active;
     }
 
     FILE_WRITE_ARRAY(game_config_file, file_options);
@@ -860,10 +866,10 @@
   return -1;
 }
 
-s32 save_config_file()
+s8 save_config_file(void)
 {
-  char config_path[512];
-  FILE_ID config_file;
+  FILE_TAG_TYPE config_file;
+  char config_path[MAX_PATH];
 
   sprintf(config_path, "%s/%s", main_path, GPSP_CONFIG_FILENAME);
 
@@ -873,20 +879,19 @@
 
   if(FILE_CHECK_VALID(config_file))
   {
-    u32 file_options[23];
+    u32 file_options[22];
     u32 i;
 
     file_options[0] = screen_scale;
     file_options[1] = screen_filter;
     file_options[2] = global_enable_audio;
-    file_options[3] = audio_buffer_size_number;
-    file_options[4] = update_backup_flag;
-    file_options[5] = global_enable_analog;
-    file_options[6] = analog_sensitivity_level;
+    file_options[3] = update_backup_flag;
+    file_options[4] = global_enable_analog;
+    file_options[5] = analog_sensitivity_level;
 
     for(i = 0; i < 16; i++)
     {
-      file_options[7 + i] = gamepad_config_map[i];
+      file_options[6 + i] = gamepad_config_map[i];
     }
 
     FILE_WRITE_ARRAY(config_file, file_options);
@@ -909,14 +914,15 @@
 
 u32 savestate_slot = 0;
 
-void get_savestate_snapshot(char *savestate_filename)
+static void get_savestate_snapshot(char *savestate_filename)
 {
+  FILE_TAG_TYPE savestate_file;
   u16 snapshot_buffer[240 * 160];
   char savestate_timestamp_string[80];
-  char savestate_path[1024];
-  FILE_ID savestate_file;
+  char savestate_path[MAX_PATH];
 
-  if (default_save_dir != NULL) {
+  if(default_save_dir != NULL)
+  {
     sprintf(savestate_path, "%s/%s", default_save_dir, savestate_filename);
   }
   else
@@ -928,36 +934,38 @@
 
   if(FILE_CHECK_VALID(savestate_file))
   {
-    time_t savestate_time_flat;
-    time_t local_time;
-//    u64 utc;
-//    u64 local;
-    int time_diff;
-    struct tm *current_time;
+    u64 savestate_time_flat;
+    u64 savestate_time_local;
+    pspTime state_time;
+
     FILE_READ_ARRAY(savestate_file, snapshot_buffer);
     FILE_READ_VARIABLE(savestate_file, savestate_time_flat);
 
     FILE_CLOSE(savestate_file);
 
-    sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_TIMEZONE,&time_diff);
-    local_time = savestate_time_flat + (time_diff * 60);
-
-    current_time = localtime(&local_time);
-
-    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_FMT_0, current_time->tm_year + 1900, current_time->tm_mon + 1, current_time->tm_mday,
-      current_time->tm_wday, current_time->tm_hour, current_time->tm_min, current_time->tm_sec, 0);
+    sceRtcConvertUtcToLocalTime(&savestate_time_flat, &savestate_time_local);
+    sceRtcSetTick(&state_time, &savestate_time_local);
+    int state_time_week =
+     sceRtcGetDayOfWeek(state_time.year, state_time.month, state_time.day);
+
+    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_FMT_0,
+     state_time.year, state_time.month, state_time.day, state_time_week,
+     state_time.hour, state_time.minutes, state_time.seconds, 0);
 
     savestate_timestamp_string[40] = 0;
-
-    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
+    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 50);
   }
   else
   {
     memset(snapshot_buffer, 0, 240 * 160 * 2);
-    print_string_ext(msg[MSG_STATE_MENU_STATE_NONE], 0xFFFF, 0x0000, 15, 75, snapshot_buffer, 240, 0);
-    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_NONE_0, 0, 0, 0, 0, 0, 0, 0, 0);
-    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 40);
+    print_string_ext(msg[MSG_STATE_MENU_STATE_NONE], 0xFFFF, 0x0000, 15, 75,
+     snapshot_buffer, 240, 0);
+    get_timestamp_string(savestate_timestamp_string, MSG_STATE_MENU_DATE_NONE_0,
+     0, 0, 0, 0, 0, 0, 0, 0);
+
+    print_string(savestate_timestamp_string, COLOR_HELP_TEXT, COLOR_BG, 10, 50);
   }
+
   blit_to_screen(snapshot_buffer, 240, 160, 230, 40);
 }
 
@@ -979,16 +987,8 @@
   change_ext(gamepak_filename, name_buffer, savestate_ext);
 }
 
-void _flush_cache()
-{
-//    sceKernelDcacheWritebackAll();
-    invalidate_all_cache();
-}
-
-u32 menu(u16 *original_screen)
+u8 menu(u16 *original_screen)
 {
-  u32 clock_speed_number = (game_config_clock_speed / 33) - 1;
-  char print_buffer[81];
 //  u32 _current_option = 0;
   gui_action_type gui_action;
 //  menu_enum _current_menu = MAIN_MENU;
@@ -999,7 +999,7 @@
 //  char savestate_ext[16];
   char current_savestate_filename[MAX_FILE];
   char line_buffer[80];
-  char cheat_format_str[MAX_CHEATS][41];
+  char cheat_format_str[10][41];
 
   menu_type *current_menu;
   menu_option_type *current_option;
@@ -1009,26 +1009,25 @@
   SceCtrlData ctrl_data;
 //  u32 buttons;
 
-  auto void choose_menu();
-  auto void clear_help();
-  auto void menu_exit();
-  auto void menu_quit();
-  auto void menu_load();
-  auto void menu_restart();
-  auto void menu_save_ss();
-  auto void menu_change_state();
-  auto void menu_save_state();
-  auto void menu_load_state();
-  auto void menu_load_state_file();
-  auto void menu_load_cheat_file();
-  auto void menu_fix_gamepad_help();
-  auto void submenu_graphics_sound();
-  auto void submenu_cheats_misc();
-  auto void submenu_gamepad();
-  auto void submenu_analog();
-  auto void submenu_savestate();
-  auto void submenu_main();
-  auto void reload_cheats_page();
+  auto void choose_menu(menu_type *new_menu);
+  auto void clear_help(void);
+  auto void menu_exit(void);
+  auto void menu_quit(void);
+  auto void menu_load(void);
+  auto void menu_restart(void);
+  auto void menu_save_ss(void);
+  auto void menu_change_state(void);
+  auto void menu_save_state(void);
+  auto void menu_load_state(void);
+  auto void menu_load_state_file(void);
+  auto void menu_load_cheat_file(void);
+  auto void menu_fix_gamepad_help(void);
+  auto void submenu_emulator(void);
+  auto void submenu_cheats_misc(void);
+  auto void submenu_gamepad(void);
+  auto void submenu_analog(void);
+  auto void submenu_savestate(void);
+  auto void submenu_main(void);
 
   char *gamepad_help[] =
   {
@@ -1050,32 +1049,32 @@
     msg[MSG_PAD_MENU_CFG_HELP_15],
     msg[MSG_PAD_MENU_CFG_HELP_16],
     msg[MSG_PAD_MENU_CFG_HELP_17],
+#if 0
     msg[MSG_PAD_MENU_CFG_HELP_18],
     msg[MSG_PAD_MENU_CFG_HELP_19],
+#endif
     msg[MSG_PAD_MENU_CFG_HELP_20],
     msg[MSG_PAD_MENU_CFG_HELP_21]
   };
 
-  void menu_exit()
+  void menu_exit(void)
   {
     if(!first_load)
       repeat = 0;
   }
 
-  void menu_quit()
+  void menu_quit(void)
   {
-//    game_config_clock_speed = (clock_speed_number + 1) * 33;
     save_config_file();
     quit();
   }
 
-  void menu_load()
+  void menu_load(void)
   {
-    char *file_ext[] = { ".gba", ".bin", ".zip", NULL };
-    char load_filename[512];
-    save_game_config_file();
+    char *file_ext[] = { ".gba", ".bin", ".zip", ".gbz", NULL };
+    char load_filename[MAX_FILE];
 
-//    if(!update_backup_flag)
+    save_game_config_file();
       update_backup_force();
 
     if(load_file(file_ext, load_filename, default_rom_dir) != -1)
@@ -1095,7 +1094,7 @@
     }
   }
 
-  void menu_restart()
+  void menu_restart(void)
   {
     if(!first_load)
     {
@@ -1106,29 +1105,31 @@
     }
   }
 
-  void menu_save_ss()
+  void menu_save_ss(void)
   {
+    if(!first_load)
     save_ss_bmp(original_screen);
   }
 
-  void menu_change_state()
+  void menu_change_state(void)
   {
     get_savestate_filename(savestate_slot, current_savestate_filename);
   }
 
-  void menu_save_state()
+  void menu_save_state(void)
   {
+    menu_change_state();
     if(!first_load)
     {
-      get_savestate_filename_noshot(savestate_slot,
-       current_savestate_filename);
+      get_savestate_filename_noshot(savestate_slot, current_savestate_filename);
       save_state(current_savestate_filename, original_screen);
+      blit_to_screen(original_screen, 240, 160, 230, 40);
     }
-    menu_change_state();
   }
 
-  void menu_load_state()
+  void menu_load_state(void)
   {
+    menu_change_state();
     if(!first_load)
     {
       load_state(current_savestate_filename);
@@ -1137,10 +1138,11 @@
     }
   }
 
-  void menu_load_state_file()
+  void menu_load_state_file(void)
   {
     char *file_ext[] = { ".svs", NULL };
-    char load_filename[512];
+    char load_filename[MAX_FILE];
+
     if(load_file(file_ext, load_filename, default_save_dir) != -1)
     {
       load_state(load_filename);
@@ -1153,13 +1155,10 @@
     }
   }
 
-  // ���j���[:�`�[�g�t�@�C���̃��[�h
-  void menu_load_cheat_file()
+  void menu_load_cheat_file(void)
   {
     char *file_ext[] = { ".cht", NULL };
     char load_filename[MAX_FILE];
-    u32 i;
-    
     if(load_file(file_ext, load_filename, default_cheat_dir) != -1)
     {
       add_cheats(load_filename);
@@ -1171,7 +1170,7 @@
         }
         else
         {
-          sprintf(cheat_format_str[i], msg[MSG_CHEAT_MENU_0], i, game_config_cheats[i].cheat_name);
+          sprintf(cheat_format_str[i], msg[MSG_CHEAT_MENU_0], i, cheats[i].cheat_name);
         }
       }
       choose_menu(current_menu);
@@ -1185,7 +1183,7 @@
     }
   }
 
-  void menu_fix_gamepad_help()
+  void menu_fix_gamepad_help(void)
   {
     clear_help();
     current_option->help_string =
@@ -1193,42 +1191,36 @@
      gamepad_config_line_to_button[current_option_num]]];
   }
 
-  void submenu_graphics_sound()
+  void submenu_emulator(void)
   {
-
+    print_string(msg[MSG_EMU_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
   }
 
-  void submenu_cheats_misc()
+  void submenu_cheats_misc(void)
   {
-
+    print_string(msg[MSG_CHEAT_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
   }
 
-  void submenu_gamepad()
+  void submenu_gamepad(void)
   {
-
+    print_string(msg[MSG_PAD_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
   }
 
-  void submenu_analog()
+  void submenu_analog(void)
   {
-
+    print_string(msg[MSG_A_PAD_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
   }
 
-  void submenu_savestate()
+  void submenu_savestate(void)
   {
-    print_string(msg[MSG_STATE_MENU_TITLE], COLOR_ACTIVE_ITEM, COLOR_BG, 10, 70);
+    print_string(msg[MSG_STATE_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
     menu_change_state();
   }
 
-  void submenu_main()
+  void submenu_main(void)
   {
-    strncpy(print_buffer, gamepak_filename, 80);
-    print_string(print_buffer, COLOR_ROM_INFO, COLOR_BG, 10, 10);
-    sprintf(print_buffer, "%s  %s  %s", gamepak_title,
-     gamepak_code, gamepak_maker);
-    print_string(print_buffer, COLOR_ROM_INFO, COLOR_BG, 10, 20);
-
-    get_savestate_filename_noshot(savestate_slot,
-     current_savestate_filename);
+    print_string(msg[MSG_MAIN_MENU_TITLE], COLOR_HELP_TEXT, COLOR_BG, 10, 20);
+    get_savestate_filename_noshot(savestate_slot, current_savestate_filename);
   }
 
   char *yes_no_options[] = { msg[MSG_NO], msg[MSG_YES] };
@@ -1243,12 +1235,6 @@
   char *frameskip_options[] = { msg[MSG_FS_AUTO], msg[MSG_FS_MANUAL], msg[MSG_FS_OFF] };
   char *frameskip_variation_options[] = { msg[MSG_FS_UNIFORM], msg[MSG_FS_RANDOM] };
 
-  char *audio_buffer_options[] =
-  {
-    msg[MSG_SB_2048], msg[MSG_SB_3072], msg[MSG_SB_4096], msg[MSG_SB_5120], msg[MSG_SB_6144],
-    msg[MSG_SB_7168], msg[MSG_SB_8192], msg[MSG_SB_9216], msg[MSG_SB_10240], msg[MSG_SB_11264], msg[MSG_SB_12288]
-  };
-
   char *update_backup_options[] = { msg[MSG_BK_EXITONLY], msg[MSG_BK_AUTO] };
 
   char *clock_speed_options[] =
@@ -1277,73 +1263,69 @@
     msg[MSG_PAD_MENU_CFG_15],
     msg[MSG_PAD_MENU_CFG_16],
     msg[MSG_PAD_MENU_CFG_17],
+#if 0
     msg[MSG_PAD_MENU_CFG_18],
     msg[MSG_PAD_MENU_CFG_19],
+#endif
     msg[MSG_PAD_MENU_CFG_20],
     msg[MSG_PAD_MENU_CFG_21],
   };
 
   // Marker for help information, don't go past this mark (except \n)------*
-  menu_option_type graphics_sound_options[] =
+  menu_option_type emulator_options[] =
   {
-    string_selection_option(NULL, msg[MSG_G_S_MENU_0], scale_options, &screen_scale, 3, msg[MSG_G_S_MENU_HELP_0], 2),
+    string_selection_option(NULL, msg[MSG_EMU_MENU_0], scale_options, (u32 *)(&screen_scale), 3, msg[MSG_EMU_MENU_HELP_0], 1),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_1], yes_no_options, &screen_filter, 2, msg[MSG_G_S_MENU_HELP_1], 3),
+    string_selection_option(NULL, msg[MSG_EMU_MENU_1], yes_no_options, (u32 *)(&screen_filter), 2, msg[MSG_EMU_MENU_HELP_1], 2),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_2], frameskip_options, &game_config_frameskip_type, 3, msg[MSG_G_S_MENU_HELP_2], 5),
+    string_selection_option(NULL, msg[MSG_EMU_MENU_2], frameskip_options, (u32 *)(&current_frameskip_type), 3, msg[MSG_EMU_MENU_HELP_2], 4),
 
-    numeric_selection_option(NULL, msg[MSG_G_S_MENU_3], &game_config_frameskip_value, 100, msg[MSG_G_S_MENU_HELP_3], 6),
+    numeric_selection_option(NULL, msg[MSG_EMU_MENU_3], &frameskip_value, 100, msg[MSG_EMU_MENU_HELP_3], 5),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_4], frameskip_variation_options, &game_config_random_skip, 2, msg[MSG_G_S_MENU_HELP_4], 7),
+    string_selection_option(NULL, msg[MSG_EMU_MENU_4], frameskip_variation_options, &random_skip, 2, msg[MSG_EMU_MENU_HELP_4], 6),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_G_S_MENU_HELP_5], 9),
+    string_selection_option(NULL, msg[MSG_EMU_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_EMU_MENU_HELP_5], 8),
 
-    string_selection_option(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 10, msg[MSG_G_S_MENU_HELP_6], 11),
+    string_selection_option(NULL, msg[MSG_CHEAT_MENU_2], clock_speed_options, &clock_speed_number, 10, msg[MSG_CHEAT_MENU_HELP_2], 10), 
 
-    action_option(menu_save_ss, NULL, msg[MSG_G_S_MENU_7], msg[MSG_G_S_MENU_HELP_7], 12),
+    string_selection_option(NULL, msg[MSG_CHEAT_MENU_3], update_backup_options, &update_backup_flag, 2, msg[MSG_CHEAT_MENU_HELP_3], 12), 
 
-    submenu_option(NULL, msg[MSG_G_S_MENU_8], msg[MSG_G_S_MENU_HELP_8], 14)
+    submenu_option(NULL, msg[MSG_EMU_MENU_8], msg[MSG_EMU_MENU_HELP_8], 14)
   };
 
-  make_menu(graphics_sound, submenu_graphics_sound, NULL);
+  make_menu(emulator, submenu_emulator, NULL);
 
   menu_option_type cheats_misc_options[] =
   {
-    cheat_option((10 * menu_cheat_page) + 0),
-    cheat_option((10 * menu_cheat_page) + 1),
-    cheat_option((10 * menu_cheat_page) + 2),
-    cheat_option((10 * menu_cheat_page) + 3),
-    cheat_option((10 * menu_cheat_page) + 4),
-    cheat_option((10 * menu_cheat_page) + 5),
-    cheat_option((10 * menu_cheat_page) + 6),
-    cheat_option((10 * menu_cheat_page) + 7),
-    cheat_option((10 * menu_cheat_page) + 8),
-    cheat_option((10 * menu_cheat_page) + 9),
-
-    numeric_selection_option(reload_cheats_page, "cheat page: %d", &menu_cheat_page, MAX_CHEATS_PAGE, "cheat page", 10),
-
-    action_option(menu_load_cheat_file, NULL, msg[MSG_CHEAT_MENU_1], msg[MSG_CHEAT_MENU_HELP_1], 11), 
+    cheat_option(0),
+    cheat_option(1),
+    cheat_option(2),
+    cheat_option(3),
+    cheat_option(4),
+    cheat_option(5),
+    cheat_option(6),
+    cheat_option(7),
+    cheat_option(8),
+    cheat_option(9),
 
-    string_selection_option(NULL, msg[MSG_CHEAT_MENU_2], clock_speed_options, &clock_speed_number, 10, msg[MSG_CHEAT_MENU_HELP_2], 13), 
+    action_option(menu_load_cheat_file, NULL, msg[MSG_CHEAT_MENU_1], msg[MSG_CHEAT_MENU_HELP_1], 12), 
 
-    string_selection_option(NULL, msg[MSG_CHEAT_MENU_3], update_backup_options, &update_backup_flag, 2, msg[MSG_CHEAT_MENU_HELP_3], 14), 
-
-    submenu_option(NULL, msg[MSG_CHEAT_MENU_4], msg[MSG_CHEAT_MENU_HELP_4], 16) 
+    submenu_option(NULL, msg[MSG_CHEAT_MENU_4], msg[MSG_CHEAT_MENU_HELP_4], 14)
   };
 
   make_menu(cheats_misc, submenu_cheats_misc, NULL);
 
   menu_option_type savestate_options[] =
   {
-    numeric_selection_action_hide_option(menu_load_state, menu_change_state, msg[MSG_STATE_MENU_0], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_0], 6),
+    numeric_selection_action_hide_option(menu_load_state, menu_change_state, msg[MSG_STATE_MENU_0], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_0], 4),
 
-    numeric_selection_action_hide_option(menu_save_state, menu_change_state, msg[MSG_STATE_MENU_1], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_1], 7),
+    numeric_selection_action_hide_option(menu_save_state, menu_change_state, msg[MSG_STATE_MENU_1], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_1], 5),
 
-    numeric_selection_action_hide_option(menu_load_state_file, menu_change_state, msg[MSG_STATE_MENU_2], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_2], 9),
+    numeric_selection_action_hide_option(menu_load_state_file, menu_change_state, msg[MSG_STATE_MENU_2], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_2], 7),
 
-    numeric_selection_option(menu_change_state, msg[MSG_STATE_MENU_3], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_3], 11),
+    numeric_selection_option(menu_change_state, msg[MSG_STATE_MENU_3], &savestate_slot, 10, msg[MSG_STATE_MENU_HELP_3], 9),
 
-    submenu_option(NULL, msg[MSG_STATE_MENU_4], msg[MSG_STATE_MENU_HELP_4], 13)
+    submenu_option(NULL, msg[MSG_STATE_MENU_4], msg[MSG_STATE_MENU_HELP_4], 11)
   };
 
   make_menu(savestate, submenu_savestate, NULL);
@@ -1362,36 +1344,41 @@
     gamepad_config_option(msg[MSG_PAD_MENU_9], 9),
     gamepad_config_option(msg[MSG_PAD_MENU_10], 10),
     gamepad_config_option(msg[MSG_PAD_MENU_11], 11),
-    submenu_option(NULL, msg[MSG_PAD_MENU_12], msg[MSG_PAD_MENU_HELP_0], 13)
+
+    submenu_option(NULL, msg[MSG_PAD_MENU_12], msg[MSG_PAD_MENU_HELP_0], 14)
   };
 
+  make_menu(gamepad_config, submenu_gamepad, NULL);
+
   menu_option_type analog_config_options[] =
   {
     analog_config_option(msg[MSG_A_PAD_MENU_0], 0),
     analog_config_option(msg[MSG_A_PAD_MENU_1], 1),
     analog_config_option(msg[MSG_A_PAD_MENU_2], 2),
     analog_config_option(msg[MSG_A_PAD_MENU_3], 3),
-    string_selection_option(NULL, msg[MSG_A_PAD_MENU_4], yes_no_options, &global_enable_analog, 2, msg[MSG_A_PAD_MENU_HELP_0], 7),
-    numeric_selection_option(NULL, msg[MSG_A_PAD_MENU_5], &analog_sensitivity_level, 10, msg[MSG_A_PAD_MENU_HELP_1], 8),
-    submenu_option(NULL, msg[MSG_A_PAD_MENU_6], msg[MSG_A_PAD_MENU_HELP_2], 11)
+
+    string_selection_option(NULL, msg[MSG_A_PAD_MENU_4], yes_no_options, &global_enable_analog, 2, msg[MSG_A_PAD_MENU_HELP_0], 6),
+    numeric_selection_option(NULL, msg[MSG_A_PAD_MENU_5], &analog_sensitivity_level, 10, msg[MSG_A_PAD_MENU_HELP_1], 7),
+    submenu_option(NULL, msg[MSG_A_PAD_MENU_6], msg[MSG_A_PAD_MENU_HELP_2], 9)
   };
 
-  make_menu(gamepad_config, submenu_gamepad, NULL);
   make_menu(analog_config, submenu_analog, NULL);
 
   menu_option_type main_options[] =
   {
-    submenu_option(&graphics_sound_menu, msg[MSG_MAIN_MENU_0], msg[MSG_MAIN_MENU_HELP_0], 0), 
+    numeric_selection_action_option(menu_load_state, NULL, msg[MSG_MAIN_MENU_1], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_1], 0),
 
-    numeric_selection_action_option(menu_load_state, NULL, msg[MSG_MAIN_MENU_1], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_1], 2),
+    numeric_selection_action_option(menu_save_state, NULL, msg[MSG_MAIN_MENU_2], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_2], 1),
 
-    numeric_selection_action_option(menu_save_state, NULL, msg[MSG_MAIN_MENU_2], &savestate_slot, 10, msg[MSG_MAIN_MENU_HELP_2], 3),
+    submenu_option(&savestate_menu, msg[MSG_MAIN_MENU_3], msg[MSG_MAIN_MENU_HELP_3], 2),
 
-    submenu_option(&savestate_menu, msg[MSG_MAIN_MENU_3], msg[MSG_MAIN_MENU_HELP_3], 4),
+    action_option(menu_save_ss, NULL, msg[MSG_EMU_MENU_7], msg[MSG_EMU_MENU_HELP_7], 4),
 
-    submenu_option(&gamepad_config_menu, msg[MSG_MAIN_MENU_4], msg[MSG_MAIN_MENU_HELP_4], 6),
+    submenu_option(&emulator_menu, msg[MSG_MAIN_MENU_0], msg[MSG_MAIN_MENU_HELP_0], 6), 
 
-    submenu_option(&analog_config_menu, msg[MSG_MAIN_MENU_5], msg[MSG_MAIN_MENU_HELP_5], 7),
+    submenu_option(&gamepad_config_menu, msg[MSG_MAIN_MENU_4], msg[MSG_MAIN_MENU_HELP_4], 7),
+
+    submenu_option(&analog_config_menu, msg[MSG_MAIN_MENU_5], msg[MSG_MAIN_MENU_HELP_5], 8),
 
     submenu_option(&cheats_misc_menu, msg[MSG_MAIN_MENU_6], msg[MSG_MAIN_MENU_HELP_6], 9),
 
@@ -1421,7 +1408,7 @@
      current_menu->init_function();
   }
 
-  void clear_help()
+  void clear_help(void)
   {
     for(i = 0; i < 6; i++)
     {
@@ -1429,20 +1416,12 @@
     }
   }
 
-  void reload_cheats_page()
-  {
-    for(i = 0; i<10; i++)
-    {
-      cheats_misc_options[i].display_string = cheat_format_str[(10 * menu_cheat_page) + i];
-      cheats_misc_options[i].current_option = &(game_config_cheats[(10 * menu_cheat_page) + i].cheat_active);
-    }
-  }
-
   video_resolution_large();
 
-  SDL_LockMutex(sound_mutex);
-  SDL_PauseAudio(1);
-  SDL_UnlockMutex(sound_mutex);
+  sound_volume = 0;
+
+  clock_speed_number = (clock_speed / 33) - 1;
+  set_cpu_clock(222);
 
   if(gamepak_filename[0] == 0)
   {
@@ -1451,6 +1430,12 @@
     print_string_ext(msg[MSG_NON_LOAD_GAME], 0xFFFF, 0x0000, 60, 75,original_screen, 240, 0);
   }
 
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
+    gamepak_file_large = -2;
+  }
+
   choose_menu(&main_menu);
 
   for(i = 0; i < MAX_CHEATS; i++)
@@ -1461,12 +1446,10 @@
     }
     else
     {
-      sprintf(cheat_format_str[i], msg[MSG_CHEAT_MENU_0], i, game_config_cheats[i].cheat_name);
+      sprintf(cheat_format_str[i], msg[MSG_CHEAT_MENU_0], i, cheats[i].cheat_name);
     }
   }
 
-  reload_cheats_page();
-
   current_menu->init_function();
 
   while(repeat)
@@ -1565,57 +1547,83 @@
         }
         break;
 
+      case CURSOR_RTRIGGER:
+        if(current_menu == &main_menu)
+          choose_menu(&savestate_menu);
+        break;
+
+      case CURSOR_LTRIGGER:
+        if(current_menu == &main_menu)
+          menu_load();
+        break;
+
       case CURSOR_EXIT:
         if(current_menu == &main_menu)
           menu_exit();
-
+        else
         choose_menu(&main_menu);
         break;
 
       case CURSOR_SELECT:
         if(current_option->option_type & ACTION_OPTION)
           current_option->action_function();
-
+        else
         if(current_option->option_type & SUBMENU_OPTION)
           choose_menu(current_option->sub_menu);
         break;
-
-      default:
-        ;
-        break;
     }
   }
 
 // menu�I�����̏���
 
+  if(gamepak_file_large == -2)
+  {
+    for(i = 0; i < 5; i++)
+    {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    clear_screen(0x0000);
+    error_msg("Failed to load gemepak.\n\nPress any button to exit.");
+    quit();
+
+    success_open_gamepak:;
+  }
+
   while(sceCtrlPeekBufferPositive(&ctrl_data, 1), ctrl_data.Buttons != 0);
 
   set_gba_resolution(screen_scale);
   video_resolution_small();
 
-  game_config_clock_speed = (clock_speed_number + 1) * 33;
-
-  scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+  clock_speed = ((clock_speed_number + 1) * 333) / 10;
+  set_cpu_clock(clock_speed);
 
-  SDL_PauseAudio(0);
+  sound_volume = PSP_AUDIO_VOLUME_MAX;
 
   return return_value;
 }
 
-u32 load_dircfg(char *file_name)
+s8 load_dircfg(char *file_name)
 {
   int loop;
   int next_line;
   char current_line[256];
-  char current_str[256];
-  FILE *msg_file;
-  char msg_path[512];
+  char current_str[MAX_FILE];
+
+  char error_str[256];
+  u16 error_str_line = 5;
 
-  sprintf(msg_path, "%s/%s", main_path, file_name);
+  FILE *msg_file;
 
-  msg_file = fopen(msg_path, "r");
+  msg_file = fopen(file_name, "r");
 
   next_line = 0;
+
   if(msg_file)
   {
     loop = 0;
@@ -1623,64 +1631,87 @@
     {
       if(parse_line(current_line, current_str) != -1)
       {
+        if(strncmp(current_str, "ms0:/", 5) != 0)
+        {
+          u16 main_path_len = strlen(main_path);
+          u16 current_str_len = strlen(current_str) + 1;
+          memmove(current_str + main_path_len - 1, current_str, current_str_len);
+          memmove(current_str, main_path, main_path_len);
+        }
+
         switch(loop)
         {
           case 0:
             if(opendir(current_str) != NULL)
+            {
               strcpy(default_rom_dir,current_str);
+            }
             else
             {
               *default_rom_dir = (char)NULL;
-              printf("not open rom dir : %s\n",current_str);
-              delay_us(500000);
+              sprintf(error_str, "not open rom dir : %s\n", current_str);
+              print_string(error_str, 0xFFFF, 0x0000, 5, error_str_line);
+              error_str_line += 10;
             }
             loop++;
             break;
 
           case 1:
             if(opendir(current_str) != NULL)
+            {
               strcpy(default_save_dir,current_str);
+            }
             else
             {
               *default_save_dir = (char)NULL;
-              printf("not open save dir : %s\n",current_str);
-              delay_us(500000);
+              sprintf(error_str, "not open save dir : %s\n", current_str);
+              print_string(error_str, 0xFFFF, 0x0000, 5, error_str_line);
+              error_str_line += 10;
             }
             loop++;
             break;
 
           case 2:
             if(opendir(current_str) != NULL)
+            {
               strcpy(default_cfg_dir,current_str);
+            }
             else
             {
               *default_cfg_dir = (char)NULL;
-              printf("not open cfg dir : %s\n",current_str);
-              delay_us(500000);
+              sprintf(error_str, "not open cfg dir : %s\n", current_str);
+              print_string(error_str, 0xFFFF, 0x0000, 5, error_str_line);
+              error_str_line += 10;
             }
             loop++;
             break;
 
           case 3:
             if(opendir(current_str) != NULL)
+            {
               strcpy(default_ss_dir,current_str);
+            }
             else
             {
               *default_ss_dir = (char)NULL;
-              printf("not open screen shot dir : %s\n",current_str);
-              delay_us(500000);
+              sprintf(error_str, "not open screen shot dir : %s\n", current_str);
+              print_string(error_str, 0xFFFF, 0x0000, 5, error_str_line);
+              error_str_line += 10;
             }
             loop++;
             break;
 
           case 4:
             if(opendir(current_str) != NULL)
+            {
               strcpy(default_cheat_dir,current_str);
+            }
             else
             {
               *default_cheat_dir = (char)NULL;
-              printf("not open cheat dir : %s\n",current_str);
-              delay_us(500000);
+              sprintf(error_str, "not open cheat dir : %s\n", current_str);
+              print_string(error_str, 0xFFFF, 0x0000, 5, error_str_line);
+              error_str_line += 10;
             }
             loop++;
             break;
@@ -1687,8 +1718,14 @@
         }
       }
     }
-    
     fclose(msg_file);
+
+    if(error_str_line > 5)
+    {
+      print_string("Press any button.\n", 0xFFFF, 0x0000, 5, error_str_line + 10);
+      error_msg("");
+    }
+
     if (loop == 5)
     {
       return 0;
@@ -1702,18 +1740,15 @@
   return -1;
 }
 
-u32 load_fontcfg(char *file_name)
+s8 load_fontcfg(char *file_name)
 {
   int loop;
   int next_line;
   char current_line[256];
   char current_str[256];
   FILE *msg_file;
-  char msg_path[512];
-
-  sprintf(msg_path, "%s/%s", main_path, file_name);
 
-  msg_file = fopen(msg_path, "r");
+  msg_file = fopen(file_name, "r");
 
   next_line = 0;
   if(msg_file)
@@ -1751,18 +1787,15 @@
   return -1;
 }
 
-u32 load_msgcfg(char *file_name)
+s8 load_msgcfg(char *file_name)
 {
   int loop;
   int next_line;
   char current_line[256];
   char current_str[256];
   FILE *msg_file;
-  char msg_path[512];
-
-  sprintf(msg_path, "%s/%s", main_path, file_name);
 
-  msg_file = fopen(msg_path, "r");
+  msg_file = fopen(file_name, "r");
 
   next_line = 0;
   if(msg_file)
@@ -1804,7 +1838,7 @@
   return -1;
 }
 
-u32 parse_line(char *current_line, char *current_str)
+static s8 parse_line(char *current_line, char *current_str)
 {
   char *line_ptr;
   char *line_ptr_new;
@@ -1842,69 +1876,104 @@
   return 0;
 }
 
-u32 load_font()
+s8 load_font(void)
 {
     return fbm_init(font8,font16,1);
 }
 
-void print_status()
+static void print_status(void)
 {
   char print_buffer_1[256];
   char print_buffer_2[256];
-  pspTime current_time;
 
+  pspTime current_time;
   sceRtcGetCurrentClockLocalTime(&current_time);
-  int wday = sceRtcGetDayOfWeek(current_time.year, current_time.month , current_time.day);
+  int current_week =
+   sceRtcGetDayOfWeek(current_time.year, current_time.month , current_time.day);
 
-  get_timestamp_string(print_buffer_1, MSG_MENU_DATE_FMT_0, current_time.year, current_time.month , current_time.day, wday,
+  get_timestamp_string(print_buffer_1, MSG_MENU_DATE_FMT_0,
+   current_time.year, current_time.month , current_time.day, current_week,
     current_time.hour, current_time.minutes, current_time.seconds, 0);
-  sprintf(print_buffer_2,"%s%s", msg[MSG_MENU_DATE], print_buffer_1);
-  print_string(print_buffer_2, COLOR_HELP_TEXT, COLOR_BG, 0, 0);
 
-  sprintf(print_buffer_1, msg[MSG_MENU_BATTERY], scePowerGetBatteryLifePercent(), scePowerGetBatteryLifeTime());
-  print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 0);
+  print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 250, 1);
 
-//  sprintf(print_buffer_1, "TOTAL FREE:%04dkb  MAX FREE:%04dkb", sceKernelTotalFreeMemSize()/1024, sceKernelMaxFreeMemSize()/1024);
-//  print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 10);
+  int batt_life_per = scePowerGetBatteryLifePercent();
 
-  sprintf(print_buffer_1, "MAX ROM BUF: %02d MB", (int)(gamepak_ram_buffer_size/1024/1024));
-  print_string(print_buffer_1, COLOR_HELP_TEXT, COLOR_BG, 240, 10);
+  if(batt_life_per < 0)
+  {
+    strcpy(print_buffer_2, "BATT. --%");
+  }
+  else
+  {
+    sprintf(print_buffer_2, "BATT.%3d%%", batt_life_per);
 }
 
-void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
+  if(scePowerIsPowerOnline())
+  {
+    strcat(print_buffer_2, "[DC IN]");
+  }
+  else
+  {
+    int batt_life_time = scePowerGetBatteryLifeTime();
+    int batt_life_hour = (batt_life_time / 60) % 100;
+    int batt_life_min = batt_life_time % 60;
+
+    if(batt_life_time < 0)
+    {
+      strcat(print_buffer_2, "[--:--]");
+    }
+    else
+    {
+      sprintf(print_buffer_1, "[%2d:%02d]", batt_life_hour, batt_life_min);
+      strcat(print_buffer_2, print_buffer_1);
+    }
+  }
+
+  print_string(print_buffer_2, COLOR_HELP_TEXT, COLOR_BG, 380, 1);
+}
+
+static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon,
+ u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
 {
-  int id;
   char *weekday_strings[] =
   {
     msg[MSG_WDAY_0], msg[MSG_WDAY_1], msg[MSG_WDAY_2], msg[MSG_WDAY_3],
     msg[MSG_WDAY_4], msg[MSG_WDAY_5], msg[MSG_WDAY_6], ""
   };
 
-  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
-  switch(id)
+  switch(date_format)
   {
     case PSP_SYSTEMPARAM_DATE_FORMAT_YYYYMMDD:
-      sprintf(buffer, msg[msg_id    ], year, mon, day, weekday_strings[wday], hour, min, sec, msec / 1000);
+      sprintf(buffer, msg[msg_id    ], year, mon, day, weekday_strings[wday],
+       hour, min, sec, msec / 1000);
       break;
+
     case PSP_SYSTEMPARAM_DATE_FORMAT_MMDDYYYY:
-      sprintf(buffer, msg[msg_id + 1], weekday_strings[wday], mon, day, year, hour, min, sec, msec / 1000);
+      sprintf(buffer, msg[msg_id + 1], weekday_strings[wday], mon, day, year,
+       hour, min, sec, msec / 1000);
       break;
+
     case PSP_SYSTEMPARAM_DATE_FORMAT_DDMMYYYY:
-      sprintf(buffer, msg[msg_id + 2], weekday_strings[wday], day, mon, year, hour, min, sec, msec / 1000);
+      sprintf(buffer, msg[msg_id + 2], weekday_strings[wday], day, mon, year,
+       hour, min, sec, msec / 1000);
       break;
   }
 }
 
-void save_ss_bmp(u16 *image)
+static void save_ss_bmp(u16 *image)
 {
-  static unsigned char header[] ={ 'B',  'M',  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
-                                   0x00, 0x00,  240, 0x00, 0x00, 0x00,  160, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
-                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+  static unsigned char header[] =
+  {  'B',  'M', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
+     240, 0x00, 0x00, 0x00,  160, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+  };
 
-  char ss_filename[512];
-  char timestamp[512];
-  char save_ss_path[1024];
+  char ss_filename[MAX_FILE];
+  char timestamp[MAX_FILE];
+  char save_ss_path[MAX_PATH];
   pspTime current_time;
   u8 rgb_data[160][240][3];
   u8 x,y;
@@ -1915,10 +1984,12 @@
 
   change_ext(gamepak_filename, ss_filename, "_");
 
-  get_timestamp_string(timestamp, MSG_SS_FMT_0, current_time.year, current_time.month , current_time.day, 7,
-    current_time.hour, current_time.minutes, current_time.seconds, current_time.microseconds);
+  get_timestamp_string(timestamp, MSG_SS_FMT_0, current_time.year,
+   current_time.month , current_time.day, 7, current_time.hour,
+   current_time.minutes, current_time.seconds, current_time.microseconds);
 
-  if (default_ss_dir != NULL) {
+  if(default_ss_dir != NULL)
+  {
     sprintf(save_ss_path, "%s/%s%s.bmp", default_ss_dir, ss_filename, timestamp);
   }
   else
@@ -1931,12 +2002,12 @@
     for(x = 0; x < 240; x++)
     {
       col = image[x + y * 240];
-      r = (col >> 11);
-      g = (col >> 5) & 0x3F;
+      r = (col >> 10) & 0x1F;
+      g = (col >> 5) & 0x1F;
       b = (col) & 0x1F;
 
       rgb_data[159-y][x][2] = b * 255 / 31;
-      rgb_data[159-y][x][1] = g * 255 / 63;
+      rgb_data[159-y][x][1] = g * 255 / 31;
       rgb_data[159-y][x][0] = r * 255 / 31;
     }
   }
@@ -1949,3 +2020,9 @@
     fclose( ss );
 
 }
+
+void _flush_cache(void)
+{
+  invalidate_all_cache();
+}
+
diff -ruibwEB --strip-trailing-cr -I RE old/gui.h mod/gui.h
--- old/gui.h	2007-08-26 00:49:55.093782600 +0900
+++ mod/gui.h	2007-10-27 22:41:57.057632000 +0900
@@ -21,37 +21,29 @@
 #ifndef GUI_H
 #define GUI_H
 
-#define GPSP_CONFIG_FILENAME "gpsp.cfg"
+#define GPSP_CONFIG_FILENAME "gpsp_mod.cfg"
 
-s32 load_file(char **wildcards, char *result, char *default_dir_name);
-u32 adjust_frameskip(u32 button_id);
-s32 load_game_config_file();
-s32 load_config_file();
-s32 save_game_config_file();
-s32 save_config_file();
-u32 menu(u16 *original_screen);
-
-u32 load_dircfg(char *file_name);
-u32 load_fontcfg(char *file_name);
-u32 load_msgcfg(char *file_name);
-u32 parse_line(char *current_line, char *current_str);
-u32 load_font();
-
-void print_status();
-void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec);
-void save_ss_bmp(u16 *image);
+s8 load_file(char **wildcards, char *result, char *default_dir_name);
+s8 load_game_config_file(void);
+s8 load_config_file(void);
+s8 save_game_config_file(void);
+s8 save_config_file(void);
+u8 menu(u16 *original_screen);
+
+s8 load_dircfg(char *file_name);
+s8 load_fontcfg(char *file_name);
+s8 load_msgcfg(char *file_name);
+s8 load_font(void);
 
 extern u32 savestate_slot;
 
 void get_savestate_filename_noshot(u32 slot, char *name_buffer);
 void get_savestate_filename(u32 slot, char *name_buffer);
-void get_savestate_snapshot(char *savestate_filename);
 
-extern char default_rom_dir[512];
-extern char default_save_dir[512];
-extern char default_cfg_dir[512];
-extern char default_ss_dir[512];
-extern char default_cheat_dir[512];
-
-#endif
+extern char default_rom_dir[MAX_PATH];
+extern char default_save_dir[MAX_PATH];
+extern char default_cfg_dir[MAX_PATH];
+extern char default_ss_dir[MAX_PATH];
+extern char default_cheat_dir[MAX_PATH];
 
+#endif /* GUI_H */
diff -ruibwEB --strip-trailing-cr -I RE old/input.c mod/input.c
--- old/input.c	2007-08-26 00:49:54.912782600 +0900
+++ mod/input.c	2007-10-27 22:42:03.737236800 +0900
@@ -20,9 +20,12 @@
 
 #include "common.h"
 
+static void trigger_key(u32 key);
+
+
 // Special thanks to psp298 for the analog->dpad code!
 
-void trigger_key(u32 key)
+static void trigger_key(u32 key)
 {
   u32 p1_cnt = io_registers[REG_P1CNT];
 //  u32 p1;
@@ -66,8 +69,6 @@
   BUTTON_ID_RIGHT
 };
 
-extern u32 psp_fps_debug;
-
 u32 global_enable_analog = 1;
 u32 analog_sensitivity_level = 4;
 
@@ -87,10 +88,14 @@
 u32 button_repeat = 0;
 gui_action_type cursor_repeat = CURSOR_NONE;
 
+u8 enable_motion_sensor;
+u16 motion_sensorX;
+u16 motion_sensorY;
+
 #define BUTTON_REPEAT_START    200000
 #define BUTTON_REPEAT_CONTINUE 50000
 
-gui_action_type get_gui_input()
+GUI_ACTION_TYPE get_gui_input(void)
 {
   SceCtrlData ctrl_data;
   gui_action_type new_button = CURSOR_NONE;
@@ -104,8 +109,9 @@
     quit();
 
   sceCtrlPeekBufferPositive(&ctrl_data, 1);
-  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
+  if(!(ctrl_data.Buttons & PSP_CTRL_HOLD))
+  {
   if(ctrl_data.Lx < analog_sensitivity)
     ctrl_data.Buttons = PSP_CTRL_LEFT;
 
@@ -117,6 +123,9 @@
 
   if(ctrl_data.Ly > inv_analog_sensitivity)
     ctrl_data.Buttons = PSP_CTRL_DOWN;
+  }
+
+  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
   new_buttons = (last_buttons ^ ctrl_data.Buttons) & ctrl_data.Buttons;
   last_buttons = ctrl_data.Buttons;
@@ -245,7 +254,7 @@
 
 u32 rapidfire_flag = 1;
 
-u32 update_input()
+u32 update_input(void)
 {
   SceCtrlData ctrl_data;
   u32 buttons;
@@ -256,11 +265,26 @@
   u32 analog_sensitivity = 92 - (analog_sensitivity_level * 4);
   u32 inv_analog_sensitivity = 256 - analog_sensitivity;
 
+  motion_sensorX = 0x800;
+  motion_sensorY = 0x800;
+
   sceCtrlPeekBufferPositive(&ctrl_data, 1);
 
   buttons = ctrl_data.Buttons;
 
-  if(global_enable_analog)
+  if((global_enable_analog) && !(ctrl_data.Buttons & PSP_CTRL_HOLD))
+  {
+    if(enable_motion_sensor)
+    {
+      if((ctrl_data.Lx < analog_sensitivity) ||
+         (ctrl_data.Lx > inv_analog_sensitivity))
+        motion_sensorX = (0xFF - ctrl_data.Lx) * 16;
+
+      if((ctrl_data.Ly < analog_sensitivity) ||
+         (ctrl_data.Ly > inv_analog_sensitivity))
+        motion_sensorY = (0xFF - ctrl_data.Ly) * 16;
+    }
+    else
   {
     if(ctrl_data.Lx < analog_sensitivity)
       buttons |= PSP_CTRL_ANALOG_LEFT;
@@ -274,6 +298,7 @@
     if(ctrl_data.Ly > inv_analog_sensitivity)
       buttons |= PSP_CTRL_ANALOG_DOWN;
   }
+  }
 
   non_repeat_buttons = (last_buttons ^ buttons) & buttons;
   last_buttons = buttons;
@@ -316,14 +341,7 @@
       case BUTTON_ID_FASTFORWARD:
         print_string("FASTFORWARD", 0xFFFF, 0x0000, 0, 50);
         synchronize_flag ^= 1;
-        return 0;
-
-      case BUTTON_ID_VOLUP:
-//        gp2x_sound_volume(1);
-        break;
-
-      case BUTTON_ID_VOLDOWN:
-//        gp2x_sound_volume(0);
+//        return 0;
         break;
 
       case BUTTON_ID_FPS:
@@ -368,7 +386,7 @@
   return 0;
 }
 
-void init_input()
+void init_input(void)
 {
   sceCtrlSetSamplingCycle(0);
   sceCtrlSetSamplingMode(PSP_CTRL_MODE_ANALOG);
@@ -380,9 +399,9 @@
   FILE_##type##_VARIABLE(savestate_file, key);                                \
 }                                                                             \
 
-void input_read_savestate(FILE_TAG_TYPE savestate_file)                   \
+void input_read_savestate(FILE_TAG_TYPE savestate_file)
 input_savestate_body(READ);
 
-void input_write_mem_savestate(FILE_TAG_TYPE savestate_file)                   \
+void input_write_mem_savestate(FILE_TAG_TYPE savestate_file)
 input_savestate_body(WRITE_MEM);
 
diff -ruibwEB --strip-trailing-cr -I RE old/input.h mod/input.h
--- old/input.h	2007-08-26 00:49:54.928782600 +0900
+++ mod/input.h	2007-10-27 22:42:09.866049600 +0900
@@ -56,8 +56,6 @@
   BUTTON_ID_RAPIDFIRE_B,
   BUTTON_ID_RAPIDFIRE_L,
   BUTTON_ID_RAPIDFIRE_R,
-  BUTTON_ID_VOLUP,
-  BUTTON_ID_VOLDOWN,
   BUTTON_ID_FPS,
   BUTTON_ID_NONE
 } input_buttons_id_type;
@@ -76,9 +74,9 @@
   CURSOR_LTRIGGER
 } gui_action_type;
 
-void init_input();
-u32 update_input();
-gui_action_type get_gui_input();
+void init_input(void);
+u32 update_input(void);
+GUI_ACTION_TYPE get_gui_input(void);
 gui_action_type get_gui_input_fs_hold(u32 button_id);
 void input_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void input_read_savestate(FILE_TAG_TYPE savestate_file);
@@ -87,5 +85,8 @@
 extern u32 global_enable_analog;
 extern u32 analog_sensitivity_level;
 
-#endif
+extern u8 enable_motion_sensor;
+extern u16 motion_sensorX;
+extern u16 motion_sensorY;
 
+#endif /* INPUT_H */
diff -ruibwEB --strip-trailing-cr -I RE old/main.c mod/main.c
--- old/main.c	2007-08-26 00:49:55.000000000 +0900
+++ mod/main.c	2007-10-27 22:42:17.847526400 +0900
@@ -18,74 +18,65 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/******************************************************************************
- * �w�b�_�t�@�C���̓Ǎ���
- ******************************************************************************/
 #include "common.h"
 
-// SDL��g�p���Ă���̕s�K�v
-//PSP_MODULE_INFO("gpSP", 0x1000, 0, 9);
-//PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_USER | PSP_THREAD_ATTR_VFPU);
-
-/******************************************************************************
- * �ϐ��̒�`
- ******************************************************************************/
+PSP_MODULE_INFO("gpSP", PSP_MODULE_USER, 0, 9);
+PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_USER | PSP_THREAD_ATTR_VFPU);
 
-TIMER_TYPE timer[4];
-
-// �t���[���X�L�b�v�̎��
-u32 game_config_frameskip_type = auto_frameskip;
+int main(int argc, char *argv[]);
 
-// �t���[���X�L�b�v��
-u32 game_config_frameskip_value = 4;
+static void init_main(void);
+static void vblank_interrupt_handler(u32 sub, u32 *parg);
 
-// �����_���X�L�b�v
-u32 game_config_random_skip = 0;
+static void loop_sleep(void);
+static int SetupCallbacks(void);
+static int exit_callback(int arg1, int arg2, void *common);
+static int power_callback(int unknown, int powerInfo, void *arg);
+static int CallbackThread(SceSize args, void *argp);
 
-// �N���b�N��
-u32 game_config_clock_speed = 333;
 
+TIMER_TYPE timer[4];
 
-u32 global_cycles_per_instruction = 1;
-u64 frame_count_initial_timestamp = 0;
-u64 last_frame_interval_timestamp;
-u32 psp_fps_debug = 0;
-u32 skip_next_frame = 0;
-u32 frameskip_counter = 0;
+FRAMESKIP_TYPE current_frameskip_type = auto_frameskip;
+u32 frameskip_value = 9;
+u32 random_skip = 0;
+u32 clock_speed = 333;
+u32 update_backup_flag = 1;
 
 u32 cpu_ticks = 0;
-u32 frame_ticks = 0;
-
+// u32 frame_ticks = 0;
 u32 execute_cycles = 960;
-s32 video_count = 960;
-u32 ticks;
 
-u32 arm_frame = 0;
-u32 thumb_frame = 0;
-u32 last_frame = 0;
-
-u32 cycle_memory_access = 0;
-u32 cycle_pc_relative_access = 0;
-u32 cycle_sp_relative_access = 0;
-u32 cycle_block_memory_access = 0;
-u32 cycle_block_memory_sp_access = 0;
-u32 cycle_block_memory_words = 0;
-u32 cycle_dma16_words = 0;
-u32 cycle_dma32_words = 0;
+// u32 cycle_dma16_words = 0;
+// u32 cycle_dma32_words = 0;
 
-u32 synchronize_flag = 1;
+// u32 arm_frame = 0;
+// u32 thumb_frame = 0;
+// u32 last_frame = 0;
 
-u32 update_backup_flag = 1;
+char main_path[MAX_PATH];
 
-u32 hold_state = 0;
+int date_format;
 
-char main_path[MAX_PATH];
+u8 sleep_flag;
+u8 quit_flag;
 
-u32 quit_flag;
-u32 power_flag;
+u8 psp_fps_debug = 0;
 
-char *lang[9] =
-  { "japanese",   // 0
+u8 synchronize_flag = 1;
+u8 skip_next_frame = 0;
+
+u32 real_frame_count = 0;
+u32 virtual_frame_count = 0;
+
+
+static s32 video_count = 960;
+
+static int lang_num;
+
+static char *lang[9] =
+{
+  "japanese",   // 0
     "english",    // 1
     "french",     // 2
     "spanish",    // 3
@@ -96,81 +87,91 @@
     "Russia"      // 8
     };
 
-int lang_num;
+static u8 num_skipped_frames = 0;
+// static u64 frame_count_initial_timestamp = 0;
 
-u32 prescale_table[] = { 0, 6, 8, 10 };
+static u64 last_frame_interval_timestamp;
+static u8 frameskip_counter = 0;
 
-char *file_ext[] = { ".gba", ".bin", ".zip", NULL };
+static u64 last_screen_timestamp = 0;
+// u32 frame_speed = 15000;
+
+static u8 interval_skipped_frames;
+static u8 frames;
+// u8 skipped_frames = 0;
+static u32 ticks_needed_total = 0;
+static const u8 frame_interval = 60;
 
-/******************************************************************************
- * �}�N�����̒�`
- ******************************************************************************/
 
 #define CHECK_COUNT(count_var)                                                \
-  if((count_var) < execute_cycles)                                            \
+  if(count_var < execute_cycles)                                              \
+  {                                                                           \
     execute_cycles = count_var;                                               \
+  }                                                                           \
 
 #define check_timer(timer_number)                                             \
   if(timer[timer_number].status == TIMER_PRESCALE)                            \
+  {                                                                           \
     CHECK_COUNT(timer[timer_number].count);                                   \
+  }                                                                           \
 
-#define update_timer(timer_number)                                            \
-  if(timer[timer_number].status != TIMER_INACTIVE)                            \
+#define update_timer(num) /* num = timer_number */                            \
+  if(timer[num].status != TIMER_INACTIVE)                                     \
   {                                                                           \
-    if(timer[timer_number].status != TIMER_CASCADE)                           \
+    if(timer[num].status != TIMER_CASCADE)                                    \
     {                                                                         \
-      timer[timer_number].count -= execute_cycles;                            \
-      io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+      timer[num].count -= execute_cycles;                                     \
+      io_registers[REG_TM##num##D] =                                          \
+       (0x10000 - (timer[num].count >> timer[num].prescale)) & 0xFFFF;        \
     }                                                                         \
                                                                               \
-    if(timer[timer_number].count <= 0)                                        \
+    if(timer[num].count <= 0)                                                 \
     {                                                                         \
-      if(timer[timer_number].irq == TIMER_TRIGGER_IRQ)                        \
-        irq_raised |= IRQ_TIMER##timer_number;                                \
+      if(timer[num].irq == TIMER_TRIGGER_IRQ)                                 \
+      {                                                                       \
+        irq_raised |= IRQ_TIMER##num;                                         \
+      }                                                                       \
                                                                               \
-      if((timer_number != 3) &&                                               \
-       (timer[timer_number + 1].status == TIMER_CASCADE))                     \
+      if((num != 3) && (timer[num + 1].status == TIMER_CASCADE))              \
       {                                                                       \
-        timer[timer_number + 1].count--;                                      \
-        io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
-        0xFFFF   - (timer[timer_number + 1].count);                          \
+        timer[num + 1].count--;                                               \
+        io_registers[REG_TM0D + (num + 1) * 2] =                              \
+         (0x10000 - timer[num + 1].count) & 0xFFFF;                           \
       }                                                                       \
                                                                               \
-      if(timer_number < 2)                                                    \
+      u32 timer_reload = timer[num].reload << timer[num].prescale;            \
+                                                                              \
+      if((num < 2) && (timer[num].direct_sound_channels))                     \
+      {                                                                       \
+        if(timer[num].direct_sound_channels & 0x01)                           \
       {                                                                       \
-        if(timer[timer_number].direct_sound_channels & 0x01)                  \
-          sound_timer(timer[timer_number].frequency_step, 0);                 \
+          sound_timer(timer[num].frequency_step, 0);                          \
+        }                                                                     \
                                                                               \
-        if(timer[timer_number].direct_sound_channels & 0x02)                  \
-          sound_timer(timer[timer_number].frequency_step, 1);                 \
+        if(timer[num].direct_sound_channels & 0x02)                           \
+        {                                                                     \
+          sound_timer(timer[num].frequency_step, 1);                          \
       }                                                                       \
                                                                               \
-      timer[timer_number].count +=                                            \
-       (timer[timer_number].reload << timer[timer_number].prescale);          \
-      io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+        if(timer[num].reload_update)                                          \
+        {                                                                     \
+          sound_update_frequency_step(num);                                   \
+          timer[num].reload_update = 0;                                       \
+        }                                                                     \
+      }                                                                       \
+                                                                              \
+      timer[num].count += timer_reload;                                       \
+      io_registers[REG_TM##num##D] =                                          \
+       (0x10000 - (timer[num].count >> timer[num].prescale)) & 0xFFFF;        \
     }                                                                         \
   }                                                                           \
-
-// ���[�J���֐��̐錾
-void vblank_interrupt_handler(u32 sub, u32 *parg);
-void init_main();
-int main(int argc, char *argv[]);
-void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str);
-void trigger_ext_event();
-u32 check_power();
-int exit_callback(int arg1, int arg2, void *common);
-int power_callback(int unknown, int powerInfo, void *common);
-int CallbackThread(SceSize args, void *argp);
-int SetupCallbacks();
-
 
 
+char *file_ext[] = { ".gba", ".bin", ".zip", ".gbz", NULL };
 
-void init_main()
+void init_main(void)
 {
-  u32 i;
+  u8 i;
 
   skip_next_frame = 0;
 
@@ -180,294 +181,159 @@
     dma[i].direct_sound_channel = DMA_NO_DIRECT_SOUND;
     timer[i].status = TIMER_INACTIVE;
     timer[i].reload = 0x10000;
-    timer[i].stop_cpu_ticks = 0;
+    timer[i].reload_update = 0;
+    timer[i].direct_sound_channels = TIMER_DS_CHANNEL_NONE;
   }
 
-  timer[0].direct_sound_channels = TIMER_DS_CHANNEL_BOTH;
-  timer[1].direct_sound_channels = TIMER_DS_CHANNEL_NONE;
-
   cpu_ticks = 0;
-  frame_ticks = 0;
+//  frame_ticks = 0;
 
   execute_cycles = 960;
   video_count = 960;
 
-  bios_mode = USE_BIOS;
-
   flush_translation_cache_rom();
   flush_translation_cache_ram();
   flush_translation_cache_bios();
 }
 
-// SDL.h�ɂ��ASDL_main�Ƃ��Ē�`�����
+
+#define load_setting_cfg()                                                    \
+{                                                                             \
+  sprintf(filename, "%s/settings/%s.fnt", main_path, lang[lang_num]);         \
+  if(load_fontcfg(filename) != 0)                                             \
+  {                                                                           \
+    quit();                                                                   \
+  }                                                                           \
+                                                                              \
+  if(load_font() != 0)                                                        \
+  {                                                                           \
+    quit();                                                                   \
+  }                                                                           \
+                                                                              \
+  sprintf(filename, "%s/settings/dir.cfg", main_path);                        \
+  if(load_dircfg(filename) != 0)                                              \
+  {                                                                           \
+    error_msg("dir.cfg error.\n\nPress any button to exit.\n");               \
+    quit();                                                                   \
+  }                                                                           \
+                                                                              \
+  sprintf(filename, "%s/settings/%s.msg", main_path, lang[lang_num]);         \
+  if(load_msgcfg(filename) != 0)                                              \
+  {                                                                           \
+    error_msg("message.cfg error.\n\nPress any button to exit.\n");           \
+    quit();                                                                   \
+  }                                                                           \
+}                                                                             \
+
+#define load_bios_file()                                                      \
+{                                                                             \
+  sprintf(filename, "%s/gba_bios.bin", main_path);                            \
+  s8 bios_ret = load_bios(filename);                                          \
+                                                                              \
+  if(bios_ret == -1)                                                          \
+  {                                                                           \
+    print_string(msg[MSG_ERR_BIOS_1], 0xFFFF, 0x0000, 5, 5);                  \
+    print_string(msg[MSG_ERR_BIOS_2], 0xFFFF, 0x0000, 5, 65);                 \
+    error_msg("");                                                            \
+    quit();                                                                   \
+  }                                                                           \
+                                                                              \
+  if(bios_ret == -2)                                                          \
+  {                                                                           \
+    error_msg(msg[MSG_ERR_BIOS_MD5]);                                         \
+    quit();                                                                   \
+  }                                                                           \
+}                                                                             \
+
 int main(int argc, char *argv[])
 {
-//  u32 i;
-//  u32 vcount = 0;
-//  u32 ticks;
-//  u32 dispstat;
-  char load_filename[512];
-  char filename[512];
+  char load_filename[MAX_FILE];
+  char filename[MAX_FILE];
+
+  gamepak_filename[0] = 0;
+  gamepak_filename_raw[0] = 0;
 
-  quit_flag = 0;
-  power_flag = 0;
   SetupCallbacks();
 
-  sceKernelRegisterSubIntrHandler(PSP_VBLANK_INT, 0, vblank_interrupt_handler, NULL);
+  sceKernelRegisterSubIntrHandler(PSP_VBLANK_INT, 0, vblank_interrupt_handler,
+   NULL);
   sceKernelEnableSubIntr(PSP_VBLANK_INT, 0);
-  dbg_file = fopen(DBG_FILE_NAME, "awb");
-
-  // Copy the directory path of the executable into main_path
-  getcwd(main_path, 512);
 
   sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_LANGUAGE, &lang_num);
-
-  if (load_dircfg("settings/dir.cfg") != 0)
-  {
-    error_msg("dir.cfg Error!!");
-    quit();
-  }
-
-  sprintf(filename,"settings/%s.fnt",lang[lang_num]);
-  if (load_fontcfg(filename) != 0)
-  {
-    error_msg("font.cfg Error!!");
-    quit();
-  }
-
-  sprintf(filename,"settings/%s.msg",lang[lang_num]);
-  if (load_msgcfg(filename) != 0)
-  {
-    error_msg("message.cfg Error!!");
-    quit();
-  }
-
-  if (load_font() != 0)
-  {
-    error_msg("font init Error!!");
-    quit();
-  }
+  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT, &date_format);
 
   init_gamepak_buffer();
 
-  load_config_file();
-
-  gamepak_filename[0] = 0;
-
-  delay_us(1500000);
-
-  init_main();
   init_sound();
-
-  init_video();
   init_input();
 
+  init_video();
   video_resolution_large();
 
-  if(load_bios("gba_bios.bin") == -1)
-  {
-    print_string(msg[MSG_ERR_BIOS_1], 0xFFFF, 0x0000, 0, 0);
-    print_string(msg[MSG_ERR_BIOS_2], 0xFFFF, 0x0000, 0, 60);
-    error_msg("");
-    quit();
-  }
+  // Copy the directory path of the executable into main_path
+  getcwd(main_path, MAX_PATH);
 
-  if(load_bios("gba_bios.bin") == -2)
-  {
-    print_string(msg[MSG_ERR_BIOS_MD5], 0xFFFF, 0x0000, 0, 0);
-    delay_us(5000000);
-  }
+  load_setting_cfg();
+  load_bios_file();
+  load_config_file();
 
   if(argc > 1)
   {
-    if(load_gamepak(argv[1]) == -1)
+    if(load_gamepak((char *)argv[1]) == -1)
     {
-      printf("Failed to load gamepak %s, exiting.\n", load_filename);
-      exit(-1);
+      error_msg("Failed to load gamepak.\n\nPress any button to exit.\n");
+      quit();
     }
 
     set_gba_resolution(screen_scale);
     video_resolution_small();
 
-    init_cpu();
-    init_memory();
+    reset_gba();
   }
   else
   {
     if(load_file(file_ext, load_filename, default_rom_dir) == -1)
     {
-      menu(copy_screen());
+      u16 *screen_copy = copy_screen();
+      menu(screen_copy);
+      free(screen_copy);
     }
     else
     {
       if(load_gamepak(load_filename) == -1)
       {
-        printf("Failed to load gamepak %s, exiting.\n", load_filename);
-        delay_us(5000000);
-        exit(-1);
+        error_msg("Failed to load gamepak.\n\nPress any button to exit.\n");
+        quit();
       }
 
       set_gba_resolution(screen_scale);
       video_resolution_small();
 
-      init_cpu();
-      init_memory();
-      reset_sound();
+      reset_gba();
     }
   }
 
-  last_frame = 0;
+//  last_frame = 0;
+  set_cpu_clock(clock_speed);
 
   // We'll never actually return from here.
-
-//  get_ticks_us(&frame_count_initial_timestamp);
   execute_arm_translate(execute_cycles);
-//  execute_arm(execute_cycles);
-  return 0;
-}
 
-void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str)
-{
-  u32 other_region_counter = region_stats[0x1] + region_stats[0xE] + region_stats[0xF];
-  u32 rom_region_counter = region_stats[0x8] + region_stats[0x9] + region_stats[0xA] +
-   region_stats[0xB] + region_stats[0xC] + region_stats[0xD];
-  u32 _counter = *counter;
-
-  printf("memory access stats: %s (out of %d)\n", stats_str, (int)_counter);
-  printf("bios: %f%%\tiwram: %f%%\tewram: %f%%\tvram: %f\n",
-   region_stats[0x0] * 100.0 / _counter, region_stats[0x3] * 100.0 / _counter,
-   region_stats[0x2] * 100.0 / _counter, region_stats[0x6] * 100.0 / _counter);
-
-  printf("oam: %f%%\tpalette: %f%%\trom: %f%%\tother: %f%%\n",
-   region_stats[0x7] * 100.0 / _counter, region_stats[0x5] * 100.0 / _counter,
-   rom_region_counter * 100.0 / _counter, other_region_counter * 100.0 / _counter);
-
-  *counter = 0;
-  memset(region_stats, 0, sizeof(u32) * 16);
-}
-
-u32 event_cycles = 0;
-const u32 event_cycles_trigger = 60 * 5;
-u32 no_alpha = 0;
-
-void trigger_ext_event()
-{
-  static u32 event_number = 0;
-  static u64 benchmark_ticks[16];
-  u64 new_ticks;
-  char current_savestate_filename[512];
-
-  return;
-
-  if(event_number)
-  {
-    get_ticks_us(&new_ticks);
-    benchmark_ticks[event_number - 1] =
-     new_ticks - benchmark_ticks[event_number - 1];
-  }
-
-  game_config_frameskip_type = no_frameskip;
-  no_alpha = 0;
-  synchronize_flag = 0;
-
-  get_savestate_filename_noshot(savestate_slot, current_savestate_filename);
-  load_state(current_savestate_filename);
-
-  switch(event_number)
-  {
-    case 0:
-      // Full benchmark, run normally
-      break;
-
-    case 1:
-      // No alpha blending
-      no_alpha = 1;
-      break;
-
-    case 2:
-      // No video benchmark
-      // Set frameskip really high + manual
-      game_config_frameskip_type = manual_frameskip;
-      game_config_frameskip_value = 1000000;
-      break;
-
-    case 3:
-      // No CPU benchmark
-      // Put CPU in halt mode, put it in IRQ mode with interrupts off
-      reg[CPU_HALT_STATE] = CPU_HALT;
-      reg[REG_CPSR] = 0xD2;
-      break;
-
-    case 4:
-      // No CPU or video benchmark
-      reg[CPU_HALT_STATE] = CPU_HALT;
-      reg[REG_CPSR] = 0xD2;
-      game_config_frameskip_type = manual_frameskip;
-      game_config_frameskip_value = 1000000;
-      break;
-
-    case 5:
-    {
-      // Done
-      char *print_strings[] =
-      {
-        "Full test   ",
-        "No blending ",
-        "No video    ",
-        "No CPU      ",
-        "No CPU/video",
-        "CPU speed   ",
-        "Video speed ",
-        "Alpha cost  "
-      };
-      u32 i;
-
-      benchmark_ticks[6] = benchmark_ticks[0] - benchmark_ticks[2];
-      benchmark_ticks[5] = benchmark_ticks[0] - benchmark_ticks[4] -
-       benchmark_ticks[6];
-      benchmark_ticks[7] = benchmark_ticks[0] - benchmark_ticks[1];
-
-      printf("Benchmark results (%d frames): \n", (int)event_cycles_trigger);
-      for(i = 0; i < 8; i++)
-      {
-        printf("   %s: %d ms (%f ms per frame)\n",
-         print_strings[i], (int)benchmark_ticks[i] / 1000,
-         (float)(benchmark_ticks[i] / (1000.0 * event_cycles_trigger)));
-        if(i == 4)
-          printf("\n");
-      }
-      quit();
-    }
-  }
-
-  event_cycles = 0;
-
-  get_ticks_us(benchmark_ticks + event_number);
-  event_number++;
+  return 0;
 }
 
-u32 check_power()
-  {
-    if (power_flag == 0) return 0;
-    FILE_CLOSE(gamepak_file_large);
-    u16 *screen_copy = copy_screen();
-    u32 ret_val = menu(screen_copy);
-    free(screen_copy);
-    power_flag = 0;
-    FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
-    return ret_val;
-  }
 
-u32 update_gba()
+u32 update_gba(void)
 {
   irq_type irq_raised = IRQ_NONE;
 
-  do {
+  do
+  {
     cpu_ticks += execute_cycles;
+//    reg[CHANGED_PC_STATUS] = 0;
 
-    reg[CHANGED_PC_STATUS] = 0;
-
-    if(gbc_sound_update) {
+    if(gbc_sound_update)
+    {
       update_gbc_sound(cpu_ticks);
       gbc_sound_update = 0;
     }
@@ -479,29 +345,29 @@
 
     video_count -= execute_cycles;
 
-    if(video_count <= 0) {
-      u32 vcount = io_registers[REG_VCOUNT];
-      u32 dispstat = io_registers[REG_DISPSTAT];
+    if(video_count <= 0)
+    {
+      u16 vcount = io_registers[REG_VCOUNT];
+      u16 dispstat = io_registers[REG_DISPSTAT];
 
-      if((dispstat & 0x02) == 0) {
+      if((dispstat & 0x02) == 0)
+      {
         // Transition from hrefresh to hblank
-        video_count += (272);
+        video_count += 272;
         dispstat |= 0x02;
 
-        if((dispstat & 0x01) == 0) {
-//          u32 i;
+        if((dispstat & 0x01) == 0)
+        {
+          u8 i;
 
           update_scanline();
 
           // If in visible area also fire HDMA
-          if(dma[0].start_type == DMA_START_HBLANK)
-            dma_transfer(dma);
-          if(dma[1].start_type == DMA_START_HBLANK)
-            dma_transfer(dma + 1);
-          if(dma[2].start_type == DMA_START_HBLANK)
-            dma_transfer(dma + 2);
-          if(dma[3].start_type == DMA_START_HBLANK)
-            dma_transfer(dma + 3);
+          for(i = 0; i < 4; i++)
+          {
+            if(dma[i].start_type == DMA_START_HBLANK)
+              dma_transfer(dma + i);
+          }
         }
 
         if(dispstat & 0x10)
@@ -515,14 +381,15 @@
 
         vcount++;
 
-        if(vcount == 160) {
+        if(vcount == 160)
+        {
           // Transition from vrefresh to vblank
-//          u32 i;
+          u8 i;
 
           dispstat |= 0x01;
-          if(dispstat & 0x8) {
+
+          if(dispstat & 0x08)
             irq_raised |= IRQ_VBLANK;
-          }
 
           affine_reference_x[0] =
            (s32)(ADDRESS32(io_registers, 0x28) << 4) >> 4;
@@ -533,26 +400,24 @@
           affine_reference_y[1] =
            (s32)(ADDRESS32(io_registers, 0x3C) << 4) >> 4;
 
-          if(dma[0].start_type == DMA_START_VBLANK)
-            dma_transfer(dma);
-          if(dma[1].start_type == DMA_START_VBLANK)
-            dma_transfer(dma + 1);
-          if(dma[2].start_type == DMA_START_VBLANK)
-            dma_transfer(dma + 2);
-          if(dma[3].start_type == DMA_START_VBLANK)
-            dma_transfer(dma + 3);
+          for(i = 0; i < 4; i++)
+          {
+            if(dma[i].start_type == DMA_START_VBLANK)
+              dma_transfer(dma + i);
+          }
         }
         else
 
-        if(vcount == 228) {
+        if(vcount >= 228)
+        {
           // Transition from vblank to next screen
           dispstat &= ~0x01;
 //          frame_ticks++;
 
-          if (update_input())
-            continue;
+          if(sleep_flag)
+            loop_sleep();
 
-          if (check_power())
+          if(update_input())
             continue;
 
           if (quit_flag == 1)
@@ -571,13 +436,14 @@
           vcount = 0;
         }
 
-        if(vcount == (dispstat >> 8)) {
+        if(vcount == (dispstat >> 8))
+        {
           // vcount trigger
           dispstat |= 0x04;
-          if(dispstat & 0x20) {
+
+          if(dispstat & 0x20)
             irq_raised |= IRQ_VCOUNT;
           }
-        }
         else
         {
           dispstat &= ~0x04;
@@ -603,48 +470,29 @@
   return execute_cycles;
 }
 
-u64 last_screen_timestamp = 0;
-u32 frame_speed = 15000;
 
-u32 real_frame_count = 0;
-u32 virtual_frame_count = 0;
-u32 num_skipped_frames = 0;
-u32 interval_skipped_frames;
-u32 frames;
-u32 skipped_frames = 0;
-u32 ticks_needed_total = 0;
-const u32 frame_interval = 60;
-
-void vblank_interrupt_handler(u32 sub, u32 *parg)
+static void vblank_interrupt_handler(u32 sub, u32 *parg)
 {
   real_frame_count++;
 }
 
-void synchronize()
+void synchronize(void)
 {
 //  char char_buffer[64];
   u64 new_ticks;
   u64 time_delta;
-//  s32 used_frameskip = game_config_frameskip_value;
+//  s32 used_frameskip = frameskip_value;
   static u32 fps = 60;
   static u32 frames_drawn = 60;
 
   if(psp_fps_debug)
   {
     char print_buffer[256];
-//    int i;
-    sprintf(print_buffer, "%d (%d)", (int)fps, (int)frames_drawn);
-    print_string(print_buffer, 0xFFFF, 0x000, 0, 0);
+    sprintf(print_buffer, "%02d(%02d)", (int)fps, (int)frames_drawn);
+    print_string(print_buffer, 0xFFFF, 0x0000, 0, 0);
   }
 
-//  if(!synchronize_flag)
-//  {
-//    print_string("--FF--", 0xFFFF, 0x000, 0, 0);
-//    used_frameskip = 4;
-//    virtual_frame_count = real_frame_count - 1;
-//  }
-
-  get_ticks_us(&new_ticks);
+  sceRtcGetCurrentTick(&new_ticks);
   time_delta = new_ticks - last_screen_timestamp;
   last_screen_timestamp = new_ticks;
   ticks_needed_total += time_delta;
@@ -652,14 +500,11 @@
   skip_next_frame = 0;
   virtual_frame_count++;
 
-//  real_frame_count = ((new_ticks -
-//    frame_count_initial_timestamp) * 3) / 50000;
-
   if(real_frame_count >= virtual_frame_count)
   {
     if((real_frame_count > virtual_frame_count) &&
-     (game_config_frameskip_type == auto_frameskip) &&
-     (num_skipped_frames < game_config_frameskip_value))
+     (current_frameskip_type == auto_frameskip) &&
+     (num_skipped_frames < frameskip_value))
     {
       skip_next_frame = 1;
       num_skipped_frames++;
@@ -672,20 +517,15 @@
     // Here so that the home button return will eventually work.
     // If it's not running fullspeed anyway this won't really hurt
     // it much more.
-
-///    delay_us(1);
+    delay_us(1);
   }
   else
+  if(synchronize_flag)
   {
-    if((synchronize_flag) /*&&
-     ((time_delta < frame_speed) && synchronize_flag)*/)
-    {
-//      delay_us(frame_speed - time_delta);
       sceDisplayWaitVblankStart();
       real_frame_count = 0;
       virtual_frame_count = 0;
     }
-  }
 
   frames++;
 
@@ -708,13 +548,13 @@
     frames = 0;
   }
 
-  if(game_config_frameskip_type == manual_frameskip)
+  if(current_frameskip_type == manual_frameskip)
   {
-    frameskip_counter = (frameskip_counter + 1) %
-     (game_config_frameskip_value + 1);
-    if(game_config_random_skip)
+    frameskip_counter = (frameskip_counter + 1) % (frameskip_value + 1);
+
+    if(random_skip)
     {
-      if(frameskip_counter != (rand() % (game_config_frameskip_value + 1)))
+      if(frameskip_counter != (rand() % (frameskip_value + 1)))
         skip_next_frame = 1;
     }
     else
@@ -727,45 +567,39 @@
   interval_skipped_frames += skip_next_frame;
 
   if(!synchronize_flag)
-    print_string("--FF--", 0xFFFF, 0x000, 0, 0);
-/*
-  sprintf(char_buffer, "%08d %08d %d %d %d\n",
-   real_frame_count, virtual_frame_count, num_skipped_frames,
-   real_frame_count - virtual_frame_count, skip_next_frame);
-  print_string(char_buffer, 0xFFFF, 0x0000, 0, 10);
-*/
-
-/*
-    sprintf(char_buffer, "%02d %02d %06d %07d", frameskip, (u32)ms_needed,
-     ram_translation_ptr - ram_translation_cache, rom_translation_ptr -
-     rom_translation_cache);
-    print_string(char_buffer, 0xFFFF, 0x0000, 0, 0);
-*/
+    print_string("--FF--", 0xFFFF, 0x0000, 0, 0);
 }
 
-void quit()
+
+void quit(void)
 {
-//  if(!update_backup_flag)
     update_backup_force();
 
   sound_exit();
-  fbm_freeall();
+  video_exit();
+  memory_exit();
 
-  fclose(dbg_file);
+  fbm_freeall();
 
-  scePowerSetClockFrequency(222, 222, 111);
+  set_cpu_clock(222);
   sceKernelExitGame();
 }
 
-void reset_gba()
+void reset_gba(void)
 {
-  init_main();
   init_memory();
+  init_main();
   init_cpu();
   reset_sound();
 }
 
-u32 file_length(char *filename, s32 dummy)
+
+void set_cpu_clock(u32 psp_clock)
+{
+  scePowerSetClockFrequency(psp_clock, psp_clock, psp_clock / 2);
+}
+
+u32 file_length(char *filename)
 {
   SceIoStat stats;
   sceIoGetstat(filename, &stats);
@@ -782,8 +617,7 @@
   u64 ticks;
   sceRtcGetCurrentTick(&ticks);
 
-//  *tick_return = (ticks * 1000000) / sceRtcGetTickResolution();
-    *tick_return = ticks;
+  *tick_return = (ticks * 1000000) / sceRtcGetTickResolution();
 }
 
 void change_ext(char *src, char *buffer, char *extension)
@@ -796,51 +630,101 @@
     strcpy(dot_position, extension);
 }
 
-// type = READ / WRITE_MEM
-#define MAIN_SAVESTATE_BODY(type)                                             \
-{                                                                             \
-  FILE_##type##_VARIABLE(savestate_file, cpu_ticks);                          \
-  FILE_##type##_VARIABLE(savestate_file, execute_cycles);                     \
-  FILE_##type##_VARIABLE(savestate_file, video_count);                        \
-  FILE_##type##_ARRAY(savestate_file, timer);                                 \
-}                                                                             \
 
-void main_read_savestate(FILE_TAG_TYPE savestate_file)
-MAIN_SAVESTATE_BODY(READ);
+static void loop_sleep(void)
+{
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
 
-void main_write_mem_savestate(FILE_TAG_TYPE savestate_file)
-MAIN_SAVESTATE_BODY(WRITE_MEM);
+    do
+    {
+      delay_us(500000);
+    } while(sleep_flag);
 
-int exit_callback(int arg1, int arg2, void *common)
+    u8 i;
+    for(i = 0; i < 5; i++)
 {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    video_resolution_large();
+    print_string("Failed to load gamepak.\n\nexiting.\n", 0xFFFF, 0x0000, 5, 5);
+    delay_us(3000000);
   quit_flag = 1;
+
+    success_open_gamepak:;
+  }
+  else
+  {
+    do
+    {
+      delay_us(500000);
+    } while(sleep_flag);
+  }
+
+}
+
+static int exit_callback(int arg1, int arg2, void *common)
+{
+  quit_flag = 1;
+
   return 0;
 }
 
-int power_callback(int unknown, int powerInfo, void *common)
+static u8 *gamepack_shelter = NULL;
+
+static int power_callback(int unknown, int powerInfo, void *arg)
+{
+  if(powerInfo & PSP_POWER_CB_SUSPENDING)
+  {
+    if((kuKernelGetModel() == PSP_MODEL_SLIM_AND_LITE) &&
+     (sceKernelDevkitVersion() >= 0x03070110))
+    {
+      gamepack_shelter = malloc(0x400000);
+      memcpy(gamepack_shelter, (void *)0xBC00000, 0x400000);
+    }
+
+    sleep_flag = 1;
+  }
+  else
+
+  if(powerInfo & PSP_POWER_CB_RESUME_COMPLETE)
 {
-  if (powerInfo & PSP_POWER_CB_SUSPENDING) power_flag = 1;
+    if((kuKernelGetModel() == PSP_MODEL_SLIM_AND_LITE) &&
+     (sceKernelDevkitVersion() >= 0x03070110))
+    {
+      memcpy((void *)0xBC00000, gamepack_shelter, 0x400000);
+      free(gamepack_shelter);
+    }
+
+    sleep_flag = 0;
+  }
+
   return 0;
 }
 
-int CallbackThread(SceSize args, void *argp)
+static int CallbackThread(SceSize args, void *argp)
 {
-  int cbid, power_callback_id;
+  int cbid;
 
-  // �I�����̃R�[���o�b�N 
   cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
   sceKernelRegisterExitCallback(cbid);
 
-  // �d�����̃R�[���o�b�N 
-  power_callback_id = sceKernelCreateCallback("Power Callback", power_callback, NULL); 
-  scePowerRegisterCallback(0, power_callback_id);
+  cbid = sceKernelCreateCallback("Power Callback", power_callback, NULL);
+  scePowerRegisterCallback(0, cbid);
 
   sceKernelSleepThreadCB();
 
   return 0;
 }
 
-int SetupCallbacks()
+static int SetupCallbacks(void)
 {
   int thid = 0;
 
@@ -851,6 +736,9 @@
     sceKernelStartThread(thid, 0, 0);
   }
 
+  quit_flag = 0;
+  sleep_flag = 0;
+
   return thid;
 }
 
@@ -858,7 +747,7 @@
 {
     gui_action_type gui_action = CURSOR_NONE;
 
-    printf(text);
+  print_string(text, 0xFFFF, 0x0000, 5, 5);
 
     while(gui_action == CURSOR_NONE)
     {
@@ -867,61 +756,19 @@
     }
 }
 
-void set_cpu_mode(CPU_MODE_TYPE new_mode)
-{
-  u32 i;
-  CPU_MODE_TYPE cpu_mode = reg[CPU_MODE];
 
-  if(cpu_mode != new_mode)
-  {
-    if(new_mode == MODE_FIQ)
-    {
-      for(i = 8; i < 15; i++)
-      {
-        reg_mode[cpu_mode][i - 8] = reg[i];
-      }
-    }
-    else
-    {
-      reg_mode[cpu_mode][5] = reg[REG_SP];
-      reg_mode[cpu_mode][6] = reg[REG_LR];
-    }
-
-    if(cpu_mode == MODE_FIQ)
-    {
-      for(i = 8; i < 15; i++)
-      {
-        reg[i] = reg_mode[new_mode][i - 8];
-      }
-    }
-    else
-    {
-      reg[REG_SP] = reg_mode[new_mode][5];
-      reg[REG_LR] = reg_mode[new_mode][6];
-    }
-
-    reg[CPU_MODE] = new_mode;
-  }
-}
+// type = READ / WRITE_MEM
+#define MAIN_SAVESTATE_BODY(type)                                             \
+{                                                                             \
+  FILE_##type##_VARIABLE(savestate_file, cpu_ticks);                          \
+  FILE_##type##_VARIABLE(savestate_file, execute_cycles);                     \
+  FILE_##type##_VARIABLE(savestate_file, video_count);                        \
+  FILE_##type##_ARRAY(savestate_file, timer);                                 \
+}                                                                             \
 
-void raise_interrupt(irq_type irq_raised)
-{
-  // The specific IRQ must be enabled in IE, master IRQ enable must be on,
-  // and it must be on in the flags.
-  io_registers[REG_IF] |= irq_raised;
+void main_read_savestate(FILE_TAG_TYPE savestate_file)
+  MAIN_SAVESTATE_BODY(READ);
 
-  if((io_registers[REG_IE] & irq_raised) && io_registers[REG_IME] &&
-   ((reg[REG_CPSR] & 0x80) == 0))
-  {
-    bios_read_protect = 0xe55ec002;
+void main_write_mem_savestate(FILE_TAG_TYPE savestate_file)
+  MAIN_SAVESTATE_BODY(WRITE_MEM);
 
-    // Interrupt handler in BIOS
-    reg_mode[MODE_IRQ][6] = reg[REG_PC] + 4;
-    spsr[MODE_IRQ] = reg[REG_CPSR];
-    reg[REG_CPSR] = 0xD2;
-    reg[REG_PC] = 0x00000018;
-    set_cpu_mode(MODE_IRQ);
-    reg[CPU_HALT_STATE] = CPU_ACTIVE;
-    reg[CHANGED_PC_STATUS] = 1;
-  }
-}
diff -ruibwEB --strip-trailing-cr -I RE old/main.h mod/main.h
--- old/main.h	2007-08-26 00:49:55.000000000 +0900
+++ mod/main.h	2007-10-27 22:42:28.442761600 +0900
@@ -46,8 +46,8 @@
 {
   s32 count;
   u32 reload;
-  u32 prescale;
-  u32 stop_cpu_ticks;
+  u8 reload_update;
+  u8 prescale;
   FIXED16_16 frequency_step;
   TIMER_DS_CHANNEL_TYPE direct_sound_channels;
   TIMER_IRQ_TYPE irq;
@@ -61,101 +62,96 @@
   no_frameskip
 } frameskip_type;
 
-extern u32 cpu_ticks;
-extern u32 frame_ticks;
-extern u32 execute_cycles;
-extern u32 game_config_frameskip_type;
-extern u32 game_config_frameskip_value;
-extern u32 game_config_random_skip;
-extern u32 global_cycles_per_instruction;
-extern u32 synchronize_flag;
-extern u32 skip_next_frame;
+
 extern TIMER_TYPE timer[4];
-extern u32 prescale_table[];
-extern u32 cycle_memory_access;
-extern u32 cycle_pc_relative_access;
-extern u32 cycle_sp_relative_access;
-extern u32 cycle_block_memory_access;
-extern u32 cycle_block_memory_sp_access;
-extern u32 cycle_block_memory_words;
-extern u32 cycle_dma16_words;
-extern u32 cycle_dma32_words;
-extern u32 flush_ram_count;
-extern u64 base_timestamp;
-extern char main_path[512];
+
+extern FRAMESKIP_TYPE current_frameskip_type;
+extern u32 frameskip_value;
+extern u32 random_skip;
+extern u32 clock_speed;
 extern u32 update_backup_flag;
-extern u32 game_config_clock_speed;
-extern u32 hold_state;
-extern u32 quit_flag;
+
+extern u32 cpu_ticks;
+// extern u32 frame_ticks;
+extern u32 execute_cycles;
+
+// extern u32 cycle_dma16_words;
+// extern u32 cycle_dma32_words;
+
+extern char main_path[MAX_PATH];
+
+extern int date_format;
+
+extern u8 sleep_flag;
+extern u8 quit_flag;
+
+extern u8 psp_fps_debug;
+
+extern u8 synchronize_flag;
+extern u8 skip_next_frame;
+
 extern u32 real_frame_count;
 extern u32 virtual_frame_count;
-extern u32 max_frameskip;
-extern u32 num_skipped_frames;
-extern u64 frame_count_initial_timestamp;
-
-u32 update_gba();
-void reset_gba();
-void synchronize();
-void quit();
+
+void set_cpu_clock(u32 psp_clock);
+
+u32 update_gba(void);
+void reset_gba(void);
+void synchronize(void);
+void quit(void);
 void delay_us(u32 us_count);
 void get_ticks_us(u64 *tick_return);
 void game_name_ext(u8 *src, u8 *buffer, u8 *extension);
 void main_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void main_read_savestate(FILE_TAG_TYPE savestate_file);
 void error_msg(char *text);
-void set_cpu_mode(CPU_MODE_TYPE new_mode);
-void raise_interrupt(irq_type irq_raised);
 void change_ext(char *src, char *buffer, char *extension);
-u32 file_length(char *filename, s32 dummy);
+u32 file_length(char *filename);
+
 
 #define count_timer(timer_number)                                             \
   timer[timer_number].reload = 0x10000 - value;                               \
-  if(timer_number < 2)                                                        \
-  {                                                                           \
-    u32 timer_reload =                                                        \
-     timer[timer_number].reload << timer[timer_number].prescale;              \
-    sound_update_frequency_step(timer_number);                                \
-  }                                                                           \
+  timer[timer_number].reload_update = 1                                       \
 
 #define adjust_sound_buffer(timer_number, channel)                            \
   if(timer[timer_number].direct_sound_channels & (0x01 << channel))           \
   {                                                                           \
-    direct_sound_channel[channel].buffer_index =                              \
-     (direct_sound_channel[channel].buffer_index + buffer_adjust) %           \
-     BUFFER_SIZE;                                                             \
+    direct_sound_channel[channel].buffer_index = gbc_sound_buffer_index;      \
   }                                                                           \
 
 #define trigger_timer(timer_number)                                           \
+{                                                                             \
   if(value & 0x80)                                                            \
   {                                                                           \
     if(timer[timer_number].status == TIMER_INACTIVE)                          \
     {                                                                         \
-      u32 prescale = prescale_table[value & 0x03];                            \
+      u8 prescale_table[] = { 0, 6, 8, 10 };                                  \
       u32 timer_reload = timer[timer_number].reload;                          \
                                                                               \
       if((value >> 2) & 0x01)                                                 \
+      {                                                                       \
         timer[timer_number].status = TIMER_CASCADE;                           \
+        timer[timer_number].prescale = 0;                                     \
+      }                                                                       \
       else                                                                    \
+      {                                                                       \
         timer[timer_number].status = TIMER_PRESCALE;                          \
+        timer[timer_number].prescale = prescale_table[value & 0x03];          \
+      }                                                                       \
                                                                               \
-      timer[timer_number].prescale = prescale;                                \
       timer[timer_number].irq = (value >> 6) & 0x01;                          \
                                                                               \
       ADDRESS16(io_registers, 0x100 + (timer_number * 4)) =                   \
        0x10000 - timer_reload;                                                \
                                                                               \
-      timer_reload <<= prescale;                                              \
+      timer_reload <<= timer[timer_number].prescale;                          \
       timer[timer_number].count = timer_reload;                               \
                                                                               \
       if(timer_reload < execute_cycles)                                       \
         execute_cycles = timer_reload;                                        \
                                                                               \
-      if(timer_number < 2)                                                    \
+      if((timer_number < 2) && (timer[timer_number].direct_sound_channels))   \
       {                                                                       \
-        u32 buffer_adjust =                                                   \
-         (u32)(((float)(cpu_ticks - timer[timer_number].stop_cpu_ticks) *     \
-         SOUND_FREQUENCY) / 16777216.0) * 2;                                  \
-                                                                              \
         sound_update_frequency_step(timer_number);                            \
         adjust_sound_buffer(timer_number, 0);                                 \
         adjust_sound_buffer(timer_number, 1);                                 \
@@ -167,11 +163,11 @@
     if(timer[timer_number].status != TIMER_INACTIVE)                          \
     {                                                                         \
       timer[timer_number].status = TIMER_INACTIVE;                            \
-      timer[timer_number].stop_cpu_ticks = cpu_ticks;                         \
     }                                                                         \
   }                                                                           \
+                                                                              \
   ADDRESS16(io_registers, 0x102 + (timer_number * 4)) = value;                \
-
-#endif
+}                                                                             \
 
 
+#endif /* MAIN_H */
diff -ruibwEB --strip-trailing-cr -I RE old/memory.c mod/memory.c
--- old/memory.c	2007-08-26 00:49:54.000000000 +0900
+++ mod/memory.c	2007-10-27 22:42:39.258313600 +0900
@@ -20,86 +20,58 @@
 
 #include "common.h"
 
-typedef enum
-{
-  FLASH_DEVICE_MACRONIX_64KB   = 0x1C,
-  FLASH_DEVICE_AMTEL_64KB      = 0x3D,
-  FLASH_DEVICE_SST_64K         = 0xD4,
-  FLASH_DEVICE_PANASONIC_64KB  = 0x1B,
-  FLASH_DEVICE_MACRONIX_128KB  = 0x09
-} FLASH_DEVICE_ID_TYPE;
+static u8 save_backup(char *name);
+static u32 encode_bcd(u8 value);
+static char *skip_spaces(char *line_ptr);
+static s8 parse_config_line(char *current_line, char *current_variable,
+ char *current_value);
+static s32 load_gamepak_raw(char *name);
+static u32 evict_gamepak_page(void);
+static void init_memory_gamepak(void);
+
+
+// read data (sequential)
+u8 waitstate_cycles_seq[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
+};
 
-typedef enum
+// read data (non sequential)
+u8 waitstate_cycles_non_seq[2][16] =
 {
-  FLASH_MANUFACTURER_MACRONIX  = 0xC2,
-  FLASH_MANUFACTURER_AMTEL     = 0x1F,
-  FLASH_MANUFACTURER_PANASONIC = 0x32,
-  FLASH_MANUFACTURER_SST       = 0xBF
-} FLASH_MANUFACTURER_ID_TYPE;
-
-
-// �֐��錾
-
-void memory_write_mem_savestate(FILE_TAG_TYPE savestate_file);
-void memory_read_savestate(FILE_TAG_TYPE savestate_file);
-u8 read_backup(u32 address);
-void write_eeprom(u32 address, u32 value);
-u32 read_eeprom();
-CPU_ALERT_TYPE write_io_register8(u32 address, u32 value);
-CPU_ALERT_TYPE write_io_register16(u32 address, u32 value);
-CPU_ALERT_TYPE write_io_register32(u32 address, u32 value);
-void write_backup(u32 address, u32 value);
-u32 encode_bcd(u8 value);
-void write_rtc(u32 address, u32 value);
-u32 save_backup(char *name);
-s32 parse_config_line(char *current_line, char *current_variable, char *current_value);
-s32 load_game_config(char *gamepak_title, char *gamepak_code, char *gamepak_maker);
-char *skip_spaces(char *line_ptr);
-s32 load_gamepak_raw(char *name);
-u32 evict_gamepak_page();
-void init_memory_gamepak();
-
-
-
-// This table is configured for sequential access on system defaults
-
-u32 waitstate_cycles_sequential[16][3] =
-{
-  { 1, 1, 1 }, // BIOS
-  { 1, 1, 1 }, // Invalid
-  { 3, 3, 6 }, // EWRAM (default settings)
-  { 1, 1, 1 }, // IWRAM
-  { 1, 1, 1 }, // IO Registers
-  { 1, 1, 2 }, // Palette RAM
-  { 1, 1, 2 }, // VRAM
-  { 1, 1, 2 }, // OAM
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 9, 9, 17 }, // Gamepak (wait 2)
-  { 9, 9, 17 }, // Gamepak (wait 2)
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 7, 7, 9, 9,13,13, 1, 1 }  /* 32bit */
 };
 
 // Different settings for gamepak ws0-2 sequential (2nd) access
 
-u32 gamepak_waitstate_sequential[2][3][3] =
+static const u8 gamepak_waitstate_seq[2][2][3] =
 {
   {
-    { 3, 3, 6 },
-    { 5, 5, 9 },
-    { 9, 9, 17 }
+    { 3, 5, 9 }, { 5, 9,17 }
   },
   {
-    { 2, 2, 3 },
-    { 2, 2, 3 },
-    { 2, 2, 3 }
+    { 2, 2, 2 }, { 3, 3, 3 }
   }
 };
 
+// read opecode
+u8 waitstate_cycles_fetch[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
+};
+
+const u32 obj_address[6] =
+{ 0x10000, 0x10000, 0x10000, 0x14000, 0x14000, 0x14000 };
+
+
 u16 palette_ram[512];
 u16 oam_ram[512];
-u16 palette_ram_converted[512];
 u16 io_registers[1024 * 16];
 u8 ewram[1024 * 256 * 2];
 u8 iwram[1024 * 32 * 2];
@@ -116,7 +88,6 @@
 u32 gamepak_size;
 
 DMA_TRANSFER_TYPE dma[4];
-//DMA_TRANSFER_TYPE *dma = (DMA_TRANSFER_TYPE *)0x010000; /* SPAD RAM use 0x2C * 4 = 0xB0 */
 
 u8 *memory_regions[16];
 u32 memory_limits[16];
@@ -130,12 +101,6 @@
 u32 gamepak_ram_buffer_size;
 u32 gamepak_ram_pages;
 
-char gamepak_title[13];
-char gamepak_code[5];
-char gamepak_maker[3];
-char gamepak_filename[512];
-char gamepak_filename_raw[512];
-
 // Enough to map the gamepak RAM space.
 gamepak_swap_entry_type *gamepak_memory_map;
 
@@ -145,7 +110,7 @@
 
 FILE_TAG_TYPE gamepak_file_large = -1;
 
-u32 direct_map_vram = 0;
+u8 direct_map_vram = 0;
 
 // Writes to these respective locations should trigger an update
 // so the related subsystem may react to it.
@@ -154,17 +119,17 @@
 u32 oam_update = 1;
 
 // If GBC audio is written to:
-u32 gbc_sound_update = 0;
+u8 gbc_sound_update = 0;
 
 // If the GBC audio waveform is modified:
-u32 gbc_sound_wave_update = 0;
+u8 gbc_sound_wave_update = 0;
 
 // If the backup space is written (only update once this hits 0)
-u32 backup_update = 0;
+static u8 backup_update = 0;
 
 // Write out backup file this many cycles after the most recent
 // backup write.
-const u32 write_backup_delay = 10;
+static const u8 write_backup_delay = 10;
 
 
 typedef enum
@@ -202,7 +167,7 @@
 } flash_size_type;
 
 flash_mode_type flash_mode = FLASH_BASE_MODE;
-u32 flash_command_position = 0;
+u8 flash_command_position = 0;
 u8 *flash_bank_ptr = gamepak_backup;
 
 FLASH_DEVICE_ID_TYPE flash_device_id = FLASH_DEVICE_MACRONIX_64KB;
@@ -206,19 +171,26 @@
 u8 *flash_bank_ptr = gamepak_backup;
 
 FLASH_DEVICE_ID_TYPE flash_device_id = FLASH_DEVICE_MACRONIX_64KB;
-FLASH_MANUFACTURER_ID_TYPE flash_manufacturer_id =
- FLASH_MANUFACTURER_MACRONIX;
+FLASH_MANUFACTURER_ID_TYPE flash_manufacturer_id = FLASH_MANUFACTURER_MACRONIX;
 flash_size_type flash_size = FLASH_SIZE_64KB;
 
-char gba_md5[16] = { 0xA8, 0x60, 0xE8, 0xC0, 0xB6, 0xD5, 0x73, 0xD1, 0x91, 0xE4, 0xEC, 0x7D, 0xB1, 0xB1, 0xE4, 0xF6 };
-char nds_md5[16] = { 0x1C, 0x0D, 0x67, 0xDB, 0x9E, 0x12, 0x08, 0xB9, 0x5A, 0x15, 0x06, 0xB1, 0x68, 0x8A, 0x0A, 0xD6 };
+static const u8 gba_md5[16] =
+{ 0xA8, 0x60, 0xE8, 0xC0, 0xB6, 0xD5, 0x73, 0xD1,
+  0x91, 0xE4, 0xEC, 0x7D, 0xB1, 0xB1, 0xE4, 0xF6 };
+
+static const u8 nds_md5[16] =
+{ 0x1C, 0x0D, 0x67, 0xDB, 0x9E, 0x12, 0x08, 0xB9,
+  0x5A, 0x15, 0x06, 0xB1, 0x68, 0x8A, 0x0A, 0xD6 };
+
 
 u8 read_backup(u32 address)
 {
   u8 value = 0;
 
   if(backup_type == BACKUP_NONE)
+  {
     backup_type = BACKUP_SRAM;
+  }
 
   if(backup_type == BACKUP_SRAM)
   {
@@ -226,6 +198,8 @@
   }
   else
 
+  if(backup_type == BACKUP_FLASH)
+  {
   if(flash_mode == FLASH_ID_MODE)
   {
     /* ID manufacturer type */
@@ -241,6 +215,33 @@
   {
     value = flash_bank_ptr[address];
   }
+  }
+  else
+
+  if(backup_type == BACKUP_EEPROM)
+  {
+    enable_motion_sensor = 1;
+
+    switch(address & 0x8F00)
+    {
+      case 0x8200:
+        value = motion_sensorX & 0xFF;
+        break;
+
+      case 0x8300:
+        value = (motion_sensorX >> 8) | 0x80;
+        break;
+
+      case 0x8400:
+        value = motion_sensorY & 0xFF;
+        break;
+
+      case 0x8500:
+        value = motion_sensorY >> 8;
+        break;
+    }
+  }
+
   return value;
 }
 
@@ -275,14 +276,12 @@
   EEPROM_WRITE_FOOTER_MODE
 } eeprom_mode_type;
 
-
 eeprom_size_type eeprom_size = EEPROM_512_BYTE;
 eeprom_mode_type eeprom_mode = EEPROM_BASE_MODE;
-u32 eeprom_address_length;
-u32 eeprom_address = 0;
-s32 eeprom_counter = 0;
-u8 eeprom_buffer[8];
-
+static u32 eeprom_address_length;
+static u32 eeprom_address = 0;
+static s32 eeprom_counter = 0;
+static u8 eeprom_buffer[8];
 
 void write_eeprom(u32 address, u32 value)
 {
@@ -377,9 +376,6 @@
         eeprom_mode = EEPROM_BASE_MODE;
       }
       break;
-    default:
-      ;
-      break;
   }
 }
 
@@ -543,8 +601,8 @@
     if(dma[dma_number].start_type == DMA_INACTIVE)                            \
     {                                                                         \
       u32 start_type = (value >> 12) & 0x03;                                  \
-      u32 dest_address = ADDRESS32(io_registers, (dma_number * 12) + 0xB4) &  \
-       0xFFFFFFF;                                                             \
+      u32 dest_address =                                                      \
+       ADDRESS32(io_registers, (dma_number * 12) + 0xB4) & 0x0FFFFFFF;        \
                                                                               \
       dma[dma_number].dma_channel = dma_number;                               \
       dma[dma_number].source_address =                                        \
@@ -562,11 +620,16 @@
         dma[dma_number].length_type = DMA_32BIT;                              \
         dma[dma_number].length = 4;                                           \
         dma[dma_number].dest_direction = DMA_FIXED;                           \
+                                                                              \
         if(dest_address == 0x40000A4)                                         \
+        {                                                                     \
           dma[dma_number].direct_sound_channel = DMA_DIRECT_SOUND_B;          \
+        }                                                                     \
         else                                                                  \
+        {                                                                     \
           dma[dma_number].direct_sound_channel = DMA_DIRECT_SOUND_A;          \
       }                                                                       \
+      }                                                                       \
       else                                                                    \
       {                                                                       \
         u32 length =                                                          \
@@ -579,15 +642,21 @@
         }                                                                     \
                                                                               \
         if(dma_number < 3)                                                    \
+        {                                                                     \
           length &= 0x3FFF;                                                   \
+        }                                                                     \
                                                                               \
         if(length == 0)                                                       \
         {                                                                     \
           if(dma_number == 3)                                                 \
+          {                                                                   \
             length = 0x10000;                                                 \
+          }                                                                   \
           else                                                                \
+          {                                                                   \
             length = 0x04000;                                                 \
         }                                                                     \
+        }                                                                     \
                                                                               \
         dma[dma_number].length = length;                                      \
         dma[dma_number].length_type = (value >> 10) & 0x01;                   \
@@ -596,9 +665,11 @@
                                                                               \
       ADDRESS16(io_registers, (dma_number * 12) + 0xBA) = value;              \
       if(start_type == DMA_START_IMMEDIATELY)                                 \
+      {                                                                       \
         return dma_transfer(dma + dma_number);                                \
     }                                                                         \
   }                                                                           \
+  }                                                                           \
   else                                                                        \
   {                                                                           \
     dma[dma_number].start_type = DMA_INACTIVE;                                \
@@ -607,6 +678,67 @@
   }                                                                           \
 
 
+// configure game pak access timings
+#define waitstate_control()                                                   \
+{                                                                             \
+  u8 i;                                                                       \
+  const u8 waitstate_table[4] = { 5, 4, 3, 9 };                               \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x0e] = waitstate_cycles_seq[0][0x0e]           \
+   = waitstate_table[value & 0x03];                                           \
+                                                                              \
+  for(i = 0; i < 2; i++)                                                      \
+  {                                                                           \
+    waitstate_cycles_seq[i][0x08] = waitstate_cycles_seq[i][0x09]             \
+     = gamepak_waitstate_seq[(value >> 4) & 0x01][i][0];                      \
+    waitstate_cycles_seq[i][0x0A] = waitstate_cycles_seq[i][0x0B]             \
+     = gamepak_waitstate_seq[(value >> 7) & 0x01][i][1];                      \
+    waitstate_cycles_seq[i][0x0C] = waitstate_cycles_seq[i][0x0D]             \
+     = gamepak_waitstate_seq[(value >> 10) & 0x01][i][2];                     \
+  }                                                                           \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x08] = waitstate_cycles_non_seq[0][0x09]       \
+   = waitstate_table[(value >> 2) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0A] = waitstate_cycles_non_seq[0][0x0B]       \
+   = waitstate_table[(value >> 5) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0C] = waitstate_cycles_non_seq[0][0x0D]       \
+   = waitstate_table[(value >> 8) & 0x03];                                    \
+                                                                              \
+  /* 32bit access ( split into two 16bit accsess ) */                         \
+  waitstate_cycles_non_seq[1][0x08] = waitstate_cycles_non_seq[1][0x09]       \
+   = (waitstate_cycles_non_seq[0][0x08] + waitstate_cycles_seq[0][0x08] - 1); \
+  waitstate_cycles_non_seq[1][0x0A] = waitstate_cycles_non_seq[1][0x0B]       \
+   = (waitstate_cycles_non_seq[0][0x0A] + waitstate_cycles_seq[0][0x0A] - 1); \
+  waitstate_cycles_non_seq[1][0x0C] = waitstate_cycles_non_seq[1][0x0D]       \
+  =  (waitstate_cycles_non_seq[0][0x0C] + waitstate_cycles_seq[0][0x0C] - 1); \
+                                                                              \
+  /* gamepak prefetch */                                                      \
+  if(value & 0x4000)                                                          \
+  {                                                                           \
+    for(i = 0x08; i <= 0x0D; i++)                                             \
+    {                                                                         \
+      waitstate_cycles_fetch[0][i] = 1;                                       \
+      waitstate_cycles_fetch[1][i] = 2;                                       \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    for(i = 0; i < 2; i++)                                                    \
+    {                                                                         \
+      waitstate_cycles_fetch[i][0x08] = waitstate_cycles_fetch[i][0x09]       \
+       = waitstate_cycles_seq[i][0x08];                                       \
+      waitstate_cycles_fetch[i][0x0A] = waitstate_cycles_fetch[i][0x0B]       \
+       = waitstate_cycles_seq[i][0x0A];                                       \
+      waitstate_cycles_fetch[i][0x0C] = waitstate_cycles_fetch[i][0x0D]       \
+       = waitstate_cycles_seq[i][0x0C];                                       \
+    }                                                                         \
+  }                                                                           \
+                                                                              \
+  ADDRESS16(io_registers, 0x204) =                                            \
+   (ADDRESS16(io_registers, 0x204) & 0x8000) | (value & 0x7FFF);              \
+}                                                                             \
+
+
 #define access_register8_high(address)                                        \
   value = (value << 8) | (ADDRESS8(io_registers, address))                    \
 
@@ -625,9 +758,9 @@
   {
     case 0x00:
     {
-      u32 dispcnt = io_registers[REG_DISPCNT];
+      u16 bg_mode = io_registers[REG_DISPCNT] & 0x07;
 
-      if((value & 0x07) != (dispcnt & 0x07))
+      if((value & 0x07) != bg_mode)
         oam_update = 1;
 
       ADDRESS8(io_registers, 0x00) = value;
@@ -643,6 +776,7 @@
     // VCOUNT
     case 0x06:
     case 0x07:
+      /* Read only */
       break;
 
     // BG2 reference X
@@ -768,7 +902,7 @@
       break;
 
     case 0x61:
-      access_register8_low(0x60);
+      access_register8_high(0x60);
       gbc_sound_tone_control_sweep();
       break;
 
@@ -905,33 +1039,35 @@
       break;
 
     // Sound FIFO A
-    case 0xA0:
-      sound_timer_queue8(0, value);
+    case 0xA0 ... 0xA3:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
-    case 0xA4:
-      sound_timer_queue8(1, value);
+    case 0xA4 ... 0xA7:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control (trigger byte)
     case 0xBB:
-      access_register8_low(0xBA);
+      access_register8_high(0xBA);
       trigger_dma(0);
       break;
 
     case 0xC7:
-      access_register8_low(0xC6);
+      access_register8_high(0xC6);
       trigger_dma(1);
       break;
 
     case 0xD3:
-      access_register8_low(0xD2);
+      access_register8_high(0xD2);
       trigger_dma(2);
       break;
 
     case 0xDF:
-      access_register8_low(0xDE);
+      access_register8_high(0xDE);
       trigger_dma(3);
       break;
 
@@ -978,48 +1114,56 @@
 
     // Timer control (trigger byte)
     case 0x103:
-      access_register8_low(0x102);
+      access_register8_high(0x102);
       trigger_timer(0);
       break;
 
     case 0x107:
-      access_register8_low(0x106);
+      access_register8_high(0x106);
       trigger_timer(1);
       break;
 
     case 0x10B:
-      access_register8_low(0x10A);
+      access_register8_high(0x10A);
       trigger_timer(2);
       break;
 
     case 0x10F:
-      access_register8_low(0x10E);
+      access_register8_high(0x10E);
       trigger_timer(3);
       break;
 
-    // RCNT
-    case 0x134:
-      ADDRESS16(io_registers, 0x134) = value;
+    // P1
+    case 0x130:
+    case 0x131:
+      /* Read only */
       break;
 
     // IF
     case 0x202:
-      ADDRESS8(io_registers, 0x202) &= ~value;
+    case 0x203:
+      ADDRESS8(io_registers, address) &= ~value;
       break;
 
-    case 0x203:
-      ADDRESS8(io_registers, 0x203) &= ~value;
+    // WAITCNT
+    case 0x204:
+      access_register8_low(0x204);
+      waitstate_control();
+      break;
+
+    case 0x205:
+      access_register8_high(0x204);
+      waitstate_control();
       break;
 
     // Halt
     case 0x301:
-      if((value & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x80)
         reg[CPU_HALT_STATE] = CPU_STOP;
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
 
       return CPU_ALERT_HALT;
-      break;
 
     default:
       ADDRESS8(io_registers, address) = value;
@@ -1035,8 +1179,9 @@
   {
     case 0x00:
     {
-      u32 dispcnt = io_registers[REG_DISPCNT];
-      if((value & 0x07) != (dispcnt & 0x07))
+      u16 bg_mode = io_registers[REG_DISPCNT] & 0x07;
+
+      if((value & 0x07) != bg_mode)
         oam_update = 1;
 
       ADDRESS16(io_registers, 0x00) = value;
@@ -1051,6 +1196,7 @@
 
     // VCOUNT
     case 0x06:
+      /* Read only */
       break;
 
     // BG2 reference X
@@ -1179,12 +1324,16 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue16(0, value);
+    case 0xA2:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue16(1, value);
+    case 0xA6:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control
@@ -1240,11 +1389,7 @@
 
     // P1
     case 0x130:
-      break;
-
-    // RCNT
-    case 0x134:
-      ADDRESS16(io_registers, 0x134) = value;
+      /* Read only */
       break;
 
     // Interrupt flag
@@ -1254,14 +1399,15 @@
 
     // WAITCNT
     case 0x204:
+      waitstate_control();
       break;
 
     // Halt
     case 0x300:
-      if(((value >> 8) & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x8000)
         reg[CPU_HALT_STATE] = CPU_STOP;
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
 
       return CPU_ALERT_HALT;
 
@@ -1304,12 +1450,14 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue32(0, value);
+      ADDRESS32(io_registers, 0xA0) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue32(1, value);
+      ADDRESS32(io_registers, 0xA4) = value;
+      sound_timer_queue32(1);
       break;
 
     default:
@@ -1330,27 +1478,15 @@
   return CPU_ALERT_NONE;
 }
 
+
 #define write_palette8(address, value)                                        \
+  ADDRESS16(palette_ram, (address & ~0x01)) = ((value << 8) | value)          \
 
 #define write_palette16(address, value)                                       \
-{                                                                             \
-  u32 palette_address = address;                                              \
-  ADDRESS16(palette_ram, palette_address) = value;                            \
-  CONVERT_PALETTE(value);                                                     \
-  ADDRESS16(palette_ram_converted, palette_address) = value;                  \
-}                                                                             \
+  ADDRESS16(palette_ram, address) = value                                     \
 
 #define write_palette32(address, value)                                       \
-{                                                                             \
-  u32 palette_address = address;                                              \
-  u32 value_high = value >> 16;                                               \
-  u32 value_low = value & 0xFFFF;                                             \
-  ADDRESS32(palette_ram, palette_address) = value;                            \
-  CONVERT_PALETTE(value_high);                                                \
-  CONVERT_PALETTE(value_low);                                                 \
-  value = (value_high << 16) | value_low;                                     \
-  ADDRESS32(palette_ram_converted, palette_address) = value;                  \
-}                                                                             \
+  ADDRESS32(palette_ram, address) = value                                     \
 
 
 void write_backup(u32 address, u32 value)
@@ -1450,9 +1586,8 @@
     }
     else
 
-    if((flash_command_position == 0) &&
-     (flash_mode == FLASH_BANKSWITCH_MODE) && (address == 0x0000) &&
-     (flash_size == FLASH_SIZE_128KB))
+    if((flash_command_position == 0) && (flash_mode == FLASH_BANKSWITCH_MODE) &&
+     (address == 0x0000) && (flash_size == FLASH_SIZE_128KB))
     {
       flash_bank_ptr = gamepak_backup + ((value & 0x01) * (1024 * 64));
       flash_mode = FLASH_BASE_MODE;
@@ -1487,15 +1623,52 @@
 
 #define write_backup32()                                                      \
 
+
 #define write_vram8()                                                         \
-  address &= ~0x01;                                                           \
-  ADDRESS16(vram, address) = ((value << 8) | value)                           \
+  if((address & 0x1FFFF) >= obj_address[io_registers[REG_DISPCNT] & 0x07])    \
+  {                                                                           \
+    break;                                                                    \
+  }                                                                           \
+  if(address & 0x10000)                                                       \
+  {                                                                           \
+    ADDRESS16(vram, address & 0x17FFe) = ((value << 8) | value);              \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    ADDRESS16(vram, address & 0x1FFFe) = ((value << 8) | value);              \
+  }                                                                           \
 
 #define write_vram16()                                                        \
-  ADDRESS16(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+  {                                                                           \
+    ADDRESS16(vram, address & 0x17FFF) = value;                               \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    ADDRESS16(vram, address & 0x1FFFF) = value;                               \
+  }                                                                           \
 
 #define write_vram32()                                                        \
-  ADDRESS32(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+  {                                                                           \
+    ADDRESS32(vram, address & 0x17FFF) = value;                               \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    ADDRESS32(vram, address & 0x1FFFF) = value;                               \
+  }                                                                           \
+
+
+#define write_oam_ram8()                                                      \
+
+#define write_oam_ram16()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS16(oam_ram, address & 0x3FF) = value                                 \
+
+#define write_oam_ram32()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS32(oam_ram, address & 0x3FF) = value                                 \
+
 
 // RTC code derived from VBA's (due to lack of any real publically available
 // documentation...)
@@ -1527,14 +1700,14 @@
 
 rtc_state_type rtc_state = RTC_DISABLED;
 rtc_write_mode_type rtc_write_mode;
-u8 rtc_registers[3];
-u32 rtc_command;
-u32 rtc_data[12];
-u32 rtc_status = 0x40;
-u32 rtc_data_bytes;
-s32 rtc_bit_count;
+static u8 rtc_registers[3];
+static u32 rtc_command;
+static u32 rtc_data[12];
+static u32 rtc_status = 0x40;
+static u32 rtc_data_bytes;
+static s32 rtc_bit_count;
 
-u32 encode_bcd(u8 value)
+static u32 encode_bcd(u8 value)
 {
   return ((value / 10) << 4) | (value % 10);
 }
@@ -1546,7 +1719,9 @@
   map = memory_map_read[rtc_page_index];                                      \
                                                                               \
   if(map == NULL)                                                             \
+  {                                                                           \
     map = load_gamepak_page(rtc_page_index & 0x3FF);                          \
+  }                                                                           \
                                                                               \
   ADDRESS16(map, update_address & 0x7FFF) = _value                            \
 
@@ -1623,13 +1800,13 @@
                     break;
 
                   // Actually outputs the time, all of it
-                  // 0x65
                   case RTC_COMMAND_OUTPUT_TIME_FULL:
                   {
                     pspTime current_time;
                     sceRtcGetCurrentClockLocalTime(&current_time);
 
-                    int day_of_week = sceRtcGetDayOfWeek(current_time.year, current_time.month , current_time.day);
+                    int day_of_week = sceRtcGetDayOfWeek(current_time.year,
+                     current_time.month , current_time.day);
                     if(day_of_week == 0)
                       day_of_week = 6;
                     else
@@ -1648,7 +1825,6 @@
                   }
 
                   // Only outputs the current time of day.
-                  // 0x67
                   case RTC_COMMAND_OUTPUT_TIME:
                   {
                     pspTime current_time;
@@ -1690,10 +1866,6 @@
                       case RTC_WRITE_STATUS:
                         rtc_status = rtc_data[0];
                         break;
-
-                      default:
-                        ;
-                        break;
                     }
                   }
                 }
@@ -1729,10 +1901,6 @@
                 }
               }
               break;
-
-            default:
-              ;
-              break;
           }
         }
       }
@@ -1761,62 +1929,82 @@
 
 #define write_rtc32()                                                         \
 
-// type = 8 / 16 / 32
+
 #define write_memory(type)                                                    \
   switch(address >> 24)                                                       \
   {                                                                           \
     case 0x02:                                                                \
+    {                                                                         \
       /* external work RAM */                                                 \
-      address = (address & 0x7FFF) + ((address & 0x38000) * 2) + 0x8000;      \
+      address = (address & 0x7FFF) + ((address & 0x38000) << 1) + 0x8000;     \
       ADDRESS##type(ewram, address) = value;                                  \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x03:                                                                \
+    {                                                                         \
       /* internal work RAM */                                                 \
       ADDRESS##type(iwram, (address & 0x7FFF) + 0x8000) = value;              \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x04:                                                                \
+    {                                                                         \
       /* I/O registers */                                                     \
-      return write_io_register##type(address & 0xFFF, value);                 \
+      if(address < 0x04000400)                                                \
+      {                                                                       \
+        return write_io_register##type(address & 0x3FF, value);               \
+      }                                                                       \
+      break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x05:                                                                \
+    {                                                                         \
       /* palette RAM */                                                       \
       write_palette##type(address & 0x3FF, value);                            \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x06:                                                                \
+    {                                                                         \
       /* VRAM */                                                              \
-      address &= 0x1FFFF;                                                     \
-      if(address >= 0x18000)                                                  \
-        address -= 0x8000;                                                    \
-                                                                              \
       write_vram##type();                                                     \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x07:                                                                \
+    {                                                                         \
       /* OAM RAM */                                                           \
-      oam_update = 1;                                                         \
-      ADDRESS##type(oam_ram, address & 0x3FF) = value;                        \
+      write_oam_ram##type();                                                  \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x08:                                                                \
+    {                                                                         \
       /* gamepak ROM or RTC */                                                \
       write_rtc##type();                                                      \
       break;                                                                  \
-                                                                              \
-    case 0x09 ... 0x0C:                                                       \
-      /* gamepak ROM space */                                                 \
-      break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x0D:                                                                \
+    {                                                                         \
       write_eeprom(address, value);                                           \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x0E:                                                                \
+    {                                                                         \
       write_backup##type();                                                   \
       break;                                                                  \
   }                                                                           \
+                                                                              \
+    default:                                                                  \
+    {                                                                         \
+      /* unwritable */                                                        \
+      break;                                                                  \
+    }                                                                         \
+  }                                                                           \
+
 
 u8 read_memory8(u32 address)
 {
@@ -1898,14 +2087,16 @@
   return CPU_ALERT_NONE;
 }
 
-char backup_filename[512];
 
-u32 load_backup(char *name)
+static char backup_filename[MAX_FILE];
+
+u8 load_backup(char *name)
 {
-  char backup_path[1024];
-  FILE_ID backup_file;
+  FILE_TAG_TYPE backup_file;
+  char backup_path[MAX_PATH];
 
-  if (*default_save_dir != (char)NULL) {
+  if(*default_save_dir != (char)NULL)
+  {
     sprintf(backup_path, "%s/%s", default_save_dir, name);
   }
   else
@@ -1917,7 +2108,7 @@
 
   if(FILE_CHECK_VALID(backup_file))
   {
-    u32 backup_size = file_length(backup_path, backup_file);
+    u32 backup_size = file_length(backup_path);
 
     FILE_READ(backup_file, gamepak_backup, backup_size);
     FILE_CLOSE(backup_file);
@@ -1962,14 +2153,15 @@
   return 0;
 }
 
-u32 save_backup(char *name)
+static u8 save_backup(char *name)
 {
-  char backup_path[1024];
-  FILE_ID backup_file;
+  FILE_TAG_TYPE backup_file;
+  char backup_path[MAX_PATH];
 
   if(backup_type != BACKUP_NONE)
   {
-    if (*default_save_dir != (char)NULL) {
+    if(*default_save_dir != (char)NULL)
+    {
       sprintf(backup_path, "%s/%s", default_save_dir, name);
     }
     else
@@ -2005,10 +2197,6 @@
           else
             backup_size = 0x2000;
           break;
-
-        default:
-          ;
-          break;
       }
 
       FILE_WRITE(backup_file, gamepak_backup, backup_size);
@@ -2020,7 +2209,7 @@
   return 0;
 }
 
-void update_backup()
+void update_backup(void)
 {
   if(backup_update != (write_backup_delay + 1))
     backup_update--;
@@ -2032,7 +2221,7 @@
   }
 }
 
-void update_backup_force()
+void update_backup_force(void)
 {
   save_backup(backup_filename);
 }
@@ -2037,9 +2226,10 @@
   save_backup(backup_filename);
 }
 
+
 #define CONFIG_FILENAME "game_config.txt"
 
-char *skip_spaces(char *line_ptr)
+static char *skip_spaces(char *line_ptr)
 {
   while(*line_ptr == ' ')
     line_ptr++;
@@ -2047,7 +2237,8 @@
   return line_ptr;
 }
 
-s32 parse_config_line(char *current_line, char *current_variable, char *current_value)
+static s8 parse_config_line(char *current_line, char *current_variable,
+ char *current_value)
 {
   char *line_ptr = current_line;
   char *line_ptr_new;
@@ -2081,14 +2272,12 @@
   return 0;
 }
 
-s32 load_game_config(char *gamepak_title, char *gamepak_code, char *gamepak_maker)
+s8 load_game_config(char *gamepak_title, char *gamepak_code, char *gamepak_maker)
 {
   char current_line[256];
   char current_variable[256];
   char current_value[256];
-  char config_path[512];
-//  u8 *line_ptr;
-//  u32 fgets_value;
+  char config_path[MAX_PATH];
   FILE *config_file;
 
   idle_loop_targets = 0;
@@ -2098,6 +2287,7 @@
   bios_rom[0x2C] = 0x00;
   translation_gate_targets = 0;
   flash_device_id = FLASH_DEVICE_MACRONIX_64KB;
+  backup_type = BACKUP_NONE;
 
   sprintf(config_path, "%s/%s", main_path, CONFIG_FILENAME);
 
@@ -2107,39 +2297,39 @@
   {
     while(fgets(current_line, 256, config_file))
     {
-      if(parse_config_line(current_line, current_variable, current_value)
-       != -1)
+      if(parse_config_line(current_line, current_variable, current_value) != -1)
+      {
+        if(strcasecmp(current_variable, "game_name") ||
+         strcasecmp(current_value, gamepak_title))
       {
-        if(strcmp(current_variable, "game_name") ||
-         strcmp(current_value, gamepak_title))
           continue;
-
+        }
         if(!fgets(current_line, 256, config_file) ||
-         (parse_config_line(current_line, current_variable,
-           current_value) == -1) ||
-         strcmp(current_variable, "game_code") ||
-         strcmp(current_value, gamepak_code))
+         (parse_config_line(current_line, current_variable, current_value) == -1) ||
+         strcasecmp(current_variable, "game_code") ||
+         strcasecmp(current_value, gamepak_code))
+        {
           continue;
-
+        }
         if(!fgets(current_line, 256, config_file) ||
-         (parse_config_line(current_line, current_variable,
-           current_value) == -1) ||
-         strcmp(current_variable, "vender_code") ||
-          strcmp(current_value, gamepak_maker))
+         (parse_config_line(current_line, current_variable, current_value) == -1) ||
+         strcasecmp(current_variable, "vender_code") ||
+          strcasecmp(current_value, gamepak_maker))
+        {
           continue;
+        }
 
         while(fgets(current_line, 256, config_file))
         {
-          if(parse_config_line(current_line, current_variable, current_value)
-           != -1)
+          if(parse_config_line(current_line, current_variable, current_value) != -1)
           {
-            if(!strcmp(current_variable, "game_name"))
+            if(!strcasecmp(current_variable, "game_name"))
             {
               fclose(config_file);
               return 0;
             }
 
-            if(!strcmp(current_variable, "idle_loop_eliminate_target"))
+            if(!strcasecmp(current_variable, "idle_loop_eliminate_target"))
             {
               if(idle_loop_targets < MAX_IDLE_LOOPS)
               {
@@ -2149,7 +2339,7 @@
               }
             }
 
-            if(!strcmp(current_variable, "translation_gate_target"))
+            if(!strcasecmp(current_variable, "translation_gate_target"))
             {
               if(translation_gate_targets < MAX_TRANSLATION_GATES)
               {
@@ -2159,26 +2349,38 @@
               }
             }
 
-            if(!strcmp(current_variable, "iwram_stack_optimize") &&
-              !strcmp(current_value, "no"))
+            if(!strcasecmp(current_variable, "iwram_stack_optimize") &&
+              !strcasecmp(current_value, "no"))
             {
                 iwram_stack_optimize = 0;
             }
 
-            if(!strcmp(current_variable, "flash_rom_type") &&
-              !strcmp(current_value, "128KB"))
+            if(!strcasecmp(current_variable, "flash_rom_type") &&
+              !strcasecmp(current_value, "128KB"))
             {
               flash_device_id = FLASH_DEVICE_MACRONIX_128KB;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_39") &&
-              !strcmp(current_value, "yes"))
+            if(!strcasecmp(current_variable, "save_type"))
+            {
+              if(!strcasecmp(current_value, "sram"))
+                backup_type = BACKUP_SRAM;
+              else
+              if(!strcasecmp(current_value, "flash"))
+                backup_type = BACKUP_FLASH;
+              else
+              if(!strcasecmp(current_value, "eeprom"))
+                backup_type = BACKUP_EEPROM;
+            }
+
+            if(!strcasecmp(current_variable, "bios_rom_hack_39") &&
+              !strcasecmp(current_value, "yes"))
             {
               bios_rom[0x39] = 0xC0;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_2C") &&
-              !strcmp(current_value, "yes"))
+            if(!strcasecmp(current_variable, "bios_rom_hack_2C") &&
+              !strcasecmp(current_value, "yes"))
             {
                bios_rom[0x2C] = 0x02;
             }
@@ -2196,19 +2398,21 @@
   return -1;
 }
 
-s32 load_gamepak_raw(char *name)
+
+static char gamepak_title[13];
+static char gamepak_code[5];
+static char gamepak_maker[3];
+char gamepak_filename[MAX_FILE];
+char gamepak_filename_raw[MAX_FILE];
+
+static s32 load_gamepak_raw(char *name)
 {
-  FILE_ID gamepak_file;
+  FILE_TAG_TYPE gamepak_file;
   FILE_OPEN(gamepak_file, name, READ);
 
   if(FILE_CHECK_VALID(gamepak_file))
   {
-    u32 gamepak_size = file_length(name, gamepak_file);
-
-    // First, close the last one if it was open, we won't
-    // be needing it anymore.
-    if(FILE_CHECK_VALID(gamepak_file_large))
-      FILE_CLOSE(gamepak_file_large);
+    u32 gamepak_size = file_length(name);
 
     // If it's a big file size keep it don't close it, we'll
     // probably want to load it later
@@ -2216,16 +2420,16 @@
     {
       FILE_READ(gamepak_file, gamepak_rom, gamepak_size);
       FILE_CLOSE(gamepak_file);
-
-      gamepak_file_large = -1;
     }
     else
     {
       // Read in just enough for the header
       FILE_READ(gamepak_file, gamepak_rom, 0x100);
       gamepak_file_large = gamepak_file;
-      strcpy(gamepak_filename_raw, name);
-//      FILE_CLOSE(gamepak_file);
+
+      char current_dir[MAX_PATH];
+      getcwd(current_dir, MAX_PATH);
+      sprintf(gamepak_filename_raw, "%s/%s", current_dir, name);
     }
 
     return gamepak_size;
@@ -2234,23 +2438,44 @@
   return -1;
 }
 
-u32 load_gamepak(char *name)
+s8 load_gamepak(char *name)
 {
   char *dot_position = strrchr(name, '.');
   s32 file_size;
-  char cheats_filename[256];
+  char cheats_filename[MAX_FILE];
+
+  // First, close the last one if it was open, we won't
+  // be needing it anymore.
+//  if(FILE_CHECK_VALID(gamepak_file_large))
+//    FILE_CLOSE(gamepak_file_large);
+
+  gamepak_file_large = -1;
 
-  if(!strcmp(dot_position, ".zip"))
+  clear_screen(0x0000);
+  print_string(msg[MSG_LOADING_ROM], 0xFFFF, 0x0000, 5, 5);
+
+  if(!strcasecmp(dot_position, ".zip") || !strcasecmp(dot_position, ".gbz"))
+  {
+    set_cpu_clock(333);
     file_size = load_file_zip(name);
+  }
   else
+  {
     file_size = load_gamepak_raw(name);
+  }
 
   if(file_size != -1)
   {
     gamepak_size = (file_size + 0x7FFF) & ~0x7FFF;
 
+    char *p = strrchr(name, '/');
+    if(p != NULL)
+    {
+      name = p + 1;
+    }
+
     strcpy(backup_filename, name);
-    strncpy(gamepak_filename, name, 512);
+    strncpy(gamepak_filename, name, MAX_FILE);
     change_ext(gamepak_filename, backup_filename, ".sav");
 
     load_backup(backup_filename);
@@ -2274,17 +2499,16 @@
   return -1;
 }
 
-s32 load_bios(char *name)
+s8 load_bios(char *name)
 {
+  FILE_TAG_TYPE bios_file;
   u8 md5[16];
-  FILE_ID bios_file;
+
   FILE_OPEN(bios_file, name, READ);
 
   if(FILE_CHECK_VALID(bios_file))
   {
     FILE_READ(bios_file, bios_rom, 0x4000);
-    // This is a hack to get Zelda working, because emulating
-    // the proper memory read behavior here is much too expensive.
     FILE_CLOSE(bios_file);
     // BIOS�t�@�C����MD5�𓾂�
     sceKernelUtilsMd5Digest(bios_rom, 0x4000, md5);
@@ -2348,10 +2574,10 @@
 };
 
 #define dma_adjust_ptr_inc(ptr, size)                                         \
-  ptr += (size / 8)                                                           \
+  ptr += (size >> 3)                                                          \
 
 #define dma_adjust_ptr_dec(ptr, size)                                         \
-  ptr -= (size / 8)                                                           \
+  ptr -= (size >> 3)                                                          \
 
 #define dma_adjust_ptr_fix(ptr, size)                                         \
 
@@ -2374,6 +2600,10 @@
   dma_smc_vars_##type()                                                       \
 
 #define dma_vars_vram(type)                                                   \
+  if(type##_ptr & 0x10000)                                                    \
+  {                                                                           \
+    type##_ptr &= ~0x08000;                                                   \
+  }                                                                           \
 
 #define dma_vars_palette_ram(type)                                            \
 
@@ -2400,7 +2630,9 @@
   if(type##_address_block == NULL)                                            \
   {                                                                           \
     if((type##_ptr & 0x1FFFFFF) >= gamepak_size)                              \
+    {                                                                         \
       break;                                                                  \
+    }                                                                         \
     type##_address_block = load_gamepak_page(type##_current_region & 0x3FF);  \
   }                                                                           \
 
@@ -2476,7 +2708,7 @@
   ADDRESS##transfer_size(vram, type##_ptr & 0x1FFFF) = read_value             \
 
 #define dma_write_io(type, transfer_size)                                     \
-  write_io_register##transfer_size(type##_ptr & 0xFFF, read_value)            \
+  write_io_register##transfer_size(type##_ptr & 0x3FF, read_value)            \
 
 #define dma_write_oam_ram(type, transfer_size)                                \
   ADDRESS##transfer_size(oam_ram, type##_ptr & 0x3FF) = read_value            \
@@ -2522,7 +2754,7 @@
 #define dma_epilogue_ext()                                                    \
 
 #define print_line()                                                          \
-  dma_print(src_op, dest_op, transfer_size, wb);                              \
+  dma_print(src_op, dest_op, transfer_size, wb)                               \
 
 #define dma_transfer_loop_region(src_region_type, dest_region_type, src_op,   \
  dest_op, transfer_size, wb)                                                  \
@@ -2543,7 +2775,7 @@
   break;                                                                      \
 }                                                                             \
 
-#define dma_transfer_loop(src_op, dest_op, transfer_size, wb);                \
+#define dma_transfer_loop(src_op, dest_op, transfer_size, wb)                 \
 {                                                                             \
   u32 src_region = src_ptr >> 24;                                             \
   u32 dest_region = dest_ptr >> 24;                                           \
@@ -2553,257 +2785,383 @@
   switch(src_region_type | (dest_region_type << 4))                           \
   {                                                                           \
     case (DMA_REGION_BIOS | (DMA_REGION_IWRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(bios, iwram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_IWRAM << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(iwram, iwram, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_IWRAM << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(ewram, iwram, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_IWRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(vram, iwram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_IWRAM << 4)):                  \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, iwram, src_op, dest_op,           \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_IWRAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, iwram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_IWRAM << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(io, iwram, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_IWRAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, iwram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_IWRAM << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(ext, iwram, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_EWRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(bios, ewram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_EWRAM << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(iwram, ewram, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_EWRAM << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(ewram, ewram, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_EWRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(vram, ewram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_EWRAM << 4)):                  \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, ewram, src_op, dest_op,           \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_EWRAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, ewram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_EWRAM << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(io, ewram, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_EWRAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, ewram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_EWRAM << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(ext, ewram, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_VRAM << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(bios, vram, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_VRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(iwram, vram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_VRAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(ewram, vram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_VRAM << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(vram, vram, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_VRAM << 4)):                   \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, vram, src_op, dest_op,            \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_VRAM << 4)):                       \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, vram, src_op, dest_op,                \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_VRAM << 4)):                            \
+    {                                                                         \
       dma_transfer_loop_region(io, vram, src_op, dest_op,                     \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_VRAM << 4)):                       \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, vram, src_op, dest_op,                \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_VRAM << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(ext, vram, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_PALETTE_RAM << 4)):                   \
+    {                                                                         \
       dma_transfer_loop_region(bios, palette_ram, src_op, dest_op,            \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_PALETTE_RAM << 4)):                  \
+    {                                                                         \
       dma_transfer_loop_region(iwram, palette_ram, src_op, dest_op,           \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_PALETTE_RAM << 4)):                  \
+    {                                                                         \
       dma_transfer_loop_region(ewram, palette_ram, src_op, dest_op,           \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_PALETTE_RAM << 4)):                   \
+    {                                                                         \
       dma_transfer_loop_region(vram, palette_ram, src_op, dest_op,            \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_PALETTE_RAM << 4)):            \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, palette_ram, src_op, dest_op,     \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_PALETTE_RAM << 4)):                \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, palette_ram, src_op, dest_op,         \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_PALETTE_RAM << 4)):                     \
+    {                                                                         \
       dma_transfer_loop_region(io, palette_ram, src_op, dest_op,              \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_PALETTE_RAM << 4)):                \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, palette_ram, src_op, dest_op,         \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_PALETTE_RAM << 4)):                    \
+    {                                                                         \
       dma_transfer_loop_region(ext, palette_ram, src_op, dest_op,             \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_OAM_RAM << 4)):                       \
+    {                                                                         \
       dma_transfer_loop_region(bios, oam_ram, src_op, dest_op,                \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_OAM_RAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(iwram, oam_ram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_OAM_RAM << 4)):                      \
+    {                                                                         \
       dma_transfer_loop_region(ewram, oam_ram, src_op, dest_op,               \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_OAM_RAM << 4)):                       \
+    {                                                                         \
       dma_transfer_loop_region(vram, oam_ram, src_op, dest_op,                \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_OAM_RAM << 4)):                \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, oam_ram, src_op, dest_op,         \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_OAM_RAM << 4)):                    \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, oam_ram, src_op, dest_op,             \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_OAM_RAM << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(io, oam_ram, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_OAM_RAM << 4)):                    \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, oam_ram, src_op, dest_op,             \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_OAM_RAM << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(ext, oam_ram, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_IO << 4)):                            \
+    {                                                                         \
       dma_transfer_loop_region(bios, io, src_op, dest_op,                     \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_IO << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(iwram, io, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_IO << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(ewram, io, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_IO << 4)):                            \
+    {                                                                         \
       dma_transfer_loop_region(vram, io, src_op, dest_op,                     \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_IO << 4)):                     \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, io, src_op, dest_op,              \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_IO << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, io, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_IO << 4)):                              \
+    {                                                                         \
       dma_transfer_loop_region(io, io, src_op, dest_op,                       \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_IO << 4)):                         \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, io, src_op, dest_op,                  \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_IO << 4)):                             \
+    {                                                                         \
       dma_transfer_loop_region(ext, io, src_op, dest_op,                      \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_BIOS | (DMA_REGION_EXT << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(bios, ext, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IWRAM | (DMA_REGION_EXT << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(iwram, ext, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EWRAM | (DMA_REGION_EXT << 4)):                          \
+    {                                                                         \
       dma_transfer_loop_region(ewram, ext, src_op, dest_op,                   \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_VRAM | (DMA_REGION_EXT << 4)):                           \
+    {                                                                         \
       dma_transfer_loop_region(vram, ext, src_op, dest_op,                    \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_PALETTE_RAM | (DMA_REGION_EXT << 4)):                    \
+    {                                                                         \
       dma_transfer_loop_region(palette_ram, ext, src_op, dest_op,             \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_OAM_RAM | (DMA_REGION_EXT << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(oam_ram, ext, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_IO | (DMA_REGION_EXT << 4)):                             \
+    {                                                                         \
       dma_transfer_loop_region(io, ext, src_op, dest_op,                      \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_GAMEPAK | (DMA_REGION_EXT << 4)):                        \
+    {                                                                         \
       dma_transfer_loop_region(gamepak, ext, src_op, dest_op,                 \
        transfer_size, wb);                                                    \
+    }                                                                         \
                                                                               \
     case (DMA_REGION_EXT | (DMA_REGION_EXT << 4)):                            \
+    {                                                                         \
       dma_transfer_loop_region(ext, ext, src_op, dest_op,                     \
        transfer_size, wb);                                                    \
   }                                                                           \
+  }                                                                           \
   break;                                                                      \
 }                                                                             \
 
@@ -2811,53 +3169,85 @@
   switch((dma->dest_direction << 2) | dma->source_direction)                  \
   {                                                                           \
     case 0x00:                                                                \
+    {                                                                         \
       dma_transfer_loop(inc, inc, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x01:                                                                \
+    {                                                                         \
       dma_transfer_loop(dec, inc, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x02:                                                                \
+    {                                                                         \
       dma_transfer_loop(fix, inc, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x03:                                                                \
+    {                                                                         \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x04:                                                                \
+    {                                                                         \
       dma_transfer_loop(inc, dec, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x05:                                                                \
+    {                                                                         \
       dma_transfer_loop(dec, dec, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x06:                                                                \
+    {                                                                         \
       dma_transfer_loop(fix, dec, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x07:                                                                \
+    {                                                                         \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x08:                                                                \
+    {                                                                         \
       dma_transfer_loop(inc, fix, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x09:                                                                \
+    {                                                                         \
       dma_transfer_loop(dec, fix, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x0A:                                                                \
+    {                                                                         \
       dma_transfer_loop(fix, fix, transfer_size, writeback);                  \
+    }                                                                         \
                                                                               \
     case 0x0B:                                                                \
+    {                                                                         \
       break;                                                                  \
+    }                                                                         \
                                                                               \
     case 0x0C:                                                                \
+    {                                                                         \
       dma_transfer_loop(inc, inc, transfer_size, reload);                     \
+    }                                                                         \
                                                                               \
     case 0x0D:                                                                \
+    {                                                                         \
       dma_transfer_loop(dec, inc, transfer_size, reload);                     \
+    }                                                                         \
                                                                               \
     case 0x0E:                                                                \
+    {                                                                         \
       dma_transfer_loop(fix, inc, transfer_size, reload);                     \
+    }                                                                         \
                                                                               \
     case 0x0F:                                                                \
+    {                                                                         \
       break;                                                                  \
   }                                                                           \
+  }                                                                           \
 
 CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma)
 {
@@ -2890,14 +3280,14 @@
   {
     src_ptr &= ~0x01;
     dest_ptr &= ~0x01;
-    cycle_dma16_words += length;
+//    cycle_dma16_words += length;
     dma_transfer_expand(16);
   }
   else
   {
     src_ptr &= ~0x03;
     dest_ptr &= ~0x03;
-    cycle_dma32_words += length;
+//    cycle_dma32_words += length;
     dma_transfer_expand(32);
   }
 
@@ -2905,14 +3295,13 @@
    (dma->start_type == DMA_START_IMMEDIATELY))
   {
     dma->start_type = DMA_INACTIVE;
-    ADDRESS16(io_registers, (dma->dma_channel * 12) + 0xBA) &=
-     (~0x8000);
+    ADDRESS16(io_registers, (dma->dma_channel * 12) + 0xBA) &= (~0x8000);
   }
 
   if(dma->irq)
   {
     raise_interrupt(IRQ_DMA0 << dma->dma_channel);
-    return_value = CPU_ALERT_IRQ;
+    return_value |= CPU_ALERT_IRQ;
   }
 
   return return_value;
@@ -2965,9 +3354,9 @@
 
 
 // Picks a page to evict
-u32 page_time = 0;
+static u32 page_time = 0;
 
-u32 evict_gamepak_page()
+static u32 evict_gamepak_page(void)
 {
   // Find the one with the smallest frame timestamp
   u32 page_index = 0;
@@ -3011,8 +3398,6 @@
   FILE_SEEK(gamepak_file_large, physical_index * (32 * 1024), SEEK_SET);
   FILE_READ(gamepak_file_large, swap_location, (32 * 1024));
 
-//  FILE_CLOSE(gamepak_file_large);
-
   memory_map_read[(0x8000000 / (32 * 1024)) + physical_index] = swap_location;
   memory_map_read[(0xA000000 / (32 * 1024)) + physical_index] = swap_location;
   memory_map_read[(0xC000000 / (32 * 1024)) + physical_index] = swap_location;
@@ -3026,7 +3411,7 @@
   return swap_location;
 }
 
-void init_memory_gamepak()
+static void init_memory_gamepak(void)
 {
   u32 map_offset = 0;
 
@@ -3054,18 +3439,21 @@
   }
 }
 
-void init_gamepak_buffer()
+void init_gamepak_buffer(void)
 {
-  // Try to initialize 32MB (this is mainly for non-PSP platforms)
   gamepak_rom = NULL;
 
-  gamepak_ram_buffer_size = 16 * 1024 * 1024;
-  gamepak_rom = malloc(gamepak_ram_buffer_size);
-
-  if(gamepak_rom == NULL)
+  // initialize 32MB (PSP-2000 && CFW 3.71 M33 or higher.)
+  if((kuKernelGetModel() == PSP_MODEL_SLIM_AND_LITE) &&
+     (sceKernelDevkitVersion() >= 0x03070110))
+  {
+    gamepak_ram_buffer_size = 32 * 1024 * 1024;
+    gamepak_rom = (u8 *)0x0a000000;
+  }
+  else
   {
     // Try 16MB, for PSP, then lower in 2MB increments
-    gamepak_ram_buffer_size = 14 * 1024 * 1024;
+    gamepak_ram_buffer_size = 16 * 1024 * 1024;
     gamepak_rom = malloc(gamepak_ram_buffer_size);
 
     while(gamepak_rom == NULL)
@@ -3082,7 +3470,7 @@
    gamepak_ram_pages);
 }
 
-void init_memory()
+void init_memory(void)
 {
   u32 map_offset = 0;
 
@@ -3125,7 +3513,6 @@
   map_ram_region(read, 0x3000000, 0x4000000, 1, iwram);
   map_region(read, 0x4000000, 0x5000000, 1, io_registers);
   map_null(read, 0x5000000, 0x6000000);
-  map_null(read, 0x6000000, 0x7000000);
   map_vram(read);
   map_null(read, 0x7000000, 0x8000000);
   init_memory_gamepak();
@@ -3178,8 +3565,6 @@
   io_registers[REG_BG3PD] = 0x100;
   io_registers[REG_RCNT] = 0x8000;
 
-  backup_type = BACKUP_NONE;
-
   sram_size = SRAM_SIZE_32KB;
   flash_size = FLASH_SIZE_64KB;
 
@@ -3196,19 +3581,30 @@
   memset(rtc_registers, 0, sizeof(rtc_registers));
   bios_read_protect = 0xe129f000;
 
+  enable_motion_sensor = 0;
 }
 
-void bios_region_read_allow()
+void bios_region_read_allow(void)
 {
   memory_map_read[0] = bios_rom;
 }
-
-void bios_region_read_protect()
+/*
+void bios_region_read_protect(void)
 {
   memory_map_read[0] = NULL;
 }
+*/
+
+void memory_exit(void)
+{
+  free(gamepak_memory_map);
+  free(gamepak_rom);
+}
+
+
+void memory_write_mem_savestate(FILE_TAG_TYPE savestate_file);
+void memory_read_savestate(FILE_TAG_TYPE savestate_file);
 
-// type = read / write_mem
 #define savestate_block(type)                                                 \
   cpu_##type##_savestate(savestate_file);                                     \
   input_##type##_savestate(savestate_file);                                   \
@@ -3219,25 +3615,22 @@
 
 void load_state(char *savestate_filename)
 {
-  char savestate_path[1024];
-  FILE_ID savestate_file;
+  FILE_TAG_TYPE savestate_file;
+  char savestate_path[MAX_PATH];
 
-  if (*default_save_dir != (char)NULL) {
+  if(*default_save_dir != (char)NULL)
     sprintf(savestate_path, "%s/%s", default_save_dir, savestate_filename);
-  }
   else
-  {
     strcpy(savestate_path, savestate_filename);
-  }
 
   FILE_OPEN(savestate_file, savestate_path, READ);
+
   if(FILE_CHECK_VALID(savestate_file))
   {
-    char current_gamepak_filename[512];
+    char current_gamepak_filename[MAX_FILE];
     u32 i;
-    u32 current_color;
 
-    FILE_SEEK(savestate_file, (240 * 160 * 2) + sizeof(time_t), SEEK_SET);
+    FILE_SEEK(savestate_file, (240 * 160 * 2) + sizeof(u64), SEEK_SET);
 
     strcpy(current_gamepak_filename, gamepak_filename);
 
@@ -3272,39 +3666,28 @@
       }
     }
 
-    for(i = 0; i < 512; i++)
-    {
-      current_color = palette_ram[i];
-      palette_ram_converted[i] =
-       CONVERT_PALETTE(current_color);
-    }
-
     // Oops, these contain raw pointers
     for(i = 0; i < 4; i++)
     {
       gbc_sound_channel[i].sample_data = square_pattern_duty[2];
     }
-    instruction_count = 0;
 
     reg[CHANGED_PC_STATUS] = 1;
   }
 }
 
-u8 savestate_write_buffer[506947];
+static u8 savestate_write_buffer[506947];
 u8 *write_mem_ptr;
 
 void save_state(char *savestate_filename, u16 *screen_capture)
 {
-  char savestate_path[1024];
-  FILE_ID savestate_file;
+  FILE_TAG_TYPE savestate_file;
+  char savestate_path[MAX_PATH];
 
-  if (*default_save_dir != (char)NULL) {
+  if(*default_save_dir != (char)NULL)
     sprintf(savestate_path, "%s/%s", default_save_dir, savestate_filename);
-  }
   else
-  {
     strcpy(savestate_path, savestate_filename);
-  }
 
   write_mem_ptr = savestate_write_buffer;
   FILE_OPEN(savestate_file, savestate_path, WRITE);
@@ -3308,12 +3691,13 @@
 
   write_mem_ptr = savestate_write_buffer;
   FILE_OPEN(savestate_file, savestate_path, WRITE);
+
   if(FILE_CHECK_VALID(savestate_file))
   {
-    time_t current_time;
+    u64 current_time;
     FILE_WRITE_MEM(savestate_file, screen_capture, 240 * 160 * 2);
 
-    time(&current_time);
+    sceRtcGetCurrentTick(&current_time);
     FILE_WRITE_MEM_VARIABLE(savestate_file, current_time);
 
     savestate_block(write_mem);
diff -ruibwEB --strip-trailing-cr -I RE old/memory.h mod/memory.h
--- old/memory.h	2007-08-26 00:49:54.994782600 +0900
+++ mod/memory.h	2007-10-27 22:42:46.939358400 +0900
@@ -21,8 +21,6 @@
 #ifndef MEMORY_H
 #define MEMORY_H
 
-#define MAX_TRANSLATION_GATES 8
-#define MAX_IDLE_LOOPS 8
 
 typedef enum
 {
@@ -140,13 +138,26 @@
   REG_HALTCNT = 0x180
 } HARDWARE_REGISTER;
 
-// �O���[�o���ϐ��錾
+typedef enum
+{
+  FLASH_DEVICE_MACRONIX_64KB   = 0x1C,
+  FLASH_DEVICE_AMTEL_64KB      = 0x3D,
+  FLASH_DEVICE_SST_64K         = 0xD4,
+  FLASH_DEVICE_PANASONIC_64KB  = 0x1B,
+  FLASH_DEVICE_MACRONIX_128KB  = 0x09
+} FLASH_DEVICE_ID_TYPE;
+
+typedef enum
+{
+  FLASH_MANUFACTURER_MACRONIX  = 0xC2,
+  FLASH_MANUFACTURER_AMTEL     = 0x1F,
+  FLASH_MANUFACTURER_PANASONIC = 0x32,
+  FLASH_MANUFACTURER_SST       = 0xBF
+} FLASH_MANUFACTURER_ID_TYPE;
+
 
-extern char gamepak_title[13];
-extern char gamepak_code[5];
-extern char gamepak_maker[3];
-extern char gamepak_filename[512];
-extern char gamepak_filename_raw[512];
+extern char gamepak_filename[MAX_FILE];
+extern char gamepak_filename_raw[MAX_FILE];
 
 extern u8 *gamepak_rom;
 extern u32 gamepak_ram_buffer_size;
@@ -150,14 +161,17 @@
 
 extern u8 *gamepak_rom;
 extern u32 gamepak_ram_buffer_size;
+
 extern u32 oam_update;
-extern u32 gbc_sound_update;
+extern u8 gbc_sound_update;
+extern u8 gbc_sound_wave_update;
+
 extern DMA_TRANSFER_TYPE dma[4];
 
 extern u8 *write_mem_ptr;
 
+extern u16 palette_ram[512];
 extern u16 oam_ram[512];
-extern u16 palette_ram_converted[512];
 extern u16 io_registers[1024 * 16];
 extern u8 ewram[1024 * 256 * 2];
 extern u8 iwram[1024 * 32 * 2];
@@ -166,35 +180,61 @@
 extern u8 bios_rom[1024 * 32];
 extern u32 bios_read_protect;
 
+extern u8 waitstate_cycles_seq[2][16];
+extern u8 waitstate_cycles_non_seq[2][16];
+extern u8 waitstate_cycles_fetch[2][16];
+
+extern const u32 obj_address[6];
+
 extern u8 *memory_map_read[8 * 1024];
-extern u32 reg[64];
 extern u8 *memory_map_write[8 * 1024];
 
+extern u32 reg[64];
+
 extern FILE_TAG_TYPE gamepak_file_large;
 
-// �֐��錾
+u8 read_memory8(u32 address);
+u32 read_memory16(u32 address);
+u16 read_memory16_signed(u32 address);
+u32 read_memory32(u32 address);
+
+CPU_ALERT_TYPE write_memory8(u32 address, u8 value);
+CPU_ALERT_TYPE write_memory16(u32 address, u16 value);
+CPU_ALERT_TYPE write_memory32(u32 address, u32 value);
+
+CPU_ALERT_TYPE write_io_register8(u32 address, u32 value);
+CPU_ALERT_TYPE write_io_register16(u32 address, u32 value);
+CPU_ALERT_TYPE write_io_register32(u32 address, u32 value);
+
+CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma);
+
+u8 *memory_region(u32 address, u32 *memory_limit);
+
+s8 load_bios(char *name);
+s8 load_gamepak(char *name);
+u8 *load_gamepak_page(u32 physical_index);
+u8 load_backup(char *name);
+
+u8 read_backup(u32 address);
+u32 read_eeprom(void);
+void write_eeprom(u32 address, u32 value);
+void write_backup(u32 address, u32 value);
+void write_rtc(u32 address, u32 value);
+
+s8 load_game_config(char *gamepak_title, char *gamepak_code, char *gamepak_maker);
+
+void init_memory(void);
+void init_gamepak_buffer(void);
+void memory_exit(void);
+
+void update_backup(void);
+void update_backup_force(void);
+
+void bios_region_read_allow(void);
+// void bios_region_read_protect(void);
+
+void load_state(char *savestate_filename);
+void save_state(char *savestate_filename, u16 *screen_capture);
 
-extern u8 read_memory8(u32 address);
-extern u32 read_memory16(u32 address);
-extern u16 read_memory16_signed(u32 address);
-extern u32 read_memory32(u32 address);
-extern CPU_ALERT_TYPE write_memory8(u32 address, u8 value);
-extern CPU_ALERT_TYPE write_memory16(u32 address, u16 value);
-extern CPU_ALERT_TYPE write_memory32(u32 address, u32 value);
-
-extern CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma);
-extern u8 *memory_region(u32 address, u32 *memory_limit);
-extern s32 load_bios(char *name);
-extern u32 load_gamepak(char *name);
-extern u8 *load_gamepak_page(u32 physical_index);
-extern u32 load_backup(char *name);
-extern void init_memory();
-extern void init_gamepak_buffer();
-extern void update_backup();
-extern void update_backup_force();
-extern void bios_region_read_allow();
-extern void bios_region_read_protect();
-extern void load_state(char *savestate_filename);
-extern void save_state(char *savestate_filename, u16 *screen_capture);
 
-#endif
+#endif /* MEMORY_H */
diff -ruibwEB --strip-trailing-cr -I RE old/message.h mod/message.h
--- old/message.h	2007-08-26 00:49:55.104782600 +0900
+++ mod/message.h	2007-09-26 23:26:25.535272000 +0900
@@ -26,13 +26,12 @@
 
   MSG_RETURN_MENU,
 
-  MSG_MENU_DATE,
-  MSG_MENU_BATTERY,
-
   MSG_MENU_DATE_FMT_0,
   MSG_MENU_DATE_FMT_1,
   MSG_MENU_DATE_FMT_2,
 
+  MSG_MAIN_MENU_TITLE,
+
   MSG_MAIN_MENU_0,
   MSG_MAIN_MENU_1,
   MSG_MAIN_MENU_2,
@@ -57,25 +56,27 @@
   MSG_MAIN_MENU_HELP_9,
   MSG_MAIN_MENU_HELP_10,
 
-  MSG_G_S_MENU_0,
-  MSG_G_S_MENU_1,
-  MSG_G_S_MENU_2,
-  MSG_G_S_MENU_3,
-  MSG_G_S_MENU_4,
-  MSG_G_S_MENU_5,
-  MSG_G_S_MENU_6,
-  MSG_G_S_MENU_7,
-  MSG_G_S_MENU_8,
-
-  MSG_G_S_MENU_HELP_0,
-  MSG_G_S_MENU_HELP_1,
-  MSG_G_S_MENU_HELP_2,
-  MSG_G_S_MENU_HELP_3,
-  MSG_G_S_MENU_HELP_4,
-  MSG_G_S_MENU_HELP_5,
-  MSG_G_S_MENU_HELP_6,
-  MSG_G_S_MENU_HELP_7,
-  MSG_G_S_MENU_HELP_8,
+  MSG_EMU_MENU_TITLE,
+
+  MSG_EMU_MENU_0,
+  MSG_EMU_MENU_1,
+  MSG_EMU_MENU_2,
+  MSG_EMU_MENU_3,
+  MSG_EMU_MENU_4,
+  MSG_EMU_MENU_5,
+/*  MSG_EMU_MENU_6, */
+  MSG_EMU_MENU_7,
+  MSG_EMU_MENU_8,
+
+  MSG_EMU_MENU_HELP_0,
+  MSG_EMU_MENU_HELP_1,
+  MSG_EMU_MENU_HELP_2,
+  MSG_EMU_MENU_HELP_3,
+  MSG_EMU_MENU_HELP_4,
+  MSG_EMU_MENU_HELP_5,
+/*  MSG_EMU_MENU_HELP_6, */
+  MSG_EMU_MENU_HELP_7,
+  MSG_EMU_MENU_HELP_8,
 
   MSG_STATE_MENU_DATE_FMT_0,
   MSG_STATE_MENU_DATE_FMT_1,
@@ -101,6 +102,8 @@
   MSG_STATE_MENU_HELP_3,
   MSG_STATE_MENU_HELP_4,
 
+  MSG_PAD_MENU_TITLE,
+
   MSG_PAD_MENU_0,
   MSG_PAD_MENU_1,
   MSG_PAD_MENU_2,
@@ -163,6 +166,8 @@
   MSG_PAD_MENU_CFG_HELP_20,
   MSG_PAD_MENU_CFG_HELP_21,
 
+  MSG_A_PAD_MENU_TITLE,
+
   MSG_A_PAD_MENU_0,
   MSG_A_PAD_MENU_1,
   MSG_A_PAD_MENU_2,
@@ -175,6 +180,8 @@
   MSG_A_PAD_MENU_HELP_1,
   MSG_A_PAD_MENU_HELP_2,
 
+  MSG_CHEAT_MENU_TITLE,
+
   MSG_CHEAT_MENU_NON_LOAD,
   MSG_CHEAT_MENU_0,
   MSG_CHEAT_MENU_1,
@@ -214,18 +221,6 @@
   MSG_FS_UNIFORM,
   MSG_FS_RANDOM,
 
-  MSG_SB_2048,
-  MSG_SB_3072,
-  MSG_SB_4096,
-  MSG_SB_5120,
-  MSG_SB_6144,
-  MSG_SB_7168,
-  MSG_SB_8192,
-  MSG_SB_9216,
-  MSG_SB_10240,
-  MSG_SB_11264,
-  MSG_SB_12288,
-
   MSG_BK_EXITONLY,
   MSG_BK_AUTO,
 
@@ -244,6 +239,8 @@
   MSG_SS_FMT_1,
   MSG_SS_FMT_2,
 
+  MSG_LOADING_ROM,
+
   MSG_ERR_BIOS_1,
   MSG_ERR_BIOS_2,
   MSG_ERR_BIOS_MD5,
@@ -253,4 +250,4 @@
 
 char msg[MSG_END][512];
 
-#endif
+#endif /* MESSAGE_H */
diff -ruibwEB --strip-trailing-cr -I RE old/mips_emit.h mod/mips_emit.h
--- old/mips_emit.h	2007-08-26 00:49:55.000000000 +0900
+++ mod/mips_emit.h	2007-10-27 22:38:09.750780800 +0900
@@ -21,8 +21,11 @@
 #ifndef MIPS_EMIT_H
 #define MIPS_EMIT_H
 
+
 u32 mips_update_gba(u32 pc);
 
+static u8 cycle_multiply(u32 _rs);
+
 // Although these are defined as a function, don't call them as
 // such (jump to it instead)
 void mips_indirect_branch_arm(u32 address);
@@ -199,10 +202,10 @@
   translation_ptr += 4                                                        \
 
 #define mips_relative_offset(source, offset)                                  \
-  (((u32)offset - ((u32)source + 4)) / 4)                                     \
+  (((u32)offset - ((u32)source + 4)) >> 2)                                    \
 
 #define mips_absolute_offset(offset)                                          \
-  ((u32)offset / 4)                                                           \
+  ((u32)offset >> 2)                                                          \
 
 // ADDU rd, rs, rt
 #define mips_emit_addu(rd, rs, rt)                                            \
@@ -600,9 +603,15 @@
   {                                                                           \
     u8 i;                                                                     \
     u8 flag = 0;                                                              \
+                                                                              \
     for( i = 0; i < idle_loop_targets; i++)                                   \
+    {                                                                         \
       if(pc == idle_loop_target_pc[i])                                        \
+      {                                                                       \
         flag = 1;                                                             \
+      }                                                                       \
+    }                                                                         \
+                                                                              \
     if(flag == 1)                                                             \
     {                                                                         \
       generate_load_pc(reg_a0, new_pc);                                       \
@@ -821,12 +830,12 @@
 
 #define generate_shift_reg_lsr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_lsr_flags_reg)                    \
 
 #define generate_shift_reg_asr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_asr_flags_reg)                    \
 
 #define generate_shift_reg_ror_flags(_rm, _rs)                                \
@@ -837,7 +846,7 @@
   mips_emit_rotrv(reg_a0, arm_to_mips_reg[_rm], arm_to_mips_reg[_rs])         \
 
 #define generate_shift_imm(arm_reg, name, flags_op)                           \
-  u32 shift = (opcode >> 7) & 0x1F;                                           \
+  u32 shift = ((opcode >> 7) & 0x1F);                                         \
   generate_shift_imm_##name##_##flags_op(arm_reg, rm, shift)                  \
 
 #define generate_shift_reg(arm_reg, name, flags_op)                           \
@@ -949,26 +958,61 @@
   u32 _address = (u32)(address);                                              \
   u32 _address_hi = (_address + 0x8000) >> 16;                                \
   generate_load_imm(ireg, address);                                           \
-  mips_emit_lui(ireg, _address_hi >> 16)                                      \
+  mips_emit_lui(ireg, _address_hi >> 16);                                     \
   generate_load_memory_##type(ireg, _address - (_address_hi << 16));          \
 }                                                                             \
 
+#define generate_known_address_load_builder(type)                             \
+  u32 generate_known_address_load_##type(u32 rd, u32 address)                 \
+  {                                                                           \
+    switch(address >> 24)                                                     \
+    {                                                                         \
+      /* Read from the BIOS ROM, can be converted to an immediate load.       \
+         Only really possible to do this from the BIOS but should be okay     \
+         to allow it everywhere */                                            \
+      case 0x00:                                                              \
+        u32 imm = read_memory_constant_##type(address);                       \
+        generate_load_imm(arm_to_mips_reg[rd], imm);                          \
+        return 1;                                                             \
+                                                                              \
+      /* Read from RAM, can be converted to a load */                         \
+      case 0x02:                                                              \
+        generate_load_memory(type, arm_to_mips_reg[rd], (u8 *)ewram +         \
+         (address & 0x7FFF) + ((address & 0x38000) * 2) + 0x8000);            \
+        return 1;                                                             \
+                                                                              \
+      case 0x03:                                                              \
+        generate_load_memory(type, arm_to_mips_reg[rd], (u8 *)iwram +         \
+         (address & 0x7FFF) + 0x8000);                                        \
+        return 1;                                                             \
+                                                                              \
+      /* Read from gamepak ROM, this has to be an immediate load because      \
+         it might not actually be in memory anymore when we get to it. */     \
+      case 0x08:                                                              \
+        u32 imm = read_memory_constant_##type(address);                       \
+        generate_load_imm(arm_to_mips_reg[rd], imm);                          \
+        return 1;                                                             \
+                                                                              \
+      default:                                                                \
+        return 0;                                                             \
+    }                                                                         \
+  }                                                                           \
+
 #define generate_block_extra_vars()                                           \
   u32 stored_pc = pc;                                                         \
   u8 *update_trampoline                                                       \
 
 #define generate_block_extra_vars_arm()                                       \
   generate_block_extra_vars();                                                \
-                                                                              \
-  auto u32 generate_load_rm_sh_flags(u32 rm);                                 \
-  auto u32 generate_load_rm_sh_no_flags(u32 rm);                              \
-  auto u32 generate_load_offset_sh(u32 rm);                                   \
-  auto void generate_indirect_branch_arm();                                   \
-  auto void generate_indirect_branch_dual();                                  \
-                                                                              \
   generate_load_rm_sh_builder(flags);                                         \
   generate_load_rm_sh_builder(no_flags);                                      \
                                                                               \
+/*  generate_known_address_load_builder(u8);                                  \
+  generate_known_address_load_builder(u16);                                   \
+  generate_known_address_load_builder(u32);                                   \
+  generate_known_address_load_builder(s8);                                    \
+  generate_known_address_load_builder(s16); */                                \
+                                                                              \
   u32 generate_load_offset_sh(u32 rm)                                         \
   {                                                                           \
     switch((opcode >> 5) & 0x03)                                              \
@@ -1045,12 +1090,15 @@
     reg_mode[MODE_IRQ][6] = address + 4;
     spsr[MODE_IRQ] = reg[REG_CPSR];
     reg[REG_CPSR] = 0xD2;
-    address = 0x00000018;
     set_cpu_mode(MODE_IRQ);
+
+    address = 0x00000018;
   }
 
   if(reg[REG_CPSR] & 0x20)
+  {
     address |= 0x01;
+  }
 
   return address;
 }
@@ -1230,11 +1278,13 @@
 #define generate_op_rsb_reg(_rd, _rn, _rm)                                    \
   mips_emit_subu(_rd, _rm, _rn)                                               \
 
+/* SBC Rd = Rn - <Oprnd> - NOT(Carry) */
 #define generate_op_sbc_reg(_rd, _rn, _rm)                                    \
   mips_emit_subu(_rd, _rn, _rm);                                              \
   mips_emit_xori(reg_temp, reg_c_cache, 1);                                   \
   mips_emit_subu(_rd, _rd, reg_temp)                                          \
 
+/* RSC Rd = <Oprnd> - Rn - NOT(Carry) */
 #define generate_op_rsc_reg(_rd, _rn, _rm)                                    \
   mips_emit_subu(_rd, _rm, _rn);                                              \
   mips_emit_xori(reg_temp, reg_c_cache, 1);                                   \
@@ -1389,18 +1439,20 @@
   mips_emit_subu(_rd, _rm, _rn);                                              \
   generate_op_sub_flags_epilogue(_rd)                                         \
 
+/* SBCS Rd = Rn - <Oprnd> - NOT(Carry) */
 #define generate_op_sbcs_reg(_rd, _rn, _rm)                                   \
-  mips_emit_addu(reg_temp, _rn, reg_c_cache);                                 \
-  mips_emit_addiu(reg_temp, reg_temp, -1);                                    \
-  generate_op_sub_flags_prologue(reg_temp, _rm);                              \
-  mips_emit_subu(_rd, reg_temp, _rm);                                         \
+  mips_emit_xori(reg_temp, reg_c_cache, 1);                                   \
+  mips_emit_addu(reg_temp, _rm, reg_temp);                                    \
+  generate_op_sub_flags_prologue(_rn, reg_temp);                              \
+  mips_emit_subu(_rd, _rn, reg_temp);                                         \
   generate_op_sub_flags_epilogue(_rd)                                         \
 
+/* RSCS Rd = <Oprnd> - Rn - NOT(Carry) */
 #define generate_op_rscs_reg(_rd, _rn, _rm)                                   \
-  mips_emit_addu(reg_temp, _rm, reg_c_cache);                                 \
-  mips_emit_addiu(reg_temp, reg_temp, -1);                                    \
-  generate_op_sub_flags_prologue(reg_temp, _rn);                              \
-  mips_emit_subu(_rd, reg_temp, _rn);                                         \
+  mips_emit_xori(reg_temp, reg_c_cache, 1);                                   \
+  mips_emit_addu(reg_temp, _rn, reg_temp);                                    \
+  generate_op_sub_flags_prologue(_rm, reg_temp);                              \
+  mips_emit_subu(_rd, _rm, reg_temp);                                         \
   generate_op_sub_flags_epilogue(_rd)                                         \
 
 #define generate_op_adds_reg(_rd, _rn, _rm)                                   \
@@ -1410,7 +1462,7 @@
 
 #define generate_op_adcs_reg(_rd, _rn, _rm)                                   \
   mips_emit_addu(reg_temp, _rm, reg_c_cache);                                 \
-  generate_add_flags_prologue(_rn, _rm);                                      \
+  generate_add_flags_prologue(_rn, reg_temp);                                 \
   mips_emit_addu(_rd, _rn, reg_temp);                                         \
   generate_add_flags_epilogue(_rd)                                            \
 
@@ -1516,7 +1568,6 @@
   {                                                                           \
     rm = generate_load_rm_sh_no_flags(rm);                                    \
   }                                                                           \
-                                                                              \
   arm_op_check_##load_op();                                                   \
   generate_op_##name##_reg(arm_to_mips_reg[rd], arm_to_mips_reg[rn],          \
    arm_to_mips_reg[rm])                                                       \
@@ -1537,20 +1588,64 @@
   arm_generate_op_imm(name, load_op)                                          \
 
 
+/* 1S+x+y */
+/* x=1I cycles if Op2 shifted-by-register. y=1S+1N cycles if Rd=R15. */
+#define cycle_arm_data_proc_reg()                                             \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
+    cycle_count += 3 + cycle_arm_base(pc);                                    \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    cycle_count += 1 + cycle_arm_fetch(pc);                                   \
+  }                                                                           \
+
+#define cycle_arm_data_proc_reg_flags()                                       \
+  cycle_arm_data_proc_reg()                                                   \
+
+#define cycle_arm_data_proc_imm()                                             \
+  cycle_count += cycle_arm_base(pc);                                          \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
+    cycle_count += 2;                                                         \
+  }                                                                           \
+
+#define cycle_arm_data_proc_imm_flags()                                       \
+  cycle_arm_data_proc_imm()                                                   \
+
+/* 1S+x */
+#define cycle_arm_data_proc_test_reg()                                        \
+  cycle_count += 1 + cycle_arm_fetch(pc)                                      \
+
+#define cycle_arm_data_proc_test_reg_flags()                                  \
+  cycle_arm_data_proc_test_reg()                                              \
+
+#define cycle_arm_data_proc_test_imm()                                        \
+  cycle_count += cycle_arm_base(pc)                                           \
+
+#define cycle_arm_data_proc_test_imm_flags()                                  \
+  cycle_arm_data_proc_test_imm()                                              \
+
+/* AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, ORR, BIC  1S+x+y */
 #define arm_data_proc(name, type, flags_op)                                   \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
+/* TST, TEQ, CMP, CMN  1S+x */
 #define arm_data_proc_test(name, type)                                        \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_test_##type();                                          \
 }                                                                             \
 
+/* MOV, MVN  1S+x+y */
 #define arm_data_proc_unary(name, type, flags_op)                             \
 {                                                                             \
   arm_generate_op_##type(name, no);                                           \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
@@ -1566,9 +1662,18 @@
   mips_emit_mflo(reg_temp);                                                   \
   mips_emit_addu(arm_to_mips_reg[rd], reg_temp, arm_to_mips_reg[rn])          \
 
+/* 1S+mI */
+#define cycle_arm_multiply_add_no()                                           \
+  cycle_count += cycle_arm_fetch(pc) + cycle_multiply(rs)                     \
+
+/* 1S+mI+1I */
+#define cycle_arm_multiply_add_yes()                                          \
+  cycle_count += 1 + cycle_arm_fetch(pc) + cycle_multiply(rs)                 \
+
 #define arm_multiply(add_op, flags)                                           \
 {                                                                             \
   arm_decode_multiply();                                                      \
+  cycle_arm_multiply_add_##add_op();                                          \
   mips_emit_multu(arm_to_mips_reg[rm], arm_to_mips_reg[rs]);                  \
   arm_multiply_add_##add_op();                                                \
   arm_multiply_flags_##flags(arm_to_mips_reg[rd]);                            \
@@ -1590,9 +1695,18 @@
 #define arm_multiply_long_add_no(name)                                        \
   generate_multiply_##name()                                                  \
 
+/* 1S+mI+1I */
+#define cycle_arm_multiply_long_add_no()                                      \
+  cycle_count += 1 + cycle_arm_fetch(pc) + cycle_multiply(rs)                 \
+
+/* 1S+mI+2I */
+#define cycle_arm_multiply_long_add_yes()                                     \
+  cycle_count += 2 + cycle_arm_fetch(pc) + cycle_multiply(rs)                 \
+
 #define arm_multiply_long(name, add_op, flags)                                \
 {                                                                             \
   arm_decode_multiply_long();                                                 \
+  cycle_arm_multiply_long_add_##add_op();                                     \
   arm_multiply_long_add_##add_op(name);                                       \
   mips_emit_mflo(arm_to_mips_reg[rdlo]);                                      \
   mips_emit_mfhi(arm_to_mips_reg[rdhi]);                                      \
@@ -1639,18 +1755,64 @@
 #define arm_psr(op_type, transfer_type, psr_reg)                              \
 {                                                                             \
   arm_decode_psr_##op_type();                                                 \
+  cycle_count += cycle_arm_base(pc);                                          \
   arm_psr_##transfer_type(op_type, psr_reg);                                  \
 }                                                                             \
 
-#define arm_access_memory_load(mem_type)                                      \
+/* LDR: 1S+1N+1I. LDR PC: 2S+2N+1I. STR: 2N. */
+#define cycle_arm_access_memory_load_u32()                                    \
+  cycle_count +=                                                              \
+/*   1 + cycle_arm_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24]; */      \
+   cycle_arm_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24];           \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
   cycle_count += 2;                                                           \
+  }                                                                           \
+
+#define cycle_arm_access_memory_load_u16()                                    \
+  cycle_count +=                                                              \
+/*   1 + cycle_arm_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24]; */      \
+   cycle_arm_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24];           \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
+    cycle_count += 2;                                                         \
+  }                                                                           \
+
+#define cycle_arm_access_memory_load_s16()                                    \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_u8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_s8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_store_u32()                                   \
+  cycle_count +=                                                              \
+   cycle_arm_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24]            \
+
+#define cycle_arm_access_memory_store_u16()                                   \
+  cycle_count +=                                                              \
+   cycle_arm_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24]            \
+
+#define cycle_arm_access_memory_store_s16()                                   \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_u8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_s8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define arm_access_memory_load(mem_type)                                      \
+  cycle_arm_access_memory_load_##mem_type();                                  \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 8));                                         \
   generate_store_reg(reg_rv, rd);                                             \
   check_store_reg_pc_no_flags(rd)                                             \
 
 #define arm_access_memory_store(mem_type)                                     \
-  cycle_count++;                                                              \
+  cycle_arm_access_memory_store_##mem_type();                                 \
   generate_load_pc(reg_a2, (pc + 4));                                         \
   generate_load_reg_pc(reg_a1, rd, 12);                                       \
   generate_function_call_swap_delay(execute_store_##mem_type)                 \
@@ -1737,11 +1899,14 @@
 #define sprint_yes(access_type, pre_op, post_op, wb)                          \
   printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
 
+/* LDM, nS+1N+1I. LDM PC, (n+1)S+2N+1I. STM (n-1)S+2N. */
 #define arm_block_memory_load()                                               \
+  block_memory_waitstate(reg_a0 >> 24);                                       \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define arm_block_memory_store()                                              \
+  block_memory_waitstate(reg_a0 >> 24);                                       \
   generate_load_reg_pc(reg_a1, i, 8);                                         \
   generate_function_call_swap_delay(execute_aligned_store32)                  \
 
@@ -1756,8 +1921,10 @@
 #define arm_block_memory_adjust_pc_store()                                    \
 
 #define arm_block_memory_adjust_pc_load()                                     \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_mov(reg_a0, reg_rv);                                             \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
@@ -1775,28 +1942,34 @@
 #define arm_block_memory_sp_adjust_pc_store()                                 \
 
 #define arm_block_memory_sp_adjust_pc_load()                                  \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
 
+/* �|�X�g�f�N�������g �A�h���b�V���O */
 #define arm_block_memory_offset_down_a()                                      \
-  mips_emit_addiu(reg_a2, base_reg, (-((word_bit_count(reg_list) * 4) - 4)))  \
+  mips_emit_addiu(reg_a2, base_reg, (-((word_bit_count(reg_list) - 1) << 2))) \
 
+/* �v���f�N�������g �A�h���b�V���O */
 #define arm_block_memory_offset_down_b()                                      \
-  mips_emit_addiu(reg_a2, base_reg, (word_bit_count(reg_list) * -4))          \
+  mips_emit_addiu(reg_a2, base_reg, (-(word_bit_count(reg_list) << 2)))       \
 
+/* �|�X�g�C���N�������g �A�h���b�V���O */
 #define arm_block_memory_offset_no()                                          \
   mips_emit_addu(reg_a2, base_reg, reg_zero)                                  \
 
+/* �v���C���N�������g �A�h���b�V���O */
 #define arm_block_memory_offset_up()                                          \
   mips_emit_addiu(reg_a2, base_reg, 4)                                        \
 
 #define arm_block_memory_writeback_down()                                     \
-  mips_emit_addiu(base_reg, base_reg, (-(word_bit_count(reg_list) * 4)))      \
+  mips_emit_addiu(base_reg, base_reg, (-(word_bit_count(reg_list) << 2)))     \
 
 #define arm_block_memory_writeback_up()                                       \
-  mips_emit_addiu(base_reg, base_reg, (word_bit_count(reg_list) * 4))         \
+  mips_emit_addiu(base_reg, base_reg, (word_bit_count(reg_list) << 2))        \
 
 #define arm_block_memory_writeback_no()
 
@@ -1818,6 +1991,8 @@
   u32 offset = 0;                                                             \
   u32 base_reg = arm_to_mips_reg[rn];                                         \
                                                                               \
+  cycle_count += cycle_arm_fetch(pc);                                         \
+                                                                              \
   arm_block_memory_offset_##offset_type();                                    \
   arm_block_memory_writeback_##access_type(writeback_type);                   \
                                                                               \
@@ -1836,7 +2011,6 @@
         offset += 4;                                                          \
       }                                                                       \
     }                                                                         \
-                                                                              \
     arm_block_memory_sp_adjust_pc_##access_type();                            \
   }                                                                           \
   else                                                                        \
@@ -1847,150 +2021,8 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
-        if(reg_list & ~((2 << i) - 1))                                        \
-        {                                                                     \
-          arm_block_memory_##access_type();                                   \
-          offset += 4;                                                        \
-        }                                                                     \
-        else                                                                  \
-        {                                                                     \
-          arm_block_memory_final_##access_type();                             \
-          break;                                                              \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_adjust_pc_##access_type();                               \
-  }                                                                           \
-}                                                                             \
-
-#define arm_block_writeback_no()
-
-#define arm_block_writeback_yes()                                             \
-  mips_emit_addu(arm_to_mips_reg[rn], reg_a2, reg_zero)                       \
-
-#define arm_block_address_preadjust_up_full(wb)                               \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   ((word_bit_count(reg_list)) * 4));                                         \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_up(wb)                                    \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn], 4);                            \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down_full(wb)                             \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -((word_bit_count(reg_list)) * 4));                                        \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down(wb)                                  \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -(((word_bit_count(reg_list)) * 4) - 4));                                  \
-  arm_block_writeback_##wb()
-
-#define arm_block_address_preadjust_no(wb)                                    \
-  mips_emit_addu(reg_a2, arm_to_mips_reg[rn], reg_zero)                       \
-
-#define arm_block_address_postadjust_no()                                     \
-
-#define arm_block_address_postadjust_up()                                     \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   ((word_bit_count(reg_list)) * 4))                                          \
-
-#define arm_block_address_postadjust_down()                                   \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   -((word_bit_count(reg_list)) * 4))                                         \
-
-#define sprint_no(access_type, pre_op, post_op, wb)                           \
-
-#define sprint_yes(access_type, pre_op, post_op, wb)                          \
-  printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
-
-#define arm_block_memory_load()                                               \
-  generate_function_call_swap_delay(execute_aligned_load32);                  \
-  generate_store_reg(reg_rv, i)                                               \
-
-#define arm_block_memory_store()                                              \
-  generate_load_reg_pc(reg_a1, i, 8);                                         \
-  generate_function_call_swap_delay(execute_aligned_store32)                  \
-
-#define arm_block_memory_final_load()                                         \
-  arm_block_memory_load()                                                     \
-
-#define arm_block_memory_final_store()                                        \
-  generate_load_pc(reg_a2, (pc + 4));                                         \
-  mips_emit_jal(mips_absolute_offset(execute_store_u32));                     \
-  generate_load_reg(reg_a1, i)                                                \
-
-#define arm_block_memory_adjust_pc_store()                                    \
-
-#define arm_block_memory_adjust_pc_load()                                     \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_mov(reg_a0, reg_rv);                                             \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define arm_block_memory_sp_load()                                            \
-  mips_emit_lw(arm_to_mips_reg[i], reg_a1, offset);                           \
-
-#define arm_block_memory_sp_store()                                           \
-{                                                                             \
-  u32 store_reg = i;                                                          \
-  check_load_reg_pc(arm_reg_a0, store_reg, 8);                                \
-  mips_emit_sw(arm_to_mips_reg[store_reg], reg_a1, offset);                   \
-}                                                                             \
-
-#define arm_block_memory_sp_adjust_pc_store()                                 \
-
-#define arm_block_memory_sp_adjust_pc_load()                                  \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define old_arm_block_memory(access_type, pre_op, post_op, wb, s_bit)         \
-{                                                                             \
-  arm_decode_block_trans();                                                   \
-  u32 i;                                                                      \
-  u32 offset = 0;                                                             \
-  u32 base_reg = arm_to_mips_reg[rn];                                         \
-                                                                              \
-  arm_block_address_preadjust_##pre_op(wb);                                   \
-  arm_block_address_postadjust_##post_op();                                   \
                                                                               \
-  sprint_##s_bit(access_type, pre_op, post_op, wb);                           \
-                                                                              \
-  if((rn == REG_SP) && iwram_stack_optimize)                                  \
-  {                                                                           \
-    mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
-    generate_load_imm(reg_a0, ((u32)(iwram + 0x8000)));                       \
-    mips_emit_addu(reg_a1, reg_a1, reg_a0);                                   \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        arm_block_memory_sp_##access_type();                                  \
-        offset += 4;                                                          \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_sp_adjust_pc_##access_type();                            \
-  }                                                                           \
-  else                                                                        \
-  {                                                                           \
-    mips_emit_ins(reg_a2, reg_zero, 0, 2);                                    \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
           arm_block_memory_##access_type();                                   \
@@ -2003,23 +2035,25 @@
         }                                                                     \
       }                                                                       \
     }                                                                         \
-                                                                              \
     arm_block_memory_adjust_pc_##access_type();                               \
   }                                                                           \
-}
-
+}                                                                             \
 
 
 // This isn't really a correct implementation, may have to fix later.
 
+/* 1S+2N+1I */
 #define arm_swap(type)                                                        \
 {                                                                             \
   arm_decode_swap();                                                          \
-  cycle_count += 3;                                                           \
+/*  cycle_count += 3 + cycle_arm_fetch(pc); */                                    \
+  cycle_count +=                                                              \
+   1 + cycle_arm_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24];       \
   mips_emit_jal(mips_absolute_offset(execute_load_##type));                   \
   generate_load_reg(reg_a0, rn);                                              \
   generate_mov(reg_a2, reg_rv);                                               \
   generate_load_reg(reg_a0, rn);                                              \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                   \
   mips_emit_jal(mips_absolute_offset(execute_store_##type));                  \
   generate_load_reg(reg_a1, rm);                                              \
   generate_store_reg(reg_a2, rd);                                             \
@@ -2044,18 +2078,29 @@
 #define thumb_data_proc(type, name, rn_type, _rd, _rs, _rn)                   \
 {                                                                             \
   thumb_decode_##type();                                                      \
+  cycle_count += cycle_thumb_base(pc);                                        \
   thumb_generate_op_##rn_type(name, _rd, _rs, _rn);                           \
 }                                                                             \
 
+/* 1S+mI */
+#define thumb_data_proc_muls(type, rn_type, _rd, _rs, _rn)                    \
+{                                                                             \
+  thumb_decode_##type();                                                      \
+  cycle_count += cycle_thumb_fetch(pc) + cycle_multiply(_rs);                 \
+  thumb_generate_op_##rn_type(muls, _rd, _rs, _rn);                           \
+}                                                                             \
+
 #define thumb_data_proc_test(type, name, rn_type, _rs, _rn)                   \
 {                                                                             \
   thumb_decode_##type();                                                      \
+  cycle_count += cycle_thumb_base(pc);                                        \
   thumb_generate_op_##rn_type(name, 0, _rs, _rn);                             \
 }                                                                             \
 
 #define thumb_data_proc_unary(type, name, rn_type, _rd, _rn)                  \
 {                                                                             \
   thumb_decode_##type();                                                      \
+  cycle_count += cycle_thumb_base(pc);                                        \
   thumb_generate_op_##rn_type(name, _rd, 0, _rn);                             \
 }                                                                             \
 
@@ -2068,6 +2113,11 @@
 #define thumb_data_proc_hi(name)                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  cycle_count += cycle_thumb_base(pc);                                        \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
+    cycle_count += 2;                                                         \
+  }                                                                           \
   u32 dest_rd = rd;                                                           \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   check_load_reg_pc(arm_reg_a1, rd, 4);                                       \
@@ -2093,6 +2143,7 @@
 #define thumb_data_proc_test_hi(name)                                         \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  cycle_count += cycle_thumb_base(pc);                                        \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   check_load_reg_pc(arm_reg_a1, rd, 4);                                       \
   generate_op_##name##_reg(reg_temp, arm_to_mips_reg[rd],                     \
@@ -2102,6 +2153,11 @@
 #define thumb_data_proc_mov_hi()                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  cycle_count += cycle_thumb_base(pc);                                        \
+  if(rd == reg_pc)                                                            \
+  {                                                                           \
+    cycle_count += 2;                                                         \
+  }                                                                           \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   mips_emit_addu(arm_to_mips_reg[rd], arm_to_mips_reg[rs], reg_zero);         \
   check_store_reg_pc_thumb(rd);                                               \
@@ -2110,18 +2166,21 @@
 #define thumb_load_pc(_rd)                                                    \
 {                                                                             \
   thumb_decode_imm();                                                         \
-  generate_load_pc(arm_to_mips_reg[_rd], (((pc & ~2) + 4) + (imm * 4)));      \
+  cycle_count += cycle_thumb_base(pc);                                        \
+  generate_load_pc(arm_to_mips_reg[_rd], (((pc & ~2) + 4) + (imm << 2)));     \
 }                                                                             \
 
 #define thumb_load_sp(_rd)                                                    \
 {                                                                             \
   thumb_decode_imm();                                                         \
-  mips_emit_addiu(arm_to_mips_reg[_rd], reg_r13, (imm * 4));                  \
+  cycle_count += cycle_thumb_base(pc);                                        \
+  mips_emit_addiu(arm_to_mips_reg[_rd], reg_r13, (imm << 2));                 \
 }                                                                             \
 
 #define thumb_adjust_sp(value)                                                \
 {                                                                             \
   thumb_decode_add_sp();                                                      \
+  cycle_count += cycle_thumb_base(pc);                                        \
   mips_emit_addiu(reg_r13, reg_r13, (value));                                 \
 }                                                                             \
 
@@ -2157,8 +2216,16 @@
   mips_emit_addu(arm_to_mips_reg[original_rd], reg_a0, reg_zero);             \
 }                                                                             \
 
+#define cycle_thumb_shift_shift()                                             \
+  cycle_count += cycle_thumb_base(pc)                                         \
+
+/* ALU operations LSL,LSR,ASR,ROR  1S+1I */
+#define cycle_thumb_shift_alu_op()                                            \
+  cycle_count += 1 + cycle_thumb_fetch(pc)                                    \
+
 #define thumb_shift(decode_type, op_type, value_type)                         \
 {                                                                             \
+  cycle_thumb_shift_##decode_type();                                          \
   thumb_decode_##decode_type();                                               \
   thumb_generate_shift_##value_type(op_type);                                 \
   generate_op_logic_flags(arm_to_mips_reg[rd]);                               \
@@ -2166,14 +2233,51 @@
 
 // Operation types: imm, mem_reg, mem_imm
 
+/* LDR 1S+1N+1I, STR 2N */
+#define cycle_thumb_access_memory_load_u32()                                  \
+  cycle_count +=                                                              \
+/*   1 + cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24] */     \
+   cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24]          \
+
+#define cycle_thumb_access_memory_load_u16()                                  \
+  cycle_count +=                                                              \
+/*   1 + cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24] */     \
+   cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24]          \
+
+#define cycle_thumb_access_memory_load_s16()                                  \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_u8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_s8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_store_u32()                                 \
+  cycle_count +=                                                              \
+   cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[1][reg_a0 >> 24]          \
+
+#define cycle_thumb_access_memory_store_u16()                                 \
+  cycle_count +=                                                              \
+   cycle_thumb_fetch(pc) + waitstate_cycles_non_seq[0][reg_a0 >> 24]          \
+
+#define cycle_thumb_access_memory_store_s16()                                 \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_u8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_s8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
 #define thumb_access_memory_load(mem_type, reg_rd)                            \
-  cycle_count += 2;                                                           \
+  cycle_thumb_access_memory_load_##mem_type();                                \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 4));                                         \
   generate_store_reg(reg_rv, reg_rd)                                          \
 
 #define thumb_access_memory_store(mem_type, reg_rd)                           \
-  cycle_count++;                                                              \
+  cycle_thumb_access_memory_store_##mem_type();                               \
   generate_load_pc(reg_a2, (pc + 2));                                         \
   mips_emit_jal(mips_absolute_offset(execute_store_##mem_type));              \
   generate_load_reg(reg_a1, reg_rd)                                           \
@@ -2186,7 +2290,7 @@
   mips_emit_addiu(reg_a0, arm_to_mips_reg[reg_rb], (offset))                  \
 
 #define thumb_access_memory_generate_address_reg_imm_sp(offset, reg_rb, reg_ro)\
-  mips_emit_addiu(reg_a0, arm_to_mips_reg[reg_rb], (offset * 4))               \
+  mips_emit_addiu(reg_a0, arm_to_mips_reg[reg_rb], (offset << 2))             \
 
 #define thumb_access_memory_generate_address_reg_reg(offset, reg_rb, reg_ro)  \
   mips_emit_addu(reg_a0, arm_to_mips_reg[reg_rb], arm_to_mips_reg[reg_ro])    \
@@ -2195,55 +2299,58 @@
  address_type, offset, mem_type)                                              \
 {                                                                             \
   thumb_decode_##op_type();                                                   \
-  thumb_access_memory_generate_address_##address_type(offset, reg_rb,         \
-   reg_ro);                                                                   \
+  thumb_access_memory_generate_address_##address_type(offset, reg_rb, reg_ro);\
   thumb_access_memory_##access_type(mem_type, reg_rd);                        \
 }                                                                             \
 
 
+/* �|�X�g�C���N�������g �A�h���b�V���O STMIA, LDMIA, POP */
 #define thumb_block_address_preadjust_no(base_reg)                            \
   mips_emit_addu(reg_a2, arm_to_mips_reg[base_reg], reg_zero)                 \
 
-#define thumb_block_address_preadjust_up(base_reg)                            \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[base_reg],                          \
-   (bit_count[reg_list] * 4));                                                \
-  mips_emit_addu(arm_to_mips_reg[base_reg], reg_a2, reg_zero)                 \
-
+/* �v���f�N�������g �A�h���b�V���O PUSH rlist */
 #define thumb_block_address_preadjust_down(base_reg)                          \
   mips_emit_addiu(reg_a2, arm_to_mips_reg[base_reg],                          \
-   -(bit_count[reg_list] * 4));                                               \
+   (-(bit_count[reg_list] << 2)));                                            \
   mips_emit_addu(arm_to_mips_reg[base_reg], reg_a2, reg_zero)                 \
 
+/* �v���f�N�������g �A�h���b�V���O PUSH rlist, lr */
 #define thumb_block_address_preadjust_push_lr(base_reg)                       \
   mips_emit_addiu(reg_a2, arm_to_mips_reg[base_reg],                          \
-   -((bit_count[reg_list] + 1) * 4));                                         \
+   (-((bit_count[reg_list] + 1) << 2)));                                      \
   mips_emit_addu(arm_to_mips_reg[base_reg], reg_a2, reg_zero)                 \
 
+/* �x�[�X���W�X�^�X�V */
 #define thumb_block_address_postadjust_no(base_reg)                           \
 
 #define thumb_block_address_postadjust_up(base_reg)                           \
   mips_emit_addiu(arm_to_mips_reg[base_reg], reg_a2,                          \
-   (bit_count[reg_list] * 4))                                                 \
+   (bit_count[reg_list] << 2))                                                \
 
 #define thumb_block_address_postadjust_down(base_reg)                         \
   mips_emit_addiu(arm_to_mips_reg[base_reg], reg_a2,                          \
-   -(bit_count[reg_list] * 4))                                                \
+   (-(bit_count[reg_list] << 2)))                                             \
 
 #define thumb_block_address_postadjust_pop_pc(base_reg)                       \
   mips_emit_addiu(arm_to_mips_reg[base_reg], reg_a2,                          \
-   ((bit_count[reg_list] * 4) + 4))                                           \
+   ((bit_count[reg_list] + 1) << 2))                                          \
 
 #define thumb_block_address_postadjust_push_lr(base_reg)                      \
 
+/* nS+1N+1I for LDM, (n-1)S+2N for STM */
+/* nS+1N+1I (POP), (n+1)S+2N+1I (POP PC), (n-1)S+2N (PUSH) */
 #define thumb_block_memory_load()                                             \
+  block_memory_waitstate(reg_a0 >> 24);                                       \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define thumb_block_memory_store()                                            \
+  block_memory_waitstate(reg_a0 >> 24);                                       \
   mips_emit_jal(mips_absolute_offset(execute_aligned_store32));               \
   generate_load_reg(reg_a1, i)                                                \
 
 #define thumb_block_memory_final_load()                                       \
+  cycle_count++;                                                              \
   thumb_block_memory_load()                                                   \
 
 #define thumb_block_memory_final_store()                                      \
@@ -2273,19 +2380,25 @@
 #define thumb_block_memory_extra_down()                                       \
 
 #define thumb_block_memory_extra_push_lr()                                    \
-  mips_emit_addiu(reg_a0, reg_a2, (bit_count[reg_list] * 4));                 \
+  mips_emit_addiu(reg_a0, reg_a2, (bit_count[reg_list] << 2));                \
   mips_emit_jal(mips_absolute_offset(execute_aligned_store32));               \
   generate_load_reg(reg_a1, REG_LR)                                           \
 
 #define thumb_block_memory_extra_pop_pc()                                     \
+  cycle_count += 2;                                                           \
   mips_emit_jal(mips_absolute_offset(execute_aligned_load32));                \
-  mips_emit_addiu(reg_a0, reg_a2, (bit_count[reg_list] * 4));                 \
+  mips_emit_addiu(reg_a0, reg_a2, (bit_count[reg_list] << 2));                \
   generate_mov(reg_a0, reg_rv);                                               \
   generate_indirect_branch_cycle_update(thumb)                                \
 
 #define thumb_block_memory_sp_load()                                          \
   mips_emit_lw(arm_to_mips_reg[i], reg_a1, offset)                            \
 
+#define cycle_thumb_block_memory_sp_store()                                   \
+
+#define cycle_thumb_block_memory_sp_load()                                    \
+  cycle_count++                                                               \
+
 #define thumb_block_memory_sp_store()                                         \
   mips_emit_sw(arm_to_mips_reg[i], reg_a1, offset)                            \
 
@@ -2293,14 +2406,27 @@
 
 #define thumb_block_memory_sp_extra_up()                                      \
 
+/* PUSH rlist */
 #define thumb_block_memory_sp_extra_down()                                    \
 
+/* POP PC */
 #define thumb_block_memory_sp_extra_pop_pc()                                  \
-  mips_emit_lw(reg_a0, reg_a1, (bit_count[reg_list] * 4));                    \
+  cycle_count += 2;                                                           \
+  mips_emit_lw(reg_a0, reg_a1, (bit_count[reg_list] << 2));                   \
   generate_indirect_branch_cycle_update(thumb)                                \
 
+/* PUSH LR */
 #define thumb_block_memory_sp_extra_push_lr()                                 \
-  mips_emit_sw(reg_r14, reg_a1, (bit_count[reg_list] * 4))                    \
+  mips_emit_sw(reg_r14, reg_a1, (bit_count[reg_list] << 2))                   \
+
+#define thumb_block_memory_writeback_load(post_op, base_reg)                  \
+  if(~((reg_list >> base_reg) & 0x01))                                        \
+  {                                                                           \
+    thumb_block_address_postadjust_##post_op(base_reg);                       \
+  }                                                                           \
+
+#define thumb_block_memory_writeback_store(post_op, base_reg)                 \
+  thumb_block_address_postadjust_##post_op(base_reg)                          \
 
 #define thumb_block_memory(access_type, pre_op, post_op, base_reg)            \
 {                                                                             \
@@ -2308,8 +2434,11 @@
   u32 i;                                                                      \
   u32 offset = 0;                                                             \
                                                                               \
+  cycle_count += cycle_thumb_fetch(pc);                                       \
+                                                                              \
   thumb_block_address_preadjust_##pre_op(base_reg);                           \
-  thumb_block_address_postadjust_##post_op(base_reg);                         \
+/*  thumb_block_address_postadjust_##post_op(base_reg); */                        \
+  thumb_block_memory_writeback_##access_type(post_op, base_reg);              \
                                                                               \
   if((base_reg == REG_SP) && iwram_stack_optimize)                            \
   {                                                                           \
@@ -2326,7 +2455,7 @@
         offset += 4;                                                          \
       }                                                                       \
     }                                                                         \
-                                                                              \
+    cycle_thumb_block_memory_sp_##access_type();                              \
     thumb_block_memory_sp_extra_##post_op();                                  \
   }                                                                           \
   else                                                                        \
@@ -2337,8 +2466,8 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
+                                                                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
           thumb_block_memory_##access_type();                                 \
@@ -2351,15 +2480,14 @@
         }                                                                     \
       }                                                                       \
     }                                                                         \
-                                                                              \
     thumb_block_memory_extra_##post_op();                                     \
   }                                                                           \
-}
-
+}                                                                             \
 
 
 #define thumb_conditional_branch(condition)                                   \
 {                                                                             \
+  cycle_count += 2 + cycle_thumb_fetch(pc);                                   \
   condition_check_type condition_check;                                       \
   generate_condition_##condition();                                           \
   generate_branch_no_cycle_update(                                            \
@@ -2370,35 +2498,42 @@
 }                                                                             \
 
 #define arm_conditional_block_header()                                        \
-  generate_condition();                                                       \
+  generate_condition()                                                        \
 
 #define arm_b()                                                               \
+  cycle_count += 2 + cycle_arm_base(pc);                                      \
   generate_branch()                                                           \
 
 #define arm_bl()                                                              \
+  cycle_count += 2 + cycle_arm_base(pc);                                      \
   generate_load_pc(reg_r14, (pc + 4));                                        \
   generate_branch()                                                           \
 
 #define arm_bx()                                                              \
+  cycle_count += 2 + cycle_arm_base(pc);                                      \
   arm_decode_branchx();                                                       \
   generate_load_reg(reg_a0, rn);                                              \
   /*generate_load_pc(reg_a2, pc);*/                                           \
   generate_indirect_branch_dual()                                             \
 
 #define arm_swi()                                                             \
-  if (((opcode >> 16) &0xFF) >= 0x2B) break;                                  \
+{                                                                             \
+  cycle_count += 2 + cycle_arm_base(pc);                                      \
   generate_swi_hle_handler((opcode >> 16) & 0xFF);                            \
   generate_load_pc(reg_a0, (pc + 4));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
   generate_branch();                                                          \
+}                                                                             \
 
 #define thumb_b()                                                             \
+  cycle_count += 2 + cycle_thumb_base(pc);                                    \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
   block_exit_position++                                                       \
 
 #define thumb_bl()                                                            \
+  cycle_count += 2 + cycle_thumb_base(pc);                                    \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
@@ -2407,15 +2542,16 @@
 
 #define thumb_blh()                                                           \
 {                                                                             \
+  cycle_count += 2 + cycle_thumb_base(pc);                                    \
   thumb_decode_branch();                                                      \
-  generate_alu_imm(addiu, addu, reg_a0, reg_r14, (offset * 2));               \
+  generate_alu_imm(addiu, addu, reg_a0, reg_r14, (offset << 1));              \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
-  generate_indirect_branch_cycle_update(dual);                                \
-  break;                                                                      \
+  generate_indirect_branch_cycle_update(thumb);                               \
 }                                                                             \
 
 #define thumb_bx()                                                            \
 {                                                                             \
+  cycle_count += 2 + cycle_thumb_base(pc);                                    \
   thumb_decode_hireg_op();                                                    \
   generate_load_reg_pc(reg_a0, rs, 4);                                        \
   /*generate_load_pc(reg_a2, pc);*/                                           \
@@ -2423,7 +2559,8 @@
 }                                                                             \
 
 #define thumb_swi()                                                           \
-  if ((opcode & 0xFF) >= 0x2B) break;                                         \
+{                                                                             \
+  cycle_count += 2 + cycle_thumb_base(pc);                                    \
   generate_swi_hle_handler(opcode & 0xFF);                                    \
   generate_load_pc(reg_a0, (pc + 2));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
@@ -2431,57 +2568,59 @@
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
   block_exit_position++;                                                      \
+}                                                                             \
 
-u8 swi_hle_handle[256][2] =
-{ /* use bios , emu bios */
-  { 0x0, 0x0 },    // SWI 0:  SoftReset
-  { 0x0, 0x0 },    // SWI 1:  RegisterRAMReset
-  { 0x0, 0x0 },    // SWI 2:  Halt
-  { 0x0, 0x0 },    // SWI 3:  Stop/Sleep
-  { 0x0, 0x0 },    // SWI 4:  IntrWait
-  { 0x0, 0x0 },    // SWI 5:  VBlankIntrWait
-  { 0x1, 0x1 },    // SWI 6:  Div
-  { 0x1, 0x1 },    // SWI 7:  DivArm
-  { 0x0, 0x1 },    // SWI 8:  Sqrt
-  { 0x0, 0x0 },    // SWI 9:  ArcTan
-  { 0x0, 0x0 },    // SWI A:  ArcTan2
-  { 0x0, 0x1 },    // SWI B:  CpuSet
-  { 0x0, 0x1 },    // SWI C:  CpuFastSet
-  { 0x0, 0x0 },    // SWI D:  GetBIOSCheckSum
-  { 0x0, 0x1 },    // SWI E:  BgAffineSet
-  { 0x0, 0x1 },    // SWI F:  ObjAffineSet
-  { 0x0, 0x0 },    // SWI 10: BitUnpack
-  { 0x0, 0x0 },    // SWI 11: LZ77UnCompWram
-  { 0x0, 0x0 },    // SWI 12: LZ77UnCompVram
-  { 0x0, 0x0 },    // SWI 13: HuffUnComp
-  { 0x0, 0x0 },    // SWI 14: RLUnCompWram
-  { 0x0, 0x0 },    // SWI 15: RLUnCompVram
-  { 0x0, 0x0 },    // SWI 16: Diff8bitUnFilterWram
-  { 0x0, 0x0 },    // SWI 17: Diff8bitUnFilterVram
-  { 0x0, 0x0 },    // SWI 18: Diff16bitUnFilter
-  { 0x0, 0x0 },    // SWI 19: SoundBias
-  { 0x0, 0x0 },    // SWI 1A: SoundDriverInit
-  { 0x0, 0x0 },    // SWI 1B: SoundDriverMode
-  { 0x0, 0x0 },    // SWI 1C: SoundDriverMain
-  { 0x0, 0x0 },    // SWI 1D: SoundDriverVSync
-  { 0x0, 0x0 },    // SWI 1E: SoundChannelClear
-  { 0x0, 0x0 },    // SWI 20: SoundWhatever0
-  { 0x0, 0x0 },    // SWI 21: SoundWhatever1
-  { 0x0, 0x0 },    // SWI 22: SoundWhatever2
-  { 0x0, 0x0 },    // SWI 23: SoundWhatever3
-  { 0x0, 0x0 },    // SWI 24: SoundWhatever4
-  { 0x0, 0x0 },    // SWI 25: MultiBoot
-  { 0x0, 0x0 },    // SWI 26: HardReset
-  { 0x0, 0x0 },    // SWI 27: CustomHalt
-  { 0x0, 0x0 },    // SWI 28: SoundDriverVSyncOff
-  { 0x0, 0x0 },    // SWI 29: SoundDriverVSyncOn
-  { 0x0, 0x0 }     // SWI 2A: SoundGetJumpList
+u8 swi_hle_handle[256] =
+{
+  0x0,    // SWI 0:  SoftReset
+  0x0,    // SWI 1:  RegisterRAMReset
+  0x0,    // SWI 2:  Halt
+  0x0,    // SWI 3:  Stop/Sleep
+  0x0,    // SWI 4:  IntrWait
+  0x0,    // SWI 5:  VBlankIntrWait
+  0x1,    // SWI 6:  Div
+  0x0,    // SWI 7:  DivArm
+  0x0,    // SWI 8:  Sqrt
+  0x0,    // SWI 9:  ArcTan
+  0x0,    // SWI A:  ArcTan2
+  0x0,    // SWI B:  CpuSet
+  0x0,    // SWI C:  CpuFastSet
+  0x0,    // SWI D:  GetBIOSCheckSum
+  0x0,    // SWI E:  BgAffineSet
+  0x0,    // SWI F:  ObjAffineSet
+  0x0,    // SWI 10: BitUnpack
+  0x0,    // SWI 11: LZ77UnCompWram
+  0x0,    // SWI 12: LZ77UnCompVram
+  0x0,    // SWI 13: HuffUnComp
+  0x0,    // SWI 14: RLUnCompWram
+  0x0,    // SWI 15: RLUnCompVram
+  0x0,    // SWI 16: Diff8bitUnFilterWram
+  0x0,    // SWI 17: Diff8bitUnFilterVram
+  0x0,    // SWI 18: Diff16bitUnFilter
+  0x0,    // SWI 19: SoundBias
+  0x0,    // SWI 1A: SoundDriverInit
+  0x0,    // SWI 1B: SoundDriverMode
+  0x0,    // SWI 1C: SoundDriverMain
+  0x0,    // SWI 1D: SoundDriverVSync
+  0x0,    // SWI 1E: SoundChannelClear
+  0x0,    // SWI 1F: MidiKey2Freq
+  0x0,    // SWI 20: SoundWhatever0
+  0x0,    // SWI 21: SoundWhatever1
+  0x0,    // SWI 22: SoundWhatever2
+  0x0,    // SWI 23: SoundWhatever3
+  0x0,    // SWI 24: SoundWhatever4
+  0x0,    // SWI 25: MultiBoot
+  0x0,    // SWI 26: HardReset
+  0x0,    // SWI 27: CustomHalt
+  0x0,    // SWI 28: SoundDriverVSyncOff
+  0x0,    // SWI 29: SoundDriverVSyncOn
+  0x0     // SWI 2A: SoundGetJumpList
 };
 
 #define generate_swi_hle_handler(_swi_number)                                 \
 {                                                                             \
   u32 swi_number = _swi_number;                                               \
-  if(swi_hle_handle[swi_number][bios_mode])                                   \
+  if(swi_hle_handle[swi_number])                                              \
   {                                                                           \
     /* Div */                                                                 \
     if(swi_number == 0x06)                                                    \
@@ -2493,66 +2632,6 @@
       mips_emit_xor(reg_r3, reg_r0, reg_a0);                                  \
       mips_emit_subu(reg_r3, reg_r3, reg_a0);                                 \
     }                                                                         \
-                                                                              \
-    /* Divarm */                                                              \
-    if(swi_number == 0x07)                                                    \
-    {                                                                         \
-      mips_emit_addu(reg_r3, reg_r0,reg_zero);                                \
-      mips_emit_addu(reg_r0, reg_r1,reg_zero);                                \
-      mips_emit_addu(reg_r1, reg_r3,reg_zero);                                \
-      mips_emit_div(reg_r0, reg_r1);                                          \
-      mips_emit_mflo(reg_r0);                                                 \
-      mips_emit_mfhi(reg_r1);                                                 \
-      mips_emit_sra(reg_a0, reg_r0, 31);                                      \
-      mips_emit_xor(reg_r3, reg_r0, reg_a0);                                  \
-      mips_emit_subu(reg_r3, reg_r3, reg_a0);                                 \
-    }                                                                         \
-                                                                              \
-    /* Sqrt */                                                                \
-    if(swi_number == 0x08)                                                    \
-    {                                                                         \
-      mips_emit_addu(reg_a0, reg_r0, reg_zero);                               \
-      generate_function_call(bios_sqrt);                                      \
-      mips_emit_addu(reg_r0, reg_rv, reg_zero);                               \
-    }                                                                         \
-                                                                              \
-    /* CpuSet */                                                              \
-    if(swi_number == 0x0B)                                                    \
-    {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                          \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                          \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                          \
-      generate_function_call(bios_cpuset);                                    \
-    }                                                                         \
-                                                                              \
-    /* CpuFastSet */                                                          \
-    if(swi_number == 0x0C)                                                    \
-    {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
-      generate_function_call(bios_cpufastset);                                \
-    }                                                                         \
-                                                                              \
-    /* BgAffineSet */                                                         \
-    if(swi_number == 0x0E)                                                    \
-    {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
-      generate_function_call(bios_bgaffineset);                               \
-    }                                                                         \
-                                                                              \
-    /* ObjAffineSet */                                                        \
-    if(swi_number == 0x0F)                                                    \
-    {                                                                         \
-      mips_emit_addu(mips_reg_a0, reg_r0, reg_zero);                               \
-      mips_emit_addu(mips_reg_a1, reg_r1, reg_zero);                               \
-      mips_emit_addu(mips_reg_a2, reg_r2, reg_zero);                               \
-      mips_emit_addu(mips_reg_a3, reg_r3, reg_zero);                          \
-      generate_function_call(bios_objaffineset);                              \
-    }                                                                         \
-                                                                              \
     break;                                                                    \
   }                                                                           \
 }                                                                             \
@@ -2563,6 +2642,55 @@
 
 #define generate_update_pc_reg()                                              \
   generate_load_pc(reg_a0, pc);                                               \
-  mips_emit_sw(reg_a0, reg_base, (REG_PC * 4))                                \
+  mips_emit_sw(reg_a0, reg_base, (REG_PC << 2))                               \
+
+
+#define cycle_arm_base(_address)                                              \
+  waitstate_cycles_seq[1][_address >> 24]                                     \
+
+#define cycle_thumb_base(_address)                                            \
+  waitstate_cycles_seq[0][_address >> 24]                                     \
+
+#define cycle_arm_fetch(_address)                                             \
+  waitstate_cycles_fetch[1][_address >> 24]                                   \
+
+#define cycle_thumb_fetch(_address)                                           \
+  waitstate_cycles_fetch[0][_address >> 24]                                   \
+
+#define block_memory_waitstate(mem_region)                                    \
+  if(offset == 0 ||                                                           \
+    (mem_region >= 0x08 && mem_region <= 0x0D && (reg_a0 % 0x20000) == 0))    \
+/*  if(offset == 0) */                                                            \
+  {                                                                           \
+    cycle_count += waitstate_cycles_non_seq[1][mem_region];                   \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    cycle_count += waitstate_cycles_seq[1][mem_region];                       \
+  }                                                                           \
+
+static u8 cycle_multiply(u32 _rs)
+{
+  u32 mult_rs = arm_to_mips_reg[_rs];
+
+  if(((s32)mult_rs) < 0)
+    mult_rs = ~mult_rs;
+
+  /* m=1 for Bit 31-8 */
+  if((mult_rs & 0xFFFFFF00) == 0)
+    return 1;
+  else
+  /* m=2 for Bit 31-16 */
+  if((mult_rs & 0xFFFF0000) == 0)
+    return 2;
+  else
+  /* m=3 for Bit 31-24 */
+  if((mult_rs & 0xFF000000) == 0)
+    return 3;
+  else
+  /* m=4 otherwise */
+    return 4;
+}
+
 
-#endif
+#endif /* MIPS_EMIT_H */
diff -ruibwEB --strip-trailing-cr -I RE old/mips_stub.S mod/mips_stub.S
--- old/mips_stub.S	2007-08-26 00:49:55.000000000 +0900
+++ mod/mips_stub.S	2007-10-27 22:43:06.167006400 +0900
@@ -132,10 +132,10 @@
 .endm
 
 .macro collapse_flags
-  lw $2, REG_CPSR($16)            # $2 = [$16 + REG_CPSR]		# load CPSR
-  andi $2, $2, 0xFF               # $2 = $2 and 0xFF			# isolate lower 8bits
-  collapse_flag 20, 31            # # store flags
-  collapse_flag 21, 30            #
+  lw $2, REG_CPSR($16)            # load CPSR
+  andi $2, $2, 0xFF               # isolate lower 8bits
+  collapse_flag 20, 31            # store flags
+  collapse_flag 21, 30
   collapse_flag 22, 29
   collapse_flag 23, 28
   sw $2, REG_CPSR($16)            # store CPSR
@@ -268,29 +268,24 @@
 .macro patch_handler ftable, force_open
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
   addiu $1, $0, (\force_open * 4)
 
 1:
   lui $2, %hi(\ftable)
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
-  srl $2, $2, 2                   # remove lower two bits
 
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -303,10 +298,9 @@
 .macro patch_handler_align ftable, alignment
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
-  addiu $1, $0, 4                 # force address to 0x1 (open)
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
+  addiu $1, $0, 4                 # force address to 0x1 (open) delay slot
 
 1:
   ins $1, $4, 6, \alignment       # place alignment bits into offset
@@ -315,20 +308,15 @@
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
 
-  srl $2, $2, 2                   # remove lower two bits
-
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -449,53 +437,51 @@
 
 
 .macro translate_region_vram_core
-  addiu $2, $2, -3                # see if it's 3
   ext $4, $4, 0, 17               # generate 17bit offset
-  bne $2, $0, 1f                  # if $2 != $0 then j 1:
-  lui $1, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $2, $0, 1f                 # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 1:
+  lui $1, %hi(vram)               # start loading vram address
   addu $2, $1, $4                 # $2 = (hi)vram + address
 .endm
 
 .macro translate_region_vram patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align16 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align32 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align16 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align32 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
@@ -506,7 +492,7 @@
   srl $2, $4, 15                  # $2 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $2 = memory_map_read[address >> 15]
-  lw $2, -32768($2)               # 
+  lw $2, -32768($2)
   bne $2, $0, 1f                  # if it's non-NULL continue
   andi $1, $4, \mask              # $1 = low 15bits of address (delay slot)
 
@@ -586,7 +570,7 @@
   save_registers                  # save the registers
 
   jal read_eeprom                 # get eeprom value in $2
-  nop
+  sw $6, REG_SAVE2($16)           # save a2 (delay)
 
   restore_registers               # restore the other registers
 
@@ -634,7 +618,7 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  andi $4, $4, 0xFFFF             # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
@@ -650,7 +634,7 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  andi $4, $4, 0xFFFF             # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
@@ -688,15 +672,19 @@
 
 
 .macro open_load8_core
-  lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
+  srl $2, $4, 29
+  bnel $2, $0, 2f                 # if(address > 0x1FFFFFFF)
+  addu $2, $0, $0                 # value = 0 (delay)
+
+  lw $2, REG_CPSR($16)            # $2 = CPSR
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x03               # isolate lower 3bits from address (delay)
+  andi $4, $4, 0x03               # in ARM mode, isolate lower 2bits from address
 
-  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory8                # get instruction at PC
@@ -705,6 +693,8 @@
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
+
+2:
   jr $ra                          # return
 .endm
 
@@ -716,15 +706,19 @@
 
 
 .macro open_load16_core
-  lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
+  srl $2, $4, 29
+  bnel $2, $0, 2f                 # if(address > 0x1FFFFFFF)
+  addu $2, $0, $0                 # value = 0 (delay)
+
+  lw $2, REG_CPSR($16)            # $2 = CPSR
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x02               # isolate bit 1 from address (delay)
+  andi $4, $4, 0x02               # in ARM mode, isolate bit 1 from address
 
-  addu $4, $0, $0                 # zero out address bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  addu $4, $0, $0                 # in Thumb mode, zero out address bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory16               # get instruction at PC
@@ -733,6 +727,8 @@
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
+
+2:
   jr $ra                          # return
 .endm
 
@@ -748,7 +744,11 @@
 
 
 .macro open_load32_core
-  lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
+  srl $2, $4, 29
+  bnel $2, $0, 3f                 # if(address > 0x1FFFFFFF)
+  addu $2, $0, $0                 # value = 0 (delay)
+
+  lw $2, REG_CPSR($16)            # $2 = CPSR
   andi $2, $2, 0x20               # test T bit
 
   save_registers                  # save the registers
@@ -757,26 +757,32 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:                                # join point
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
+
+3:
   jr $ra                          # return
 .endm
 
 .macro open_load32_a patch_handler
   region_check_open \patch_handler
 
-  lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
+  srl $2, $4, 28
+  bnel $2, $0, 3f                 # if(address > 0x0FFFFFFF)
+  addu $2, $0, $0                 # value = 0 (delay)
+
+  lw $2, REG_CPSR($16)            # $2 = CPSR
   andi $2, $2, 0x20               # test T bit
 
   save_registers                  # save the registers
@@ -786,14 +792,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:
   restore_registers               # restore the other registers
@@ -801,6 +807,10 @@
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
   lw $6, REG_SAVE2($16)           # restore a2 (delay)
+
+3:
+  jr $ra
+  nop
 .endm
 
 .macro open_load32_align align_bits, alignment, patch_handler
@@ -820,7 +830,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -837,7 +847,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -961,9 +971,9 @@
 
 execute_load_bios_u8:
   region_check 0, patch_load_u8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -994,9 +1003,18 @@
   load_u8 (iwram + 0x8000)
 
 execute_load_io_u8:
-  translate_region 4, patch_load_u8, io_registers, 0xFFF
+  region_check 4, patch_load_u8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u8 io_registers
 
+1:
+  open_load8_core
+  nop
+
 execute_load_palette_u8:
   translate_region 5, patch_load_u8, palette_ram, 0x3FF
   load_u8 palette_ram
@@ -1067,9 +1085,9 @@
 
 execute_load_bios_s8:
   region_check 0, patch_load_s8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1097,9 +1115,18 @@
   load_s8 (iwram + 0x8000)
 
 execute_load_io_s8:
-  translate_region 4, patch_load_s8, io_registers, 0xFFF
+  region_check 4, patch_load_s8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s8 io_registers
 
+1:
+  open_load8_core
+  seb $2, $2
+
 execute_load_palette_s8:
   translate_region 5, patch_load_s8, palette_ram, 0x3FF
   load_s8 palette_ram
@@ -1170,9 +1197,9 @@
 
 execute_load_bios_u16:
   region_check_align 0, 1, 0, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1199,9 +1226,18 @@
   load_u16 (iwram + 0x8000)
 
 execute_load_io_u16:
-  translate_region_align 4, 1, 0, patch_load_u16, io_registers, 0xFFF
+  region_check_align 4, 1, 0 patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16 io_registers
 
+1:
+  open_load16_core
+  nop
+
 execute_load_palette_u16:
   translate_region_align 5, 1, 0, patch_load_u16, palette_ram, 0x3FF
   load_u16 palette_ram
@@ -1250,9 +1286,9 @@
 
 execute_load_bios_u16u:
   region_check_align 0, 1, 1, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1280,9 +1316,18 @@
   load_u16_unaligned (iwram + 0x8000)
 
 execute_load_io_u16u:
-  translate_region_align 4, 1, 1, patch_load_u16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16_unaligned io_registers
 
+1:
+  open_load16_core
+  ror $2, $2, 8
+
 execute_load_palette_u16u:
   translate_region_align 5, 1, 1, patch_load_u16, palette_ram, 0x3FE
   load_u16_unaligned palette_ram
@@ -1327,7 +1372,6 @@
   ror $2, $2, 8                   # rotate value by 8bits
 
 load_u16_ftable:
-#  .long execute_load_full_u16
   .long execute_load_bios_u16     # 0x00 BIOS
   .long execute_load_open_u16     # 0x01 open address
   .long execute_load_ewram_u16    # 0x02 EWRAM
@@ -1363,41 +1407,6 @@
   .long execute_load_open_u16u    # 0x0F open unaligned
 
 
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-  .long execute_load_full_u16
-
-
-
 patch_load_u16:
   patch_handler_align load_u16_ftable, 1
 
@@ -1405,9 +1414,9 @@
 
 execute_load_bios_s16:
   region_check_align 0, 1, 0, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1417,7 +1426,7 @@
 
 1:
   lui $2, %hi(bios_read_protect)  # generate upper address
-  ins $2, $4, 0, 2                # bit 1 contributes
+  ins $2, $4, 0, 2                # bit 2 contributes
   load_s16 bios_read_protect
 
 2:
@@ -1435,9 +1443,18 @@
   load_s16 (iwram + 0x8000)
 
 execute_load_io_s16:
-  translate_region_align 4, 1, 0, patch_load_s16, io_registers, 0xFFF
+  region_check_align 4, 1, 0, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16 io_registers
 
+1:
+  open_load16_core
+  seh $2, $2
+
 execute_load_palette_s16:
   translate_region_align 5, 1, 0, patch_load_s16, palette_ram, 0x3FF
   load_s16 palette_ram
@@ -1486,68 +1503,76 @@
 
 execute_load_bios_s16u:
   region_check_align 0, 1, 1, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
-  andi $4, $4, 0x3FFE             # generate offset
+  andi $4, $4, 0x3FFF             # generate offset
   addu $2, $2, $4
   load_s16_unaligned bios_rom
 
 1:
   lui $2, %hi(bios_read_protect)  # generate upper address
-  ext $1, $4, 1, 1
-  ins $2, $1, 1, 1                # bit 1 contributes
+  ins $2, $4, 0, 2                # bit 2 contributes
   load_s16_unaligned bios_read_protect
 
 2:
-  open_load16_core
+  open_load8_core
   seb $2, $2
 
 execute_load_ewram_s16u:
-  translate_region_ewram_load_align16 1, 1, patch_load_s16
+  translate_region_ewram_load_align 1, 1, patch_load_s16
   load_s16_unaligned (ewram + 0x8000)
 
 execute_load_iwram_s16u:
-  translate_region_align 3, 1, 1, patch_load_s16, (iwram + 0x8000), 0x7FFE
+  translate_region_align 3, 1, 1, patch_load_s16, (iwram + 0x8000), 0x7FFF
   load_s16_unaligned (iwram + 0x8000)
 
 execute_load_io_s16u:
-  translate_region_align 4, 1, 1, patch_load_s16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16_unaligned io_registers
 
+1:
+  open_load8_core
+  seb $2, $2
+
 execute_load_palette_s16u:
-  translate_region_align 5, 1, 1, patch_load_s16, palette_ram, 0x3FE
+  translate_region_align 5, 1, 1, patch_load_s16, palette_ram, 0x3FF
   load_s16_unaligned palette_ram
 
 execute_load_vram_s16u:
-  translate_region_vram_load_align16 1, 1, patch_load_s16
+  translate_region_vram_load_align 1, 1, patch_load_s16
   load_s16_unaligned vram
 
 execute_load_oam_s16u:
-  translate_region_align 7, 1, 1, patch_load_s16, oam_ram, 0x3FE
+  translate_region_align 7, 1, 1, patch_load_s16, oam_ram, 0x3FF
   load_s16_unaligned oam_ram
 
 execute_load_gamepak8_s16u:
-  translate_region_gamepak_align16 8, 1, 1, patch_load_s16
+  translate_region_gamepak_align 8, 1, 1, patch_load_s16
   load_s16_unaligned 0
 
 execute_load_gamepak9_s16u:
-  translate_region_gamepak_align16 9, 1, 1, patch_load_s16
+  translate_region_gamepak_align 9, 1, 1, patch_load_s16
   load_s16_unaligned 0
 
 execute_load_gamepakA_s16u:
-  translate_region_gamepak_align16 10, 1, 1, patch_load_s16
+  translate_region_gamepak_align 10, 1, 1, patch_load_s16
   load_s16_unaligned 0
 
 execute_load_gamepakB_s16u:
-  translate_region_gamepak_align16 11, 1, 1, patch_load_s16
+  translate_region_gamepak_align 11, 1, 1, patch_load_s16
   load_s16_unaligned 0
 
 execute_load_gamepakC_s16u:
-  translate_region_gamepak_align16 12, 1, 1, patch_load_s16
+  translate_region_gamepak_align 12, 1, 1, patch_load_s16
   load_s16_unaligned 0
 
 execute_load_eeprom_s16u:
@@ -1558,7 +1583,8 @@
   seb $2, $2                      # sign extend result from 8bits
 
 execute_load_open_s16u:
-  open_load16_align 1, 1, patch_load_s16
+  region_check_open_align 1, 1, patch_load_s16
+  open_load8_core
   seb $2, $2                      # sign extend result from 8bits
 
 load_s16_ftable:
@@ -1605,9 +1631,9 @@
 
 execute_load_bios_u32:
   region_check_align 0, 2, 0, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1634,9 +1660,18 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32:
-  translate_region_align 4, 2, 0, patch_load_u32, io_registers, 0xFFF
+  region_check_align 4, 2, 0, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_core
+  nop
+
 execute_load_palette_u32:
   translate_region_align 5, 2, 0, patch_load_u32, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -1685,9 +1720,9 @@
 
 execute_load_bios_u32u1:
   region_check_align 0, 2, 1, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1712,9 +1747,18 @@
   load_u32_unaligned (iwram + 0x8000), 1
 
 execute_load_io_u32u1:
-  translate_region_align 4, 2, 1, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 1, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 1
 
+1:
+  open_load32_core
+  ror $2, $2, 8
+
 execute_load_palette_u32u1:
   translate_region_align 5, 2, 1, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 1
@@ -1763,9 +1807,9 @@
 
 execute_load_bios_u32u2:
   region_check_align 0, 2, 2, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1790,9 +1834,18 @@
   load_u32_unaligned (iwram + 0x8000), 2
 
 execute_load_io_u32u2:
-  translate_region_align 4, 2, 2, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 2, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 2
 
+1:
+  open_load32_core
+  ror $2, $2, 16
+
 execute_load_palette_u32u2:
   translate_region_align 5, 2, 2, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 2
@@ -1840,9 +1893,9 @@
 
 execute_load_bios_u32u3:
   region_check_align 0, 2, 3, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1867,9 +1920,18 @@
   load_u32_unaligned (iwram + 0x8000), 3
 
 execute_load_io_u32u3:
-  translate_region_align 4, 2, 3, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 3, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 3
 
+1:
+  open_load32_core
+  ror $2, $2, 24
+
 execute_load_palette_u32u3:
   translate_region_align 5, 2, 3, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 3
@@ -1992,9 +2054,9 @@
 
 execute_load_bios_u32a:
   region_check 0, patch_load_u32a
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -2008,7 +2070,6 @@
 
 2:
   open_load32_a
-  nop
 
 execute_load_ewram_u32a:
   translate_region_ewram patch_load_u32a
@@ -2020,9 +2081,17 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32a:
-  translate_region 4, patch_load_u32a, io_registers, 0xFFF
+  region_check 4, patch_load_u32a
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_a
+
 execute_load_palette_u32a:
   translate_region 5, patch_load_u32a, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -2060,7 +2129,6 @@
 
 execute_load_backup_u32a:
   backup_load_a patch_load_u32a
-  nop
 
 execute_load_open_u32a:
   open_load32_a patch_load_u32a
@@ -2106,8 +2174,11 @@
 
 execute_store_io_u8:
   region_check 4, patch_store_u8
-  andi $5, $5, 0xFF               # make value 8bit
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $5, $5, 0xFF               # make value 8bit (delay)
   andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
@@ -2118,29 +2190,37 @@
   nop
 
 execute_store_palette_u8:
-  region_check 5, patch_store_u8
-  lui $2, %hi(palette_ram)        # start loading palette_ram address (delay)
-  ins $5, $5, 8, 8                # double value
-  andi $4, $4, 0x3FE              # align palette address
-  addu $2, $2, $4
-  sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-  lui $2, %hi(palette_ram_converted)
-  addu $2, $2, $4
-  jr $ra                          # return
-  sh $1, %lo(palette_ram_converted)($2)
+  translate_region 5, patch_store_u8, palette_ram, 0x3FE
+  store_u8_double palette_ram
 
 execute_store_vram_u8:
-  translate_region_vram_store_align16 patch_store_u8
+  region_check 6, patch_store_u8
+  lui $2, %hi(io_registers)
+  addu $2, $2, $0                 # REG_DISPCNT = 0x00
+  lhu $1, %lo(io_registers)($2)   # $1 = io_registers[REG_DISPCNT]
+
+  lui $2, %hi(obj_address)
+  andi $1, $1, 0x07               # $1 = BG Mode
+  sll $1, $1, 2                   # adjust to word offset
+  addu $2, $2, $1
+  lw $2, %lo(obj_address)($2)     # $2 = OBJ Tile address
+
+  ext $4, $4, 0, 17               # address = adress & 0x1FFFF
+  sltu $1, $4, $2                 # if(address < OBJ Tile address) $1 = 1
+  beq $1, $0, ext_store_ignore
+
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
+  ins $4, $0, 0, 1                # mask out lower bit of address
+  bnel $2, $0, 1f                 # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
+
+1:
+  lui $1, %hi(vram)               # start loading vram address
+  addu $2, $1, $4                 # $2 = (hi)vram + address
   store_u8_double vram
 
 execute_store_oam_u8:
-  translate_region 7, patch_store_u8, oam_ram, 0x3FE
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  store_u8_double oam_ram
+  ignore_region 7, patch_store_u8 # Write byte datas are ignore
 
 execute_store_ignore8_u8:
   ignore_region 8, patch_store_u8
@@ -2207,8 +2287,11 @@
 
 execute_store_io_u16:
   region_check 4, patch_store_u16
-  andi $5, $5, 0xFFFF             # make value 16bit
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $5, $5, 0xFFFF             # make value 16bit (delay)
   andi $4, $4, 0x3FE              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
@@ -2219,18 +2303,8 @@
   nop
 
 execute_store_palette_u16:
-  region_check 5, patch_store_u16
-  lui $2, %hi(palette_ram)        # start loading palette_ram address (delay)
-  andi $4, $4, 0x3FE              # wrap/align palette address
-  addu $2, $2, $4
-  sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-  lui $2, %hi(palette_ram_converted)
-  addu $2, $2, $4
-  jr $ra                          # return
-  sh $1, %lo(palette_ram_converted)($2)
+  translate_region 5, patch_store_u16, palette_ram, 0x3FE
+  store_u16 palette_ram
 
 execute_store_vram_u16:
   translate_region_vram_store_align16 patch_store_u16
@@ -2238,7 +2312,7 @@
 
 execute_store_oam_u16:
   translate_region 7, patch_store_u16, oam_ram, 0x3FE
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
+  lui $1, %hi(oam_update)         # write non-zero to oam_update (delay)
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
   store_u16 oam_ram
 
@@ -2310,8 +2382,10 @@
 
 execute_store_io_u32:
   region_check 4, patch_store_u32
-  nop
-  andi $4, $4, 0x3FC              # wrap around/align address
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $4, $4, 0x3FC              # wrap around/align address (delay)
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
@@ -2322,27 +2397,8 @@
   nop
 
 execute_store_palette_u32:
-  region_check 5, patch_store_u32
-  lui $2, %hi(palette_ram)        # start loading palette_ram address (delay)
-  andi $4, $4, 0x3FC              # wrap/align palette address
-  addu $2, $2, $4
-  sw $5, %lo(palette_ram)($2)     # palette_ram[address] = value
-
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-  lui $2, %hi(palette_ram_converted)
-  addu $2, $2, $4
-  addiu $2, $2, %lo(palette_ram_converted)
-  sh $1, ($2)
-
-  srl $5, $5, 16                  # shift down to next palette value
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-
-  jr $ra                          # return
-  sh $1, 2($2)
+  translate_region 5, patch_store_u32, palette_ram, 0x3FC
+  store_u32 palette_ram
 
 execute_store_vram_u32:
   translate_region_vram_store_align32 patch_store_u32
@@ -2421,15 +2477,14 @@
 
 execute_store_io_u32a:
   region_check 4, patch_store_u32a
-  nop
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  sw $ra, REG_SAVE2($16)          # save ra (delay)
   sw $6, REG_SAVE($16)            # save a2
-  sw $ra, REG_SAVE2($16)          # save ra
-
-  andi $4, $4, 0x3FC              # wrap around/align address
 
   save_registers
   jal write_io_register32         # write the value out
-  nop
+  andi $4, $4, 0x3FC              # wrap around/align address (delay)
 
   restore_registers
 
@@ -2435,30 +2490,11 @@
 
   lw $ra, REG_SAVE2($16)          # restore ra
   jr $ra
-  lw $6, REG_SAVE($16)            # restore a2
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 execute_store_palette_u32a:
-  region_check 5, patch_store_u32a
-  lui $2, %hi(palette_ram)        # start loading palette_ram address (delay)
-  andi $4, $4, 0x3FC              # wrap/align palette address
-  addu $2, $2, $4
-  sw $5, %lo(palette_ram)($2)     # palette_ram[address] = value
-
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-  lui $2, %hi(palette_ram_converted)
-  addu $2, $2, $4
-  addiu $2, $2, %lo(palette_ram_converted)
-  sh $1, ($2)
-
-  srl $5, $5, 16                  # shift down to next palette value
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-
-  jr $ra                          # return
-  sh $1, 2($2)
+  translate_region 5, patch_store_u32a, palette_ram, 0x3FC
+  store_u32 palette_ram
 
 execute_store_vram_u32a:
   translate_region_vram_store_align32 patch_store_u32a
@@ -2521,7 +2557,7 @@
 execute_load_full_u8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_u8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2546,7 +2584,7 @@
 execute_load_full_s8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_s8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2573,7 +2611,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_u16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2581,7 +2619,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lhu $2, ($1)                    # read the value
+  lhu $2, ($1)                    # read the value (delay)
 
 ext_load_u16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2599,7 +2637,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_s16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2607,7 +2645,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lh $2, ($1)                     # read the value
+  lh $2, ($1)                     # read the value (delay)
 
 ext_load_s16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2626,7 +2664,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 2                # or unaligned (bottom two bits)
   bne $1, $0, ext_load_u32        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2634,7 +2672,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_load_u32:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2650,7 +2688,7 @@
 #execute_aligned_load32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_load32  # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($1)
@@ -2658,7 +2696,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_aligned_load32:
   addiu $sp, $sp, -8              # make room on the stack for $ra
@@ -2681,40 +2719,27 @@
 
 write_io_epilogue:
   beq $2, $0, no_alert            # 0 means nothing happened
-  addiu $4, $2, -2                # see if return value is 2 (delay slot)
-  beq $4, $0, smc_dma             # is it an SMC alert? (return value = 2)
-  nop
-  addiu $4, $2, -3                # see if return value is 3
-  beq $4, $0, irq_alert           # is it an IRQ alert? (return value = 3)
+  andi $4, $2, 0x01               # see if return value is bit0 enable (delay slot)
+  bne $4, $0, smc_dma             # is it an SMC alert? (return value = bit0 'H')
+  addiu $sp, $sp, 4               # fix the stack (delay)
+  andi $4, $2, 0x02               # see if return value is bit1 enable
+  bne $4, $0, lookup_pc           # is it an IRQ alert? (return value = bit1 'H')
   nop
+                                  # halt mode (return value = bit 2 'H')
   collapse_flags                  # make sure flags are good for update_gba
-
-alert_loop:
   jal update_gba                  # process the next event
   nop
-  lw $1, CPU_HALT_STATE($16)      # check if CPU is sleeping
-  bne $1, $0, alert_loop          # see if it hasn't changed
-  nop
-
-  addu $17, $2, $0                # $17 = new cycle counter
-  lw $4, REG_PC($16)              # $4 = new PC
-
-  j lookup_pc
-  addiu $sp, $sp, 4               # fix the stack (delay slot)
 
-irq_alert:
-  restore_registers
   j lookup_pc                     # PC has changed, get a new one
-  addiu $sp, $sp, 4               # fix the stack
+  addu $17, $2, $0                # $17 = new cycle counter (delay)
 
 no_alert:
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 smc_dma:
-  addiu $sp, $sp, 4               # fix the stack
   jal flush_translation_cache_ram # flush translation cache
   nop
   j lookup_pc
@@ -2730,16 +2757,20 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 # 8bit ext memory routines
 
 ext_store_io8:
-  andi $5, $5, 0xFF               # make value 8bit
-  andi $4, $4, 0xFFF              # wrap around address
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $5, $5, 0xFF               # make value 8bit (delay)
+  andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register8          # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
@@ -2747,34 +2779,40 @@
   nop
 
 ext_store_palette8:
-  j ext_store_palette16b          # perform 16bit palette write
-  andi $4, $4, 0x3FE              # wrap + align (delay)
+  ins $5, $5, 8, 8                # value = (value << 8) | value
+  andi $4, $4, 0x3FE              # wrap + align
+
+  lui $2, %hi(palette_ram)
+  addu $2, $2, $4
+  jr $ra                          # return
+  sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value (delay)
 
 ext_store_vram8:
-  ins $5, $5, 8, 8                # value = (value << 8) | value
+  lui $2, %hi(io_registers)
+  addu $2, $2, $0                 # REG_DISPCNT = 0x00
+  lhu $1, %lo(io_registers)($2)   # $1 = io_registers[REG_DISPCNT]
+
+  lui $2, %hi(obj_address)
+  andi $1, $1, 0x07               # $1 = BG Mode
+  sll $1, $1, 2                   # adjust to word offset
+  addu $2, $2, $1
+  lw $2, %lo(obj_address)($2)     # $2 = OBJ Tile address
+
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  ins $4, $0, 0, 1                # align out bottom bit
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # if $4 >= $1 then $1 = 0 else $1 = 1
-  bne $1, $0, ext_store_vram8b    # if $1 != 0 then j ext_store_vram8b
-  lui $2, %hi(vram)               # start loading vram address (delay)
+  sltu $1, $4, $2                 # if(address < OBJ Tile address) $1 = 1
+  beq $1, $0, ext_store_ignore
 
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
+  ins $4, $0, 0, 1                # align out bottom bit
+  bnel $2, $0, ext_store_vram8b   # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram8b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
-  jr $ra                          # return
-  sh $5, %lo(vram)($2)            # vram[address] = value (delay)
-
-ext_store_oam8:
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  andi $4, $4, 0x3FE              # wrap around address and align to 16bits
   ins $5, $5, 8, 8                # value = (value << 8) | value
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
   jr $ra                          # return
-  sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  sh $5, %lo(vram)($2)            # vram[address] = value (delay)
 
 ext_store_backup:
   andi $5, $5, 0xFF               # make value 8bit
@@ -2787,7 +2828,7 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u8_jtable:
   .long ext_store_ignore  # 0x00 BIOS
@@ -2797,7 +2838,7 @@
   .long ext_store_io8       # 0x04 I/O registers
   .long ext_store_palette8  # 0x05 Palette RAM
   .long ext_store_vram8     # 0x06 VRAM
-  .long ext_store_oam8      # 0x07 OAM RAM
+  .long ext_store_ignore    # 0x07 OAM RAM
   .long ext_store_ignore  # 0x08 gamepak (no RTC accepted in 8bit)
   .long ext_store_ignore  # 0x09 gamepak, ignore
   .long ext_store_ignore  # 0x0A gamepak, ignore
@@ -2844,10 +2885,14 @@
 # 16bit ext memory routines
 
 ext_store_io16:
-  andi $4, $4, 0xFFF              # wrap around address
-  andi $5, $5, 0xFFFF             # make value 16bit
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $5, $5, 0xFFFF             # make value 16bit (delay)
+  andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register16         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
@@ -2855,30 +2901,20 @@
   nop
 
 ext_store_palette16:
-  andi $4, 0x3FF                  # wrap address
-
-ext_store_palette16b:
   lui $2, %hi(palette_ram)
-  addu $2, $2, $4
-  sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
-  sll $1, $5, 1                   # make green 6bits
-  ins $1, $0, 0, 6                # make bottom bit 0
-  ins $1, $5, 0, 5                # insert red channel into $1
-  lui $2, %hi(palette_ram_converted)
+  andi $4, $4, 0x3FF              # wrap address
   addu $2, $2, $4
   jr $ra                          # return
-  sh $1, %lo(palette_ram_converted)($2)
+  sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value (delay)
 
 ext_store_vram16:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram16b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram16b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram16b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2886,16 +2922,19 @@
 ext_store_oam16:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
+  lui $2, %hi(oam_ram)            # $1 = (hi)oam_ram
+  addu $2, $2, $4                 # $1 = (hi)oam_ram + address
   jr $ra                          # return
-  sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  sh $5, %lo(oam_ram)($2)         # oam_ram[address] = value (delay)
 
 ext_store_rtc:
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $4, $4, 0xFF               # wrap address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_rtc                   # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
@@ -2902,7 +2942,7 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u16_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -2960,9 +2995,13 @@
 # 32bit ext memory routines
 
 ext_store_io32:
-  andi $4, $4, 0xFFF              # wrap around address
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $4, $4, 0x3FF              # wrap around address (delay)
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register32         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
@@ -2970,24 +3010,20 @@
   nop
 
 ext_store_palette32:
-  addu $6, $ra, $0                # save return address in $6
-  jal ext_store_palette16b        # write out palette entry
-  andi $4, 0x3FF                  # wrap address (delay)
-  addiu $4, $4, 2                 # go to next location
-  srl $5, $5, 16                  # shift to next 16bit value
-  j ext_store_palette16b          # write out next palette entry
-  addu $ra, $6, $0                # restore return address (delay)
+  lui $2, %hi(palette_ram)
+  andi $4, $4, 0x3FF              # wrap address
+  addu $2, $2, $4
+  jr $ra                          # return
+  sw $5, %lo(palette_ram)($2)     # palette_ram[address] = value (delay)
 
 ext_store_vram32:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram32b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram32b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram32b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sw $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2995,11 +3031,12 @@
 ext_store_oam32:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
+  lui $2, %hi(oam_ram)            # $1 = (hi)oam_ram
   andi $4, $4, 0x3FF              # wrap around address
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
+  addu $2, $2, $4                 # $1 = (hi)oam_ram + address
   jr $ra                          # return
-  sw $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  sw $5, %lo(oam_ram)($2)         # oam_ram[address] = value (delay)
 
 ext_store_u32_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -3031,6 +3068,7 @@
   nop
 
 #execute_store_u32:
+execute_store_full_u32:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_store_u32       # if it is, perform an extended write
   srl $2, $4, 15                  # $1 = page number of address (delay slot)
@@ -3050,24 +3088,26 @@
 # 32bit ext aligned, non a2 destroying routines
 
 ext_store_io32a:
-  andi $4, $4, 0xFFF              # wrap around address
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18
+  bne $2, $0, ext_store_ignore    # if not, unwritable
+  andi $4, $4, 0x3FF              # wrap around address (delay)
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register32         # write the value out
-  sw $6, REG_SAVE($16)            # save a2
-  lw $6, REG_SAVE($16)            # restore a2
+  sw $6, REG_SAVE($16)            # save a2 (delay)
+
   j write_io_epilogue             # handle any state changes
-  nop
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 ext_store_palette32a:
-  sw $ra, REG_SAVE($16)           # save return address
-  jal ext_store_palette16b        # write out palette entry
-  andi $4, 0x3FF                  # wrap address (delay)
-  addiu $4, $4, 2                 # go to next location
-  srl $5, $5, 16                  # shift to next 16bit value
-  j ext_store_palette16b          # write out next palette entry
-  lw $ra, REG_SAVE($16)           # restore return address (delay)
+  lui $2, %hi(palette_ram)
+  andi $4, $4, 0x3FF              # wrap address
+  addu $2, $2, $4
+  jr $ra                          # return
+  sw $5, %lo(palette_ram)($2)     # palette_ram[address] = value (delay)
 
 ext_store_u32a_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -3101,7 +3141,7 @@
 #execute_aligned_store32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_store32 # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_write[address >> 15]
   lw $1, 256($1)
@@ -3149,21 +3189,23 @@
   lw $1, CPU_MODE($16)            # $1 = cpu_mode
   lui $2, %hi(spsr)
   sll $1, $1, 2                   # adjust to word offset size
-  addu $2, $2, $1
+  addu $1, $2, $1
   jr $ra                          # return
-  lw $2, %lo(spsr)($2)            # $2 = spsr[cpu_mode] (delay slot)
+  lw $2, %lo(spsr)($1)            # $2 = spsr[cpu_mode] (delay slot)
 
 # Switch into SWI, has to collapse flags
 # $4: Current pc
 
 execute_swi:
-  add $sp, $sp, -4                # push $ra
-  sw $ra, ($sp)
   lui $1, %hi(SUPERVISOR_LR)
   sw $4, %lo(SUPERVISOR_LR)($1)   # store next PC in the supervisor's LR
   collapse_flags                  # get cpsr in $2
   lui $5, %hi(SUPERVISOR_SPSR)
   sw $2, %lo(SUPERVISOR_SPSR)($5) # save cpsr in SUPERVISOR_CPSR
+
+  addiu $sp, $sp, -4              # push $ra
+  sw $ra, ($sp)
+
   ins $2, $0, 0, 6                # zero out bottom 6 bits of CPSR
   ori $2, 0x13                    # set mode to supervisor
   sw $2, REG_CPSR($16)            # write back CPSR
@@ -3167,9 +3209,13 @@
   ins $2, $0, 0, 6                # zero out bottom 6 bits of CPSR
   ori $2, 0x13                    # set mode to supervisor
   sw $2, REG_CPSR($16)            # write back CPSR
+
   save_registers
+  jal bios_region_read_allow
+  nop
   jal set_cpu_mode                # set the CPU mode to supervisor
   li $4, 3                        # 3 is supervisor mode (delay slot)
+
   restore_registers
   lw $ra, ($sp)                   # pop $ra
   jr $ra                          # return
@@ -3173,7 +3219,7 @@
   restore_registers
   lw $ra, ($sp)                   # pop $ra
   jr $ra                          # return
-  add $sp, $sp, 4                 # fix stack (delay slot)
+  addiu $sp, $sp, 4               # fix stack (delay slot)
 
 # $4: pc to restore to
 # returns in $4
@@ -3187,10 +3232,12 @@
   sll $1, $1, 2                   # adjust to word offset size
   addu $2, $2, $1
   lw $1, %lo(spsr)($2)            # $1 = spsr[cpu_mode]
-  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
-  extract_flags_body              # extract flags from $1
+
   addiu $sp, $sp, -4
   sw $ra, ($sp)
+
+  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
+  extract_flags_body              # extract flags from $1
   save_registers
   jal execute_spsr_restore_body   # do the dirty work in this C function
   nop
@@ -3272,15 +3322,15 @@
   sllv $4, $4, $5                 # return (value << shift) (delay)
 
 lsl_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsl_shift_done      # jump if shift == 32
-  andi $22, $4, 1                 # c flag = value & 0x01 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  andi $22, $4, 1                 # c flag = value & 0x01
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsl_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsl_shift_done:
   jr $ra                          # return
-  add $4, $0, $0                  # value = 0 no matter what
+  add $4, $0, $0                  # value = 0 no matter what (delay)
 
 
 execute_lsr_flags_reg:
@@ -3297,11 +3347,11 @@
   srlv $4, $4, $5                 # return (value >> shift) (delay)
 
 lsr_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsr_shift_done      # jump if shift == 32
-  srl $22, $4, 31                 # c flag = value >> 31 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  srl $22, $4, 31                 # c flag = value >> 31
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsr_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsr_shift_done:
   jr $ra                          # return
@@ -3341,28 +3391,17 @@
 # $4: cycle counter argument
 
 execute_arm_translate:
-  addu $17, $4, $0                # load cycle counter register
   lui $16, %hi(reg)               # load base register
   addiu $16, %lo(reg)
-  extract_flags                   # load flag variables
-
-  and $1, $1, 0x20                # see if Thumb bit is set in flags
+  addu $17, $4, $0                # load cycle counter register
 
-  bne $1, $0, 1f
+  jal block_lookup_address_arm    # lookup initial jump address
   lw $4, REG_PC($16)              # load PC into $4 (delay)
 
-  jal block_lookup_address_arm    # lookup initial jump address
-  nop
   restore_registers               # load initial register values
   jr $2                           # jump to return
   nop
 
-1:
-  jal block_lookup_address_thumb  # lookup initial jump address
-  nop
-  restore_registers               # load initial register values
-  jr $2                           # jump to return
-  nop
 
 # sceKernelInvalidateIcacheRange gives me problems, trying this instead
 # Invalidates an n byte region starting at the start address
@@ -3377,9 +3416,7 @@
   nop
 
 iir_loop:
-##  cache 8, ($4)                   # invalidate icache line
-##  cache 8, ($4)                   # do it again for good luck :P
-  cache 0x08, ($4)                # hit invalidate icache line
+  cache 0x08, ($4)                # invalidate icache line
   addiu $2, $2, -1                # next loop iteration
   bne $2, $0, iir_loop            # loop
   addiu $4, $4, 64                # go to next cache line (delay slot)
@@ -3412,5 +3449,3 @@
 memory_map_write:
   .space 0x8000
 
-reg_temp:
-  .space 0x100
Only in mod/: psp
Only in old/: readme_kai_jp.txt
diff -ruibwEB --strip-trailing-cr -I RE old/sound.c mod/sound.c
--- old/sound.c	2007-08-26 00:49:55.000000000 +0900
+++ mod/sound.c	2007-10-23 23:17:14.359534400 +0900
@@ -25,56 +26,41 @@
 direct_sound_struct direct_sound_channel[2];
 gbc_sound_struct gbc_sound_channel[4];
 
-//u32 sound_frequency = 44100;
+u8 sound_on = 0;
 
-SDL_AudioSpec sound_settings;
-SDL_mutex *sound_mutex;
-SDL_cond *sound_cv;
+int sound_volume;
 
-u32 audio_buffer_size_number = 1;
-u32 audio_buffer_size;
-u32 audio_buffer_size_x2;
-u32 sound_on = 0;
-s16 sound_buffer[BUFFER_SIZE];
-u32 sound_buffer_base = 0;
 
-u32 sound_last_cpu_ticks = 0;
-FIXED16_16 gbc_sound_tick_step;
+static void init_noise_table(u32 *table, u32 period, u32 bit_length);
 
-u32 gbc_sound_wave_update;
+static SceUID sound_thread;
+static int sound_handle;
+static int sound_update_thread(SceSize args, void *argp);
+static void sound_callback(s16 *stream, int length);
 
-u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
+static u8 sound_active;
 
-void sound_callback(void *userdata, Uint8 *stream, int length);
-void init_noise_table(u32 *table, u32 period, u32 bit_length);
+static s16 psp_sound_buffer[SOUND_BUFFER_SIZE];
+static u16 audio_buffer_size_xN = SOUND_BUFFER_SIZE * 3;
 
-// Queue 1, 2, or 4 samples to the top of the DS FIFO, wrap around circularly
+static s16 sound_buffer[BUFFER_SIZE];
+static u32 sound_buffer_base = 0;
 
-#define sound_timer_queue(size, value)                                        \
-  *((s##size *)(ds->fifo + ds->fifo_top)) = value;                            \
-  ds->fifo_top = (ds->fifo_top + 1) % 32;                                     \
+static u32 sound_last_cpu_ticks = 0;
+static FIXED16_16 gbc_sound_tick_step;
 
-void sound_timer_queue8(u32 channel, u8 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  sound_timer_queue(8, value);
-}
 
-void sound_timer_queue16(u32 channel, u16 value)
+void sound_timer_queue32(u8 channel)
 {
   direct_sound_struct *ds = direct_sound_channel + channel;
-  sound_timer_queue(8, value & 0xFF);
-  sound_timer_queue(8, value >> 8);
-}
+  u8 offset = channel * 4;
+  u8 i;
 
-void sound_timer_queue32(u32 channel, u32 value)
+  for(i = 0xA0; i <= 0xA3; i++)
 {
-  direct_sound_struct *ds = direct_sound_channel + channel;
-
-  sound_timer_queue(8, value & 0xFF);
-  sound_timer_queue(8, (value >> 8) & 0xFF);
-  sound_timer_queue(8, (value >> 16) & 0xFF);
-  sound_timer_queue(8, value >> 24);
+    ds->fifo[ds->fifo_top] = ADDRESS8(io_registers, i + offset);
+    ds->fifo_top = (ds->fifo_top + 1) % 32;
+  }
 }
 
 // Unqueue 1 sample from the base of the DS FIFO and place it on the audio
@@ -84,14 +70,14 @@
 
 #define render_sample_null()                                                  \
 
-#define render_sample_left()                                                  \
-  sound_buffer[buffer_index] += current_sample +                              \
-   FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
-
 #define render_sample_right()                                                 \
   sound_buffer[buffer_index + 1] += current_sample +                          \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
 
+#define render_sample_left()                                                  \
+  sound_buffer[buffer_index] += current_sample +                              \
+   FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
+
 #define render_sample_both()                                                  \
   dest_sample = current_sample +                                              \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional);          \
@@ -153,7 +139,14 @@
   ds->buffer_index = buffer_index;
   ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
 
-  if(((ds->fifo_top - ds->fifo_base) % 32) <= 16)
+  u8 fifo_length;
+
+  if(ds->fifo_top > ds->fifo_base)
+    fifo_length = ds->fifo_top - ds->fifo_base;
+  else
+    fifo_length = ds->fifo_top + (32 - ds->fifo_base);
+
+  if(fifo_length <= 16)
   {
     if(dma[1].direct_sound_channel == channel)
       dma_transfer(dma + 1);
@@ -165,7 +158,7 @@
 
 void sound_reset_fifo(u32 channel)
 {
-  direct_sound_struct *ds = direct_sound_channel;
+  DIRECT_SOUND_STRUCT *ds = direct_sound_channel + channel;
 
   memset(ds->fifo, 0, 32);
 }
@@ -185,17 +178,17 @@
   { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
   { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
   { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 },
+  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 }
 };
 
-s8 wave_samples[64];
+static s8 wave_samples[64];
 
-u32 noise_table15[1024];
-u32 noise_table7[4];
+static u32 noise_table15[1024];
+static u32 noise_table7[4];
 
-u32 gbc_sound_master_volume_table[4] = { 1, 2, 4, 0 };
+static const u8 gbc_sound_master_volume_table[4] = { 1, 2, 4, 0 };
 
-u32 gbc_sound_channel_volume_table[8] =
+static u32 gbc_sound_channel_volume_table[8] =
 {
   FIXED_DIV(0, 7, 12),
   FIXED_DIV(1, 7, 12),
@@ -207,7 +200,7 @@
   FIXED_DIV(7, 7, 12)
 };
 
-u32 gbc_sound_envelope_volume_table[16] =
+static u32 gbc_sound_envelope_volume_table[16] =
 {
   FIXED_DIV(0, 15, 14),
   FIXED_DIV(1, 15, 14),
@@ -228,12 +221,12 @@
 };
 
 u32 gbc_sound_buffer_index = 0;
-u32 gbc_sound_last_cpu_ticks = 0;
-u32 gbc_sound_partial_ticks = 0;
+static u32 gbc_sound_last_cpu_ticks = 0;
+static u32 gbc_sound_partial_ticks = 0;
 
-u32 gbc_sound_master_volume_left;
-u32 gbc_sound_master_volume_right;
-u32 gbc_sound_master_volume;
+u8 gbc_sound_master_volume_left;
+u8 gbc_sound_master_volume_right;
+u8 gbc_sound_master_volume;
 
 #define update_volume_channel_envelope(channel)                               \
   volume_##channel = gbc_sound_envelope_volume_table[envelope_volume] *       \
@@ -259,18 +252,23 @@
       u32 rate = gs->rate;                                                    \
                                                                               \
       if(gs->sweep_direction)                                                 \
+      {                                                                       \
         rate = rate - (rate >> gs->sweep_shift);                              \
+      }                                                                       \
       else                                                                    \
+      {                                                                       \
         rate = rate + (rate >> gs->sweep_shift);                              \
+      }                                                                       \
                                                                               \
-      if(rate > 2048) {                                                       \
-        rate = 0;                                                             \
-        frequency_step = 0;                                                   \
-      } else {                                                                \
-        frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)  \
-        / SOUND_FREQUENCY);                                                   \
+      if(rate > 2047)                                                         \
+      {                                                                       \
+        gs->active_flag = 0;                                                  \
+        break;                                                                \
       }                                                                       \
                                                                               \
+      frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) /  \
+       SOUND_FREQUENCY);                                                      \
+                                                                              \
       gs->frequency_step = frequency_step;                                    \
       gs->rate = rate;                                                        \
                                                                               \
@@ -292,13 +290,17 @@
       if(gs->envelope_direction)                                              \
       {                                                                       \
         if(envelope_volume != 15)                                             \
+        {                                                                     \
           envelope_volume = gs->envelope_volume + 1;                          \
       }                                                                       \
+      }                                                                       \
       else                                                                    \
       {                                                                       \
         if(envelope_volume != 0)                                              \
+        {                                                                     \
           envelope_volume = gs->envelope_volume - 1;                          \
       }                                                                       \
+      }                                                                       \
                                                                               \
       update_volume(envelope);                                                \
                                                                               \
@@ -317,6 +319,8 @@
   tick_counter += gbc_sound_tick_step;                                        \
   if(tick_counter > 0xFFFF)                                                   \
   {                                                                           \
+    tick_counter &= 0xFFFF;                                                   \
+                                                                              \
     if(gs->length_status)                                                     \
     {                                                                         \
       u32 length_ticks = gs->length_ticks - 1;                                \
@@ -331,8 +335,6 @@
                                                                               \
     update_tone_##envelope_op();                                              \
     update_tone_##sweep_op();                                                 \
-                                                                              \
-    tick_counter &= 0xFFFF;                                                   \
   }                                                                           \
 
 #define gbc_sound_render_sample_right()                                       \
@@ -381,7 +383,9 @@
     sample_index += frequency_step;                                           \
                                                                               \
     if(sample_index >= U32_TO_FP16_16(gbc_noise_wrap_##noise_type))           \
+    {                                                                         \
       sample_index -= U32_TO_FP16_16(gbc_noise_wrap_##noise_type);            \
+    }                                                                         \
                                                                               \
     buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
     update_tone_counters(envelope_op, sweep_op);                              \
@@ -398,23 +402,31 @@
   switch(gs->status)                                                          \
   {                                                                           \
     case GBC_SOUND_INACTIVE:                                                  \
+    {                                                                         \
       break;                                                                  \
-                                                                              \
-    case GBC_SOUND_LEFT:                                                      \
-      gbc_sound_render_##type(left, sample_length, envelope_op, sweep_op);    \
-      break;                                                                  \
+    }                                                                         \
                                                                               \
     case GBC_SOUND_RIGHT:                                                     \
+    {                                                                         \
       gbc_sound_render_##type(right, sample_length, envelope_op, sweep_op);   \
       break;                                                                  \
+    }                                                                         \
+                                                                              \
+    case GBC_SOUND_LEFT:                                                      \
+    {                                                                         \
+      gbc_sound_render_##type(left, sample_length, envelope_op, sweep_op);    \
+      break;                                                                  \
+    }                                                                         \
                                                                               \
     case GBC_SOUND_LEFTRIGHT:                                                 \
+    {                                                                         \
       gbc_sound_render_##type(both, sample_length, envelope_op, sweep_op);    \
       break;                                                                  \
   }                                                                           \
+  }                                                                           \
                                                                               \
   gs->sample_index = sample_index;                                            \
-  gs->tick_counter = tick_counter;                                            \
+  gs->tick_counter = tick_counter                                             \
 
 #define gbc_sound_load_wave_ram(bank)                                         \
   wave_bank = wave_samples + (bank * 32);                                     \
@@ -427,8 +439,8 @@
 
 void update_gbc_sound(u32 cpu_ticks)
 {
-  FIXED16_16 buffer_ticks = FLOAT_TO_FP16_16(((float)(cpu_ticks -
-   gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / 16777216.0);
+  FIXED16_16 buffer_ticks = FLOAT_TO_FP16_16(((float)
+   (cpu_ticks - gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / 16777216.0);
   u32 i, i2;
   gbc_sound_struct *gs = gbc_sound_channel;
   FIXED16_16 sample_index, frequency_step;
@@ -451,21 +463,20 @@
     gbc_sound_partial_ticks &= 0xFFFF;
   }
 
-  SDL_LockMutex(sound_mutex);
-
   if(synchronize_flag)
   {
     if(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
-     (audio_buffer_size_x2))
+     audio_buffer_size_xN)
     {
       while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
-       (audio_buffer_size_x2))
+       audio_buffer_size_xN)
       {
-        SDL_CondWait(sound_cv, sound_mutex);
+        delay_us(10);
       }
-      if(game_config_frameskip_type == auto_frameskip)
+
+      if(current_frameskip_type == auto_frameskip)
       {
-//        sceDisplayWaitVblankStart();
+        sceDisplayWaitVblankStart();
         real_frame_count = 0;
         virtual_frame_count = 0;
       }
@@ -495,15 +506,7 @@
     gs = gbc_sound_channel + 2;
     if(gbc_sound_wave_update)
     {
-      if(gs->wave_bank == 1)
-      {
-        gbc_sound_load_wave_ram(1);
-      }
-      else
-      {
-        gbc_sound_load_wave_ram(0);
-      }
-
+      gbc_sound_load_wave_ram(gs->wave_bank);
       gbc_sound_wave_update = 0;
     }
 
@@ -511,16 +514,17 @@
     {
       sound_status |= 0x04;
       sample_data = wave_samples;
-      if(gs->wave_type == 0)
-      {
-        if(gs->wave_bank == 1)
-          sample_data += 32;
 
-        gbc_sound_render_channel(samples, 32, noenvelope, nosweep);
+      if(gs->wave_type)
+      {
+        gbc_sound_render_channel(samples, 64, noenvelope, nosweep);
       }
       else
       {
-        gbc_sound_render_channel(samples, 64, noenvelope, nosweep);
+        if(gs->wave_bank)
+          sample_data += 32;
+
+        gbc_sound_render_channel(samples, 32, noenvelope, nosweep);
       }
     }
 
@@ -530,7 +534,7 @@
       sound_status |= 0x08;
       envelope_volume = gs->envelope_volume;
 
-      if(gs->noise_type == 1)
+      if(gs->noise_type)
       {
         gbc_sound_render_channel(noise, half, envelope, nosweep);
       }
@@ -543,68 +547,103 @@
 
   ADDRESS16(io_registers, 0x84) = sound_status;
 
-  SDL_CondSignal(sound_cv);
-
-  SDL_UnlockMutex(sound_mutex);
-
   gbc_sound_last_cpu_ticks = cpu_ticks;
   gbc_sound_buffer_index =
    (gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
 }
 
+
+// Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
+// on the forum at http://meridian.overclocked.org:
+// http://meridian.overclocked.org/cgi-bin/wwwthreads/showpost.pl?Board=merid
+// angeneraldiscussion&Number=2069&page=0&view=expanded&mode=threaded&sb=4
+// Hope you don't mind me borrowing it ^_-
+
+static void init_noise_table(u32 *table, u32 period, u32 bit_length)
+{
+  u32 shift_register = 0xFF;
+  u32 mask = ~(1 << bit_length);
+  s32 table_pos, bit_pos;
+  u32 current_entry;
+  u32 table_period = (period + 31) / 32;
+
+  // Bits are stored in reverse order so they can be more easily moved to
+  // bit 31, for sign extended shift down.
+
+  for(table_pos = 0; table_pos < table_period; table_pos++)
+  {
+    current_entry = 0;
+    for(bit_pos = 31; bit_pos >= 0; bit_pos--)
+    {
+      current_entry |= (shift_register & 0x01) << bit_pos;
+
+      shift_register =
+       ((1 & (shift_register ^ (shift_register >> 1))) << bit_length) |
+       ((shift_register >> 1) & mask);
+    }
+
+    table[table_pos] = current_entry;
+  }
+}
+
+
 #define sound_copy_normal()                                                   \
   current_sample = source[i]                                                  \
 
 #define sound_copy(source_offset, length, render_type)                        \
-  _length = (length) / 2;                                                     \
+  _length = (length) >> 1;                                                    \
   source = (s16 *)(sound_buffer + source_offset);                             \
+                                                                              \
   for(i = 0; i < _length; i++)                                                \
   {                                                                           \
     sound_copy_##render_type();                                               \
     if(current_sample > 2047)                                                 \
+    {                                                                         \
       current_sample = 2047;                                                  \
+    }                                                                         \
     if(current_sample < -2048)                                                \
+    {                                                                         \
       current_sample = -2048;                                                 \
-                                                                              \
+    }                                                                         \
     stream_base[i] = current_sample << 4;                                     \
     source[i] = 0;                                                            \
   }                                                                           \
 
 #define sound_copy_null(source_offset, length)                                \
-  _length = (length) >> 2;                                                    \
+  _length = (length) >> 1;                                                    \
   source = (s16 *)(sound_buffer + source_offset);                             \
+                                                                              \
+  for(i = 0; i < _length; i++)                                                \
   {                                                                           \
-    u32 *ptr1 = (u32 *) stream_base;                                          \
-    u32 *ptr2 = (u32 *) source;                                               \
-    while (_length--) *ptr1++ = *ptr2++ = 0;                                  \
+    stream_base[i] = 0;                                                       \
+    source[i] = 0;                                                            \
   }                                                                           \
 
-void sound_callback(void *userdata, Uint8 *stream, int length)
+static void sound_callback(s16 *stream, int length)
 {
-  u32 sample_length = length / 2;
+  u32 sample_length = length >> 1;
   u32 _length;
   u32 i;
-  s16 *stream_base = (s16 *)stream;
+  s16 *stream_base = stream;
   s16 *source;
   s32 current_sample;
 
-  SDL_LockMutex(sound_mutex);
-
-  while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) <
-   length)
+  while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) < length)
   {
-    SDL_CondWait(sound_cv, sound_mutex);
+    delay_us(10);
+
+    if(!sound_active)
+      goto outloop;
   }
 
   if(global_enable_audio)
   {
     if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
     {
-      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
+      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) << 1;
       sound_copy(sound_buffer_base, partial_length, normal);
-//      source = (s16 *)sound_buffer;
       sound_copy(0, length - partial_length, normal);
-      sound_buffer_base = (length - partial_length) / 2;
+      sound_buffer_base = (length - partial_length) >> 1;
     }
     else
     {
@@ -616,67 +655,80 @@
   {
     if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
     {
-      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
+      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) << 1;
       sound_copy_null(sound_buffer_base, partial_length);
-//      source = (s16 *)sound_buffer;
       sound_copy_null(0, length - partial_length);
-      sound_buffer_base = (length - partial_length) / 2;
+      sound_buffer_base = (length - partial_length) >> 1;
     }
     else
     {
       sound_copy_null(sound_buffer_base, length);
       sound_buffer_base += sample_length;
     }
+
+    sound_volume = 0;
+  }
+
+  outloop:;
   }
 
-  SDL_CondSignal(sound_cv);
+static int sound_update_thread(SceSize args, void *argp)
+{
+  while(sound_active)
+  {
+    while(sleep_flag)
+      delay_us(500000);
 
-  SDL_UnlockMutex(sound_mutex);
+    sound_callback(psp_sound_buffer, SOUND_BUFFER_SIZE);
+    sceAudioOutputBlocking(sound_handle, sound_volume, (char *)psp_sound_buffer);
 }
 
-// Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
-// on the forum at http://meridian.overclocked.org:
-// http://meridian.overclocked.org/cgi-bin/wwwthreads/showpost.pl?Board=merid
-// angeneraldiscussion&Number=2069&page=0&view=expanded&mode=threaded&sb=4
-// Hope you don't mind me borrowing it ^_-
+  sceAudioChRelease(sound_handle);
+  sceKernelExitThread(0);
+
+  return 0;
+}
 
-void init_noise_table(u32 *table, u32 period, u32 bit_length)
+void init_sound(void)
 {
-  u32 shift_register = 0xFF;
-  u32 mask = ~(1 << bit_length);
-  s32 table_pos, bit_pos;
-  u32 current_entry;
-  u32 table_period = (period + 31) / 32;
+  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
 
-  // Bits are stored in reverse order so they can be more easily moved to
-  // bit 31, for sign extended shift down.
+  init_noise_table(noise_table15, 32767, 14);
+  init_noise_table(noise_table7, 127, 6);
 
-  for(table_pos = 0; table_pos < table_period; table_pos++)
-  {
-    current_entry = 0;
-    for(bit_pos = 31; bit_pos >= 0; bit_pos--)
+  sound_handle = sceAudioChReserve(PSP_AUDIO_NEXT_CHANNEL,
+                                   SOUND_BUFFER_SIZE / 4,
+                                   PSP_AUDIO_FORMAT_STEREO);
+  if(sound_handle < 0)
     {
-      current_entry |= (shift_register & 0x01) << bit_pos;
-
-      shift_register =
-       ((1 & (shift_register ^ (shift_register >> 1))) << bit_length) |
-       ((shift_register >> 1) & mask);
+    quit();
     }
 
-    table[table_pos] = current_entry;
+  sound_thread = sceKernelCreateThread("Sound thread", sound_update_thread,
+                                       0x11, 1024, 0, NULL);
+  if(sound_thread < 0)
+  {
+    sceAudioChRelease(sound_handle);
+    quit();
   }
+
+  sound_active = 1;
+  sceKernelStartThread(sound_thread, 0, 0);
+
+  reset_sound();
 }
 
-void reset_sound()
+void reset_sound(void)
 {
   direct_sound_struct *ds = direct_sound_channel;
   gbc_sound_struct *gs = gbc_sound_channel;
-  u32 i;
+  u8 i;
 
   sound_on = 0;
   sound_buffer_base = 0;
   sound_last_cpu_ticks = 0;
-  memset(sound_buffer, 0, audio_buffer_size);
+
+  memset(sound_buffer, 0, BUFFER_SIZE);
 
   for(i = 0; i < 2; i++, ds++)
   {
@@ -704,47 +756,21 @@
     gs->sample_data = square_pattern_duty[2];
     gs->active_flag = 0;
   }
+
+  sound_volume = PSP_AUDIO_VOLUME_MAX;
 }
 
-void sound_exit()
+void sound_exit(void)
 {
-//  gbc_sound_buffer_index =
-//   (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
-  SDL_PauseAudio(1);
-  SDL_CondSignal(sound_cv);
-}
-
-void init_sound()
-{
-  audio_buffer_size = (audio_buffer_size_number * 1024) + 2048;
-  audio_buffer_size_x2 = audio_buffer_size * 2;
-
-  SDL_AudioSpec desired_spec =
-  {
-    SOUND_FREQUENCY,
-    AUDIO_S16,
-    2,
-    0,
-    audio_buffer_size / 4,
-    0,
-    0,
-    sound_callback,
-    NULL
-  };
-
-  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
-
-  init_noise_table(noise_table15, 32767, 14);
-  init_noise_table(noise_table7, 127, 6);
-
-  reset_sound();
+  if(sound_thread >= 0)
+  {
+    sound_active = 0;
+    sceKernelWaitThreadEnd(sound_thread, NULL);
 
-  SDL_OpenAudio(&desired_spec, &sound_settings);
-//  sound_frequency = sound_settings.freq;
-  sound_mutex = SDL_CreateMutex();
-  sound_cv = SDL_CreateCond();
-  SDL_PauseAudio(0);
+    sceKernelDeleteThread(sound_thread);
 }
+}
+
 
 #define sound_savestate_body(type)                                          \
 {                                                                           \
diff -ruibwEB --strip-trailing-cr -I RE old/sound.h mod/sound.h
--- old/sound.h	2007-08-26 00:49:55.000000000 +0900
+++ mod/sound.h	2007-10-23 23:15:46.693476800 +0900
@@ -21,12 +21,11 @@
 #ifndef SOUND_H
 #define SOUND_H
 
-#define BUFFER_SIZE 65536
 
-// A lot of sound cards on PC can't handle such small buffers but this
-// seems to work well on PSP.
+#define BUFFER_SIZE 65536
+#define SOUND_BUFFER_SIZE 2048
 
-#define SOUND_BUFFER_SIZE 4096
+#define SOUND_FREQUENCY 44100
 
 typedef enum
 {
@@ -42,11 +41,19 @@
   DIRECT_SOUND_VOLUME_100
 } direct_sound_volume_type;
 
+typedef enum
+{
+  GBC_SOUND_INACTIVE,
+  GBC_SOUND_RIGHT,
+  GBC_SOUND_LEFT,
+  GBC_SOUND_LEFTRIGHT
+} GBC_SOUND_STATUS_TYPE;
+
 typedef struct
 {
   s8 fifo[32];
-  u32 fifo_base;
-  u32 fifo_top;
+  u8 fifo_base;
+  u8 fifo_top;
   FIXED16_16 fifo_fractional;
   // The + 1 is to give some extra room for linear interpolation
   // when wrapping around.
@@ -56,43 +63,34 @@
   u32 last_cpu_ticks;
 } direct_sound_struct;
 
-typedef enum
-{
-  GBC_SOUND_INACTIVE,
-  GBC_SOUND_RIGHT,
-  GBC_SOUND_LEFT,
-  GBC_SOUND_LEFTRIGHT
-} gbc_sound_status_type;
-
-
 typedef struct
 {
-  u32 rate;
+  u16 rate;
   FIXED16_16 frequency_step;
   FIXED16_16 sample_index;
   FIXED16_16 tick_counter;
-  u32 total_volume;
-  u32 envelope_initial_volume;
-  u32 envelope_volume;
-  u32 envelope_direction;
-  u32 envelope_status;
-  u32 envelope_step;
-  u32 envelope_ticks;
-  u32 envelope_initial_ticks;
-  u32 sweep_status;
-  u32 sweep_direction;
-  u32 sweep_ticks;
-  u32 sweep_initial_ticks;
-  u32 sweep_shift;
-  u32 length_status;
-  u32 length_ticks;
-  u32 noise_type;
-  u32 wave_type;
-  u32 wave_bank;
-  u32 wave_volume;
+  u8 total_volume;
+  u8 envelope_initial_volume;
+  u8 envelope_volume;
+  u8 envelope_direction;
+  u8 envelope_status;
+  u8 envelope_step;
+  u8 envelope_ticks;
+  u8 envelope_initial_ticks;
+  u8 sweep_status;
+  u8 sweep_direction;
+  u8 sweep_ticks;
+  u8 sweep_initial_ticks;
+  u8 sweep_shift;
+  u8 length_status;
+  u8 length_ticks;
+  u8 noise_type;
+  u8 wave_type;
+  u8 wave_bank;
+  u16 wave_volume;
   gbc_sound_status_type status;
-  u32 active_flag;
-  u32 master_enable;
+  u8 active_flag;
+  u8 master_enable;
   s8 *sample_data;
 } gbc_sound_struct;
 
@@ -96,29 +94,26 @@
   s8 *sample_data;
 } gbc_sound_struct;
 
+
 extern direct_sound_struct direct_sound_channel[2];
 extern gbc_sound_struct gbc_sound_channel[4];
+
 extern s8 square_pattern_duty[4][8];
-extern u32 gbc_sound_master_volume_left;
-extern u32 gbc_sound_master_volume_right;
-extern u32 gbc_sound_master_volume;
+extern u8 gbc_sound_master_volume_left;
+extern u8 gbc_sound_master_volume_right;
+extern u8 gbc_sound_master_volume;
 
-extern u32 sound_on;
+extern u32 gbc_sound_buffer_index;
 
+extern u8 sound_on;
 extern u32 global_enable_audio;
-extern u32 enable_low_pass_filter;
-extern u32 audio_buffer_size_number;
+extern int sound_volume;
 
-extern SDL_mutex *sound_mutex;
-extern SDL_cond *sound_cv;
-
-void sound_timer_queue8(u32 channel, u8 value);
-void sound_timer_queue16(u32 channel, u16 value);
-void sound_timer_queue32(u32 channel, u32 value);
+void sound_timer_queue32(u8 channel);
 void sound_timer(FIXED16_16 frequency_step, u32 channel);
 void sound_reset_fifo(u32 channel);
 void update_gbc_sound(u32 cpu_ticks);
-void init_sound();
+void init_sound(void);
 void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void sound_read_savestate(FILE_TAG_TYPE savestate_file);
 
@@ -128,6 +122,7 @@
 {                                                                             \
   u32 initial_volume = (value >> 12) & 0x0F;                                  \
   u32 envelope_ticks = ((value >> 8) & 0x07) * 4;                             \
+                                                                              \
   gbc_sound_channel[channel].length_ticks = 64 - (value & 0x3F);              \
   gbc_sound_channel[channel].sample_data =                                    \
    square_pattern_duty[(value >> 6) & 0x03];                                  \
@@ -137,18 +132,19 @@
   gbc_sound_channel[channel].envelope_initial_ticks = envelope_ticks;         \
   gbc_sound_channel[channel].envelope_ticks = envelope_ticks;                 \
   gbc_sound_channel[channel].envelope_status = (envelope_ticks != 0);         \
-  gbc_sound_channel[channel].envelope_volume = initial_volume;                \
+                                                                              \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, address) = value;                                   \
 }                                                                             \
 
 #define gbc_sound_tone_control_high(channel, address)                         \
 {                                                                             \
-  u32 rate = value & 0x7FF;                                                   \
+  u16 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[channel].rate = rate;                                     \
   gbc_sound_channel[channel].frequency_step =                                 \
    FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / SOUND_FREQUENCY);    \
   gbc_sound_channel[channel].length_status = (value >> 14) & 0x01;            \
+                                                                              \
   if(value & 0x8000)                                                          \
   {                                                                           \
     gbc_sound_channel[channel].active_flag = 1;                               \
@@ -157,6 +153,8 @@
      gbc_sound_channel[channel].envelope_initial_ticks;                       \
     gbc_sound_channel[channel].envelope_volume =                              \
      gbc_sound_channel[channel].envelope_initial_volume;                      \
+    gbc_sound_channel[channel].sweep_ticks =                                  \
+     gbc_sound_channel[channel].sweep_initial_ticks;                          \
   }                                                                           \
                                                                               \
   gbc_sound_update = 1;                                                       \
@@ -165,12 +163,13 @@
 
 #define gbc_sound_tone_control_sweep()                                        \
 {                                                                             \
-  u32 sweep_ticks = ((value >> 4) & 0x07) * 2;                                \
+  u8 sweep_ticks = ((value >> 4) & 0x07) * 2;                                 \
   gbc_sound_channel[0].sweep_shift = value & 0x07;                            \
   gbc_sound_channel[0].sweep_direction = (value >> 3) & 0x01;                 \
   gbc_sound_channel[0].sweep_status = (value != 8);                           \
   gbc_sound_channel[0].sweep_ticks = sweep_ticks;                             \
   gbc_sound_channel[0].sweep_initial_ticks = sweep_ticks;                     \
+                                                                              \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, 0x60) = value;                                      \
 }                                                                             \
@@ -179,6 +178,7 @@
 {                                                                             \
   gbc_sound_channel[2].wave_type = (value >> 5) & 0x01;                       \
   gbc_sound_channel[2].wave_bank = (value >> 6) & 0x01;                       \
+                                                                              \
   if(value & 0x80)                                                            \
   {                                                                           \
     gbc_sound_channel[2].master_enable = 1;                                   \
@@ -192,11 +192,12 @@
   ADDRESS16(io_registers, 0x70) = value;                                      \
 }                                                                             \
 
-extern u32 gbc_sound_wave_volume[4];
-
 #define gbc_sound_tone_control_low_wave()                                     \
 {                                                                             \
+  const u16 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };              \
+                                                                              \
   gbc_sound_channel[2].length_ticks = 256 - (value & 0xFF);                   \
+                                                                              \
   if((value >> 15) & 0x01)                                                    \
   {                                                                           \
     gbc_sound_channel[2].wave_volume = 12288;                                 \
@@ -206,30 +207,34 @@
     gbc_sound_channel[2].wave_volume =                                        \
      gbc_sound_wave_volume[(value >> 13) & 0x03];                             \
   }                                                                           \
+                                                                              \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, 0x72) = value;                                      \
 }                                                                             \
 
 #define gbc_sound_tone_control_high_wave()                                    \
 {                                                                             \
-  u32 rate = value & 0x7FF;                                                   \
+  u16 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[2].rate = rate;                                           \
   gbc_sound_channel[2].frequency_step =                                       \
    FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / SOUND_FREQUENCY);           \
   gbc_sound_channel[2].length_status = (value >> 14) & 0x01;                  \
+                                                                              \
   if(value & 0x8000)                                                          \
   {                                                                           \
     gbc_sound_channel[2].sample_index = 0;                                    \
     gbc_sound_channel[2].active_flag = 1;                                     \
   }                                                                           \
+                                                                              \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, 0x74) = value;                                      \
 }                                                                             \
 
 #define gbc_sound_noise_control()                                             \
 {                                                                             \
-  u32 dividing_ratio = value & 0x07;                                          \
-  u32 frequency_shift = (value >> 4) & 0x0F;                                  \
+  u8 dividing_ratio = value & 0x07;                                           \
+  u8 frequency_shift = (value >> 4) & 0x0F;                                   \
+                                                                              \
   if(dividing_ratio == 0)                                                     \
   {                                                                           \
     gbc_sound_channel[3].frequency_step =                                     \
@@ -242,8 +247,10 @@
      FLOAT_TO_FP16_16(524288.0 / (dividing_ratio *                            \
      (1 << (frequency_shift + 1))) / SOUND_FREQUENCY);                        \
   }                                                                           \
+                                                                              \
   gbc_sound_channel[3].noise_type = (value >> 3) & 0x01;                      \
   gbc_sound_channel[3].length_status = (value >> 14) & 0x01;                  \
+                                                                              \
   if(value & 0x8000)                                                          \
   {                                                                           \
     gbc_sound_channel[3].sample_index = 0;                                    \
@@ -253,31 +260,35 @@
     gbc_sound_channel[3].envelope_volume =                                    \
      gbc_sound_channel[3].envelope_initial_volume;                            \
   }                                                                           \
+                                                                              \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, 0x7C) = value;                                      \
 }                                                                             \
 
 #define gbc_trigger_sound_channel(channel)                                    \
-  gbc_sound_master_volume_right = value & 0x07;                               \
-  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
-  gbc_sound_channel[channel].status = ((value >> (channel + 8)) & 0x01) |     \
-   ((value >> (channel + 11)) & 0x03)                                         \
+  gbc_sound_channel[channel].status =                                         \
+  ((value >> (channel + 11)) & 0x02) | ((value >> (channel + 8)) & 0x01)      \
 
 #define gbc_trigger_sound()                                                   \
 {                                                                             \
+  gbc_sound_master_volume_right = value & 0x07;                               \
+  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
+                                                                              \
   gbc_trigger_sound_channel(0);                                               \
   gbc_trigger_sound_channel(1);                                               \
   gbc_trigger_sound_channel(2);                                               \
   gbc_trigger_sound_channel(3);                                               \
+                                                                              \
   ADDRESS16(io_registers, 0x80) = value;                                      \
 }                                                                             \
 
 #define trigger_sound()                                                       \
 {                                                                             \
-  timer[0].direct_sound_channels = (((value >> 10) & 0x01) == 0) |            \
-   ((((value >> 14) & 0x01) == 0) << 1);                                      \
-  timer[1].direct_sound_channels = (((value >> 10) & 0x01) == 1) |            \
-   ((((value >> 14) & 0x01) == 1) << 1);                                      \
+  timer[0].direct_sound_channels =                                            \
+   ((~value >> 13) & 0x02) | ((~value >> 10) & 0x01);                         \
+  timer[1].direct_sound_channels =                                            \
+   ((value >> 13) & 0x02) | ((value >> 10) & 0x01);                           \
+                                                                              \
   direct_sound_channel[0].volume = (value >> 2) & 0x01;                       \
   direct_sound_channel[0].status = (value >> 8) & 0x03;                       \
   direct_sound_channel[1].volume = (value >> 3) & 0x01;                       \
@@ -285,37 +296,43 @@
   gbc_sound_master_volume = value & 0x03;                                     \
                                                                               \
   if((value >> 11) & 0x01)                                                    \
+  {                                                                           \
     sound_reset_fifo(0);                                                      \
+  }                                                                           \
   if((value >> 15) & 0x01)                                                    \
+  {                                                                           \
     sound_reset_fifo(1);                                                      \
+  }                                                                           \
+                                                                              \
   ADDRESS16(io_registers, 0x82) = value;                                      \
 }                                                                             \
 
 #define sound_on()                                                            \
-  if(value & 0x80)                                                            \
   {                                                                           \
-    if(sound_on != 1)                                                         \
+  if(value & 0x80)                                                            \
     {                                                                         \
       sound_on = 1;                                                           \
     }                                                                         \
-  }                                                                           \
   else                                                                        \
   {                                                                           \
-    u32 i;                                                                    \
+    u8 i;                                                                     \
     for(i = 0; i < 4; i++)                                                    \
     {                                                                         \
       gbc_sound_channel[i].active_flag = 0;                                   \
     }                                                                         \
     sound_on = 0;                                                             \
   }                                                                           \
+                                                                              \
   ADDRESS16(io_registers, 0x84) =                                             \
     (ADDRESS16(io_registers, 0x84) & 0x000F) | (value & 0xFFF0);              \
+}                                                                             \
 
 #define sound_update_frequency_step(timer_number)                             \
   timer[timer_number].frequency_step =                                        \
    FLOAT_TO_FP16_16(16777216.0 / (timer_reload * SOUND_FREQUENCY))            \
 
-void reset_sound();
-void sound_exit();
 
-#endif
+void reset_sound(void);
+void sound_exit(void);
+
+#endif /* SOUND_H */
diff -ruibwEB --strip-trailing-cr -I RE old/video.c mod/video.c
--- old/video.c	2007-08-26 00:49:54.000000000 +0900
+++ mod/video.c	2007-10-27 22:43:28.689392000 +0900
@@ -20,16 +20,6 @@
 
 #include "common.h"
 
-#include <pspctrl.h>
-
-#include <pspkernel.h>
-#include <pspdebug.h>
-#include <pspdisplay.h>
-
-#include <pspgu.h>
-#include <psppower.h>
-#include <psprtc.h>
-
 #define render_scanline_dest_normal         u16
 #define render_scanline_dest_alpha          u32
 #define render_scanline_dest_alpha_obj      u32
@@ -45,60 +35,12 @@
 static u32 *ge_cmd_ptr = (u32 *)0x441FC000;
 static u32 gecbid;
 static u32 video_direct = 0;
+static u16 *screen_texture = (u16 *)(0x4000000 + (512 * 272 * 2));
+// static u16 *current_screen_texture = (u16 *)(0x4000000 + (512 * 272 * 2));
+static u16 *screen_pixels = (u16 *)(0x4000000 + (512 * 272 * 2));
+static u32 screen_pitch = 240;
 
-static u32 __attribute__((aligned(32))) display_list[32];
-
-
-void render_scanline_text_base_normal(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_transparent_normal(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_base_color16(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_transparent_color16(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_base_color32(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_transparent_color32(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_base_alpha(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_text_transparent_alpha(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_base_normal(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_transparent_normal(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_base_color16(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_transparent_color16(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_base_color32(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_transparent_color32(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_base_alpha(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_affine_transparent_alpha(u32 layer, u32 start, u32 end, void *scanline);
-void render_scanline_bitmap_mode3_normal(u32 start, u32 end, void *scanline);
-void render_scanline_bitmap_mode4_normal(u32 start, u32 end, void *scanline);
-void render_scanline_bitmap_mode5_normal(u32 start, u32 end, void *scanline);
-void render_scanline_obj_normal_1D(u32 priority, u32 start, u32 end, render_scanline_dest_normal *scanline);
-void render_scanline_obj_normal_2D(u32 priority, u32 start, u32 end, render_scanline_dest_normal *scanline);
-void render_scanline_obj_color16_1D(u32 priority, u32 start, u32 end, render_scanline_dest_color16 *scanline);
-void render_scanline_obj_color16_2D(u32 priority, u32 start, u32 end, render_scanline_dest_color16 *scanline);
-void render_scanline_obj_color32_1D(u32 priority, u32 start, u32 end, render_scanline_dest_color32 *scanline);
-void render_scanline_obj_color32_2D(u32 priority, u32 start, u32 end, render_scanline_dest_color32 *scanline);
-void render_scanline_obj_alpha_obj_1D(u32 priority, u32 start, u32 end, render_scanline_dest_alpha_obj *scanline);
-void render_scanline_obj_alpha_obj_2D(u32 priority, u32 start, u32 end, render_scanline_dest_alpha_obj *scanline);
-void render_scanline_obj_partial_alpha_1D(u32 priority, u32 start, u32 end, render_scanline_dest_partial_alpha *scanline);
-void render_scanline_obj_partial_alpha_2D(u32 priority, u32 start, u32 end, render_scanline_dest_partial_alpha *scanline);
-void render_scanline_obj_copy_tile_1D(u32 priority, u32 start, u32 end, render_scanline_dest_copy_tile *scanline);
-void render_scanline_obj_copy_tile_2D(u32 priority, u32 start, u32 end, render_scanline_dest_copy_tile *scanline);
-void render_scanline_obj_copy_bitmap_1D(u32 priority, u32 start, u32 end, render_scanline_dest_copy_bitmap *scanline);
-void render_scanline_obj_copy_bitmap_2D(u32 priority, u32 start, u32 end, render_scanline_dest_copy_bitmap *scanline);
-void order_obj(u32 video_mode);
-void order_layers(u32 layer_flags);
-void fill_line_normal(u16 color, render_scanline_dest_normal *dest_ptr, u32 start, u32 end);
-void fill_line_alpha(u16 color, render_scanline_dest_alpha *dest_ptr, u32 start, u32 end);
-void fill_line_color16(u16 color, render_scanline_dest_color16 *dest_ptr, u32 start, u32 end);
-void fill_line_color32(u16 color, render_scanline_dest_color32 *dest_ptr, u32 start, u32 end);
-void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,u32 start, u32 end);
-void expand_darken(u16 *screen_src_ptr, u16 *screen_dest_ptr,u32 start, u32 end);
-void expand_brighten(u16 *screen_src_ptr, u16 *screen_dest_ptr, u32 start, u32 end);
-void expand_darken_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr, u32 start, u32 end);
-void expand_brighten_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr, u32 start, u32 end);
-void render_scanline_tile(u16 *scanline, u32 dispcnt);
-void render_scanline_bitmap(u16 *scanline, u32 dispcnt);
-void render_scanline_window_tile(u16 *scanline, u32 dispcnt);
-void render_scanline_window_bitmap(u16 *scanline, u32 dispcnt);
-
-
+static u32 __attribute__((aligned(16))) display_list[32];
 
 #define GBA_SCREEN_WIDTH 240
 #define GBA_SCREEN_HEIGHT 160
@@ -107,33 +49,26 @@
 #define PSP_SCREEN_HEIGHT 272
 #define PSP_LINE_SIZE 512
 
-#define PSP_ALL_BUTTON_MASK 0xFFFF
-
-#define GE_CMD_FBP    0x9C
-#define GE_CMD_FBW    0x9D
-#define GE_CMD_TBP0   0xA0
-#define GE_CMD_TBW0   0xA8
-#define GE_CMD_TSIZE0 0xB8
-#define GE_CMD_TFLUSH 0xCB
-#define GE_CMD_CLEAR  0xD3
-#define GE_CMD_VTYPE  0x12
-#define GE_CMD_BASE   0x10
-#define GE_CMD_VADDR  0x01
-#define GE_CMD_IADDR  0x02
-#define GE_CMD_PRIM   0x04
+#define GE_CMD_FBP    0x9C  /* Frame Buffer */
+#define GE_CMD_FBW    0x9D  /* Frame Buffer Width */
+#define GE_CMD_TBP0   0xA0  /* Texture Base Pointer (Mipmap level 0) */
+#define GE_CMD_TBW0   0xA8  /* Texture Buffer Width (Mipmap level 0) */
+#define GE_CMD_TSIZE0 0xB8  /* Texture Size (Mipmap level 0) */
+#define GE_CMD_TFLUSH 0xCB  /* Texture Flush */
+#define GE_CMD_CLEAR  0xD3  /* Clear Flags */
+#define GE_CMD_VTYPE  0x12  /* Vertex Type */
+#define GE_CMD_BASE   0x10  /* Base Address Register */
+#define GE_CMD_VADDR  0x01  /* Vertex List (BASE) */
+#define GE_CMD_IADDR  0x02  /* Index List (BASE) */
+#define GE_CMD_PRIM   0x04  /* Primitive Kick */
 #define GE_CMD_FINISH 0x0F
-#define GE_CMD_SIGNAL 0x0C
-#define GE_CMD_NOP    0x00
+#define GE_CMD_SIGNAL 0x0C  /* Raise Signal Interrupt */
+#define GE_CMD_NOP    0x00  /* No Operation */
 
 #define GE_CMD(cmd, operand)                                                \
   *ge_cmd_ptr = (((GE_CMD_##cmd) << 24) | (operand));                       \
   ge_cmd_ptr++                                                              \
 
-static u16 *screen_texture = (u16 *)(0x4000000 + (512 * 272 * 2));
-//static u16 *current_screen_texture = (u16 *)(0x4000000 + (512 * 272 * 2));
-static u16 *screen_pixels = (u16 *)(0x4000000 + (512 * 272 * 2));
-static u32 screen_pitch = 240;
-
 static void Ge_Finish_Callback(int id, void *arg)
 {
 }
@@ -144,12 +79,105 @@
 #define get_screen_pitch()                                                    \
   screen_pitch                                                                \
 
-void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
- u32 enable_flags, u32 dispcnt, u32 bldcnt, tile_layer_render_struct
- *layer_renderers);
-void render_scanline_conditional_bitmap(u32 start, u32 end, u16 *scanline,
- u32 enable_flags, u32 dispcnt, u32 bldcnt, bitmap_layer_render_struct
- *layer_renderers);
+static void render_scanline_text_base_normal(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_transparent_normal(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_base_color16(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_transparent_color16(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_base_color32(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_transparent_color32(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_base_alpha(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_text_transparent_alpha(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_base_normal(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_transparent_normal(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_base_color16(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_transparent_color16(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_base_color32(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_transparent_color32(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_base_alpha(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_affine_transparent_alpha(u32 layer,
+ u32 start, u32 end, void *scanline);
+static void render_scanline_bitmap_mode3_normal(u32 start, u32 end,
+ void *scanline);
+static void render_scanline_bitmap_mode4_normal(u32 start, u32 end,
+ void *scanline);
+static void render_scanline_bitmap_mode5_normal(u32 start, u32 end,
+ void *scanline);
+static void render_scanline_obj_normal_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_normal *scanline);
+static void render_scanline_obj_normal_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_normal *scanline);
+static void render_scanline_obj_color16_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_color16 *scanline);
+static void render_scanline_obj_color16_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_color16 *scanline);
+static void render_scanline_obj_color32_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_color32 *scanline);
+static void render_scanline_obj_color32_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_color32 *scanline);
+static void render_scanline_obj_alpha_obj_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_alpha_obj *scanline);
+static void render_scanline_obj_alpha_obj_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_alpha_obj *scanline);
+static void render_scanline_obj_partial_alpha_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_partial_alpha *scanline);
+static void render_scanline_obj_partial_alpha_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_partial_alpha *scanline);
+static void render_scanline_obj_copy_tile_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_copy_tile *scanline);
+static void render_scanline_obj_copy_tile_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_copy_tile *scanline);
+static void render_scanline_obj_copy_bitmap_1D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_copy_bitmap *scanline);
+static void render_scanline_obj_copy_bitmap_2D(u32 priority, u32 start, u32 end,
+ render_scanline_dest_copy_bitmap *scanline);
+static void fill_line_normal(u16 color, render_scanline_dest_normal *dest_ptr,
+ u32 start, u32 end);
+static void fill_line_alpha(u16 color, render_scanline_dest_alpha *dest_ptr,
+ u32 start, u32 end);
+static void fill_line_color16(u16 color, render_scanline_dest_color16 *dest_ptr,
+ u32 start, u32 end);
+static void fill_line_color32(u16 color, render_scanline_dest_color32 *dest_ptr,
+ u32 start, u32 end);
+static void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+ u32 start, u32 end);
+static void expand_darken(u16 *screen_src_ptr, u16 *screen_dest_ptr,
+ u32 start, u32 end);
+static void expand_brighten(u16 *screen_src_ptr, u16 *screen_dest_ptr,
+ u32 start, u32 end);
+static void expand_darken_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+ u32 start, u32 end);
+static void expand_brighten_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+ u32 start, u32 end);
+static void render_scanline_tile(u16 *scanline, u32 dispcnt);
+static void render_scanline_bitmap(u16 *scanline, u32 dispcnt);
+static void render_scanline_window_tile(u16 *scanline, u32 dispcnt);
+static void render_scanline_window_bitmap(u16 *scanline, u32 dispcnt);
+
+static void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
+ u32 enable_flags, u32 dispcnt, u32 bldcnt,
+ TILE_LAYER_RENDER_STRUCT *layer_renderers);
+static void render_scanline_conditional_bitmap(u32 start, u32 end, u16 *scanline,
+ u32 enable_flags, u32 dispcnt, u32 bldcnt,
+ BITMAP_LAYER_RENDER_STRUCT *layer_renderers);
+
+static void order_obj(u32 video_mode);
+static void order_layers(u32 layer_flags);
+
 
 #define no_op                                                                 \
 
@@ -158,26 +186,22 @@
 // version (without conversion) is much faster.
 
 #define tile_lookup_palette_full(palette, source)                             \
-  current_pixel = palette[source];                                            \
-  CONVERT_PALETTE(current_pixel)                                              \
+  current_pixel = palette[source]                                             \
 
 #define tile_lookup_palette(palette, source)                                  \
-  current_pixel = palette[source];                                            \
-
-
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_expand_base_normal(index)                                        \
-  tile_expand_base_color16(index)                                             \
+  current_pixel = palette[source]                                             \
 
-#else
+#define tile_expand_base_normal_mode4(index)                                  \
+  tile_lookup_palette(palette, current_pixel);                                \
+  if(current_pixel)                                                           \
+  {                                                                           \
+    dest_ptr[index] = current_pixel;                                          \
+  }                                                                           \
 
 #define tile_expand_base_normal(index)                                        \
   tile_lookup_palette(palette, current_pixel);                                \
   dest_ptr[index] = current_pixel                                             \
 
-#endif
-
 #define tile_expand_transparent_normal(index)                                 \
   tile_expand_base_normal(index)                                              \
 
@@ -316,7 +340,7 @@
 
 #define get_tile_8bpp()                                                       \
   current_tile = *map_ptr;                                                    \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 64)                        \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) << 6)                        \
 
 
 // Draw half of a tile in 8bpp mode, for base renderer
@@ -376,13 +400,13 @@
   if(partial_tile_offset >= 4)                                                \
   {                                                                           \
     current_pixels = *((u32 *)(tile_ptr + 4)) >>                              \
-     ((partial_tile_offset - 4) * 8);                                         \
+     ((partial_tile_offset - 4) << 3);                                        \
     partial_tile_8bpp(combine_op, alpha_op);                                  \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     partial_tile_run -= 4;                                                    \
-    current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset * 8);         \
+    current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset << 3);        \
     partial_tile_8bpp(combine_op, alpha_op);                                  \
     current_pixels = *((u32 *)(tile_ptr + 4));                                \
     tile_8bpp_draw_four_##combine_op(0, alpha_op, noflip);                    \
@@ -397,12 +421,12 @@
   if(partial_tile_offset >= 4)                                                \
   {                                                                           \
     current_pixels = *((u32 *)(tile_ptr + 4)) >>                              \
-     ((partial_tile_offset - 4) * 8);                                         \
+     ((partial_tile_offset - 4) << 3);                                        \
     partial_tile_8bpp(combine_op, alpha_op);                                  \
   }                                                                           \
   else                                                                        \
   {                                                                           \
-    current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset * 8);         \
+    current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset << 3);        \
     if((partial_tile_offset + partial_tile_run) > 4)                          \
     {                                                                         \
       u32 old_run = partial_tile_run;                                         \
@@ -431,7 +455,6 @@
     tile_ptr += 4;                                                            \
     partial_tile_run -= 4;                                                    \
   }                                                                           \
-                                                                              \
   current_pixels = *((u32 *)(tile_ptr));                                      \
   partial_tile_8bpp(combine_op, alpha_op)                                     \
 
@@ -458,14 +481,14 @@
 #define partial_tile_right_flip_8bpp(combine_op, alpha_op)                    \
   if(partial_tile_offset >= 4)                                                \
   {                                                                           \
-    current_pixels = *((u32 *)tile_ptr) << ((partial_tile_offset - 4) * 8);   \
+    current_pixels = *((u32 *)tile_ptr) << ((partial_tile_offset - 4) << 3);  \
     partial_tile_flip_8bpp(combine_op, alpha_op);                             \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     partial_tile_run -= 4;                                                    \
     current_pixels = *((u32 *)(tile_ptr + 4)) <<                              \
-     ((partial_tile_offset - 4) * 8);                                         \
+     ((partial_tile_offset - 4) << 3);                                        \
     partial_tile_flip_8bpp(combine_op, alpha_op);                             \
     current_pixels = *((u32 *)tile_ptr);                                      \
     tile_8bpp_draw_four_##combine_op(0, alpha_op, flip);                      \
@@ -475,13 +498,13 @@
 #define partial_tile_mid_flip_8bpp(combine_op, alpha_op)                      \
   if(partial_tile_offset >= 4)                                                \
   {                                                                           \
-    current_pixels = *((u32 *)tile_ptr) << ((partial_tile_offset - 4) * 8);   \
+    current_pixels = *((u32 *)tile_ptr) << ((partial_tile_offset - 4) << 3);  \
     partial_tile_flip_8bpp(combine_op, alpha_op);                             \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     current_pixels = *((u32 *)(tile_ptr + 4)) <<                              \
-     ((partial_tile_offset - 4) * 8);                                         \
+     ((partial_tile_offset - 4) << 3);                                        \
                                                                               \
     if((partial_tile_offset + partial_tile_run) > 4)                          \
     {                                                                         \
@@ -507,7 +530,6 @@
     tile_ptr -= 4;                                                            \
     partial_tile_run -= 4;                                                    \
   }                                                                           \
-                                                                              \
   current_pixels = *((u32 *)(tile_ptr + 4));                                  \
   partial_tile_flip_8bpp(combine_op, alpha_op)                                \
 
@@ -621,20 +643,10 @@
 // Draws eight background pixels for the normal renderer, just a bunch of
 // zeros.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_4bpp_draw_eight_base_zero_normal()                               \
-  current_pixel = 0;                                                          \
-  tile_4bpp_draw_eight_base_zero(current_pixel)                               \
-
-#else
-
 #define tile_4bpp_draw_eight_base_zero_normal()                               \
   current_pixel = palette[0];                                                 \
   tile_4bpp_draw_eight_base_zero(current_pixel)                               \
 
-#endif
-
 
 // Draws eight 4bpp pixels.
 
@@ -698,7 +710,7 @@
 #define get_tile_4bpp()                                                       \
   current_tile = *map_ptr;                                                    \
   current_palette = (current_tile >> 12) << 4;                                \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32);                       \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) << 5)                        \
 
 
 // Helper macro for drawing clipped 4bpp tiles.
@@ -717,7 +729,7 @@
 // how many to draw.
 
 #define partial_tile_right_noflip_4bpp(combine_op, alpha_op)                  \
-  current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset * 4);           \
+  current_pixels = *((u32 *)tile_ptr) >> (partial_tile_offset << 2);          \
   partial_tile_4bpp(combine_op, alpha_op)                                     \
 
 
@@ -752,7 +764,7 @@
   }                                                                           \
 
 #define partial_tile_right_flip_4bpp(combine_op, alpha_op)                    \
-  current_pixels = *((u32 *)tile_ptr) << (partial_tile_offset * 4);           \
+  current_pixels = *((u32 *)tile_ptr) << (partial_tile_offset << 2);          \
   partial_tile_flip_4bpp(combine_op, alpha_op)                                \
 
 #define partial_tile_mid_flip_4bpp(combine_op, alpha_op)                      \
@@ -773,7 +785,9 @@
 #define single_tile_map(tile_type, combine_op, color_depth, alpha_op)         \
   get_tile_##color_depth();                                                   \
   if(current_tile & 0x800)                                                    \
+  {                                                                           \
     tile_ptr += vertical_pixel_flip;                                          \
+  }                                                                           \
                                                                               \
   if(current_tile & 0x400)                                                    \
   {                                                                           \
@@ -890,8 +904,8 @@
 
 #define tile_render(color_depth, combine_op, alpha_op)                        \
 {                                                                             \
-  u32 vertical_pixel_offset = (vertical_offset % 8) *                         \
-   tile_width_##color_depth;                                                  \
+  u32 vertical_pixel_offset =                                                 \
+   (vertical_offset % 8) * tile_width_##color_depth;                          \
   u32 vertical_pixel_flip =                                                   \
    ((tile_size_##color_depth - tile_width_##color_depth) -                    \
    vertical_pixel_offset) - vertical_pixel_offset;                            \
@@ -901,7 +915,7 @@
   u32 pixel_run = 256 - (horizontal_offset % 256);                            \
   u32 current_tile;                                                           \
                                                                               \
-  map_base += ((vertical_offset % 256) / 8) * 32;                             \
+  map_base += ((vertical_offset % 256) >> 3) << 5;                            \
   partial_tile_offset = (horizontal_offset % 8);                              \
                                                                               \
   if(pixel_run >= end)                                                        \
@@ -922,7 +936,7 @@
       }                                                                       \
     }                                                                         \
                                                                               \
-    tile_run = end / 8;                                                       \
+    tile_run = end >> 3;                                                      \
     multiple_tile_map(combine_op, color_depth, alpha_op);                     \
                                                                               \
     partial_tile_run = end % 8;                                               \
@@ -940,11 +954,11 @@
       partial_tile_right_map(combine_op, color_depth, alpha_op);              \
     }                                                                         \
                                                                               \
-    tile_run = (pixel_run - partial_tile_run) / 8;                            \
+    tile_run = (pixel_run - partial_tile_run) >> 3;                           \
     multiple_tile_map(combine_op, color_depth, alpha_op);                     \
     map_ptr = second_ptr;                                                     \
     end -= pixel_run;                                                         \
-    tile_run = end / 8;                                                       \
+    tile_run = end >> 3;                                                      \
     multiple_tile_map(combine_op, color_depth, alpha_op);                     \
                                                                               \
     partial_tile_run = end % 8;                                               \
@@ -967,18 +982,8 @@
   }                                                                           \
 
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_extra_variables_base_normal(bg_type)                  \
-  const u32 pixel_combine = 0                                                 \
-
-#else
-
 #define render_scanline_extra_variables_base_normal(bg_type)                  \
-  u16 *palette = palette_ram_converted                                        \
-
-#endif
-
+  u16 *palette = palette_ram                                                  \
 
 #define render_scanline_extra_variables_base_alpha(bg_type)                   \
   u32 bg_combine = color_combine_mask(5);                                     \
@@ -1013,18 +1018,15 @@
   render_scanline_extra_variables_transparent_color()                         \
 
 
-
-
-
 // Map widths and heights
 
-u32 map_widths[] = { 256, 512, 256, 512 };
-u32 map_heights[] = { 256, 256, 512, 512 };
+static const u32 map_widths[] = { 256, 512, 256, 512 };
+// static const u32 map_heights[] = { 256, 256, 512, 512 };
 
 // Build text scanline rendering functions.
 
 #define render_scanline_text_builder(combine_op, alpha_op)                    \
-void render_scanline_text_##combine_op##_##alpha_op(u32 layer,                \
+static void render_scanline_text_##combine_op##_##alpha_op(u32 layer,         \
  u32 start, u32 end, void *scanline)                                          \
 {                                                                             \
   render_scanline_extra_variables_##combine_op##_##alpha_op(text);            \
@@ -1045,7 +1047,7 @@
   render_scanline_dest_##alpha_op *dest_ptr =                                 \
    ((render_scanline_dest_##alpha_op *)scanline) + start;                     \
                                                                               \
-  u16 *map_base = (u16 *)(vram + ((bg_control >> 8) & 0x1F) * (1024 * 2));    \
+  u16 *map_base = (u16 *)(vram + ((bg_control >> 8) & 0x1F) * (1024 << 1));   \
   u16 *map_ptr, *second_ptr;                                                  \
   u8 *tile_ptr;                                                               \
                                                                               \
@@ -1053,12 +1055,12 @@
                                                                               \
   if((map_size & 0x02) && (vertical_offset >= 256))                           \
   {                                                                           \
-    map_base += ((map_width / 8) * 32) +                                      \
-     (((vertical_offset - 256) / 8) * 32);                                    \
+    map_base +=                                                               \
+     (((map_width >> 3) << 5) + (((vertical_offset - 256) >> 3) << 5));       \
   }                                                                           \
   else                                                                        \
   {                                                                           \
-    map_base += (((vertical_offset % 256) / 8) * 32);                         \
+    map_base += (((vertical_offset % 256) >> 3) << 5);                        \
   }                                                                           \
                                                                               \
   if(map_size & 0x01)                                                         \
@@ -1066,19 +1068,19 @@
     if(horizontal_offset >= 256)                                              \
     {                                                                         \
       horizontal_offset -= 256;                                               \
-      map_ptr = map_base + (32 * 32) + (horizontal_offset / 8);               \
+      map_ptr = map_base + 1024 + (horizontal_offset >> 3);                   \
       second_ptr = map_base;                                                  \
     }                                                                         \
     else                                                                      \
     {                                                                         \
-      map_ptr = map_base + (horizontal_offset / 8);                           \
-      second_ptr = map_base + (32 * 32);                                      \
+      map_ptr = map_base + (horizontal_offset >> 3);                          \
+      second_ptr = map_base + 1024;                                           \
     }                                                                         \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     horizontal_offset %= 256;                                                 \
-    map_ptr = map_base + (horizontal_offset / 8);                             \
+    map_ptr = map_base + (horizontal_offset >> 3);                            \
     second_ptr = map_base;                                                    \
   }                                                                           \
                                                                               \
@@ -1106,7 +1108,7 @@
 s32 affine_reference_y[2];
 
 #define affine_render_bg_pixel_normal()                                       \
-  current_pixel = palette_ram_converted[0]                                    \
+  current_pixel = palette_ram[0]                                              \
 
 #define affine_render_bg_pixel_alpha()                                        \
   current_pixel = bg_combine                                                  \
@@ -1149,24 +1151,24 @@
   advance_dest_ptr_##combine_op(1)                                            \
 
 #define affine_render_scale_offset()                                          \
-  tile_base += ((pixel_y % 8) * 8);                                           \
-  map_base += (pixel_y / 8) << map_pitch                                      \
+  tile_base += ((pixel_y % 8) << 3);                                          \
+  map_base += ((pixel_y >> 3) << map_pitch)                                   \
 
 #define affine_render_scale_pixel(combine_op, alpha_op)                       \
-  map_offset = (pixel_x / 8);                                                 \
+  map_offset = (pixel_x >> 3);                                                \
   if(map_offset != last_map_offset)                                           \
   {                                                                           \
-    tile_ptr = tile_base + (map_base[map_offset] * 64);                       \
+    tile_ptr = tile_base + (map_base[map_offset] << 6);                       \
     last_map_offset = map_offset;                                             \
   }                                                                           \
-  tile_ptr = tile_base + (map_base[(pixel_x / 8)] * 64);                      \
+  tile_ptr = tile_base + (map_base[(pixel_x >> 3)] << 6);                      \
   current_pixel = tile_ptr[(pixel_x % 8)];                                    \
   tile_8bpp_draw_##combine_op(0, none, 0, alpha_op);                          \
   affine_render_next(combine_op)                                              \
 
 #define affine_render_scale(combine_op, alpha_op)                             \
 {                                                                             \
-  pixel_y = source_y >> 8;                                                    \
+  pixel_y = (source_y >> 8);                                                  \
   u32 i = 0;                                                                  \
   affine_render_bg_pixel_##combine_op(alpha_op);                              \
   if((u32)pixel_y < (u32)width_height)                                        \
@@ -1174,7 +1176,7 @@
     affine_render_scale_offset();                                             \
     for(; i < end; i++)                                                       \
     {                                                                         \
-      pixel_x = source_x >> 8;                                                \
+      pixel_x = (source_x >> 8);                                              \
                                                                               \
       if((u32)pixel_x < (u32)width_height)                                    \
       {                                                                       \
@@ -1187,10 +1189,12 @@
                                                                               \
     for(; i < end; i++)                                                       \
     {                                                                         \
-      pixel_x = source_x >> 8;                                                \
+      pixel_x = (source_x >> 8);                                              \
                                                                               \
       if((u32)pixel_x >= (u32)width_height)                                   \
+      {                                                                       \
         break;                                                                \
+      }                                                                       \
                                                                               \
       affine_render_scale_pixel(combine_op, alpha_op);                        \
     }                                                                         \
@@ -1215,14 +1219,14 @@
 
 
 #define affine_render_rotate_pixel(combine_op, alpha_op)                      \
-  map_offset = (pixel_x / 8) + ((pixel_y / 8) << map_pitch);                  \
+  map_offset = (pixel_x >> 3) + ((pixel_y >> 3) << map_pitch);                \
   if(map_offset != last_map_offset)                                           \
   {                                                                           \
-    tile_ptr = tile_base + (map_base[map_offset] * 64);                       \
+    tile_ptr = tile_base + (map_base[map_offset] << 6);                       \
     last_map_offset = map_offset;                                             \
   }                                                                           \
                                                                               \
-  current_pixel = tile_ptr[(pixel_x % 8) + ((pixel_y % 8) * 8)];              \
+  current_pixel = tile_ptr[(pixel_x % 8) + ((pixel_y % 8) << 3)];             \
   tile_8bpp_draw_##combine_op(0, none, 0, alpha_op);                          \
   affine_render_next(combine_op)                                              \
 
@@ -1231,8 +1235,8 @@
   affine_render_bg_pixel_##combine_op(alpha_op);                              \
   for(i = 0; i < end; i++)                                                    \
   {                                                                           \
-    pixel_x = source_x >> 8;                                                  \
-    pixel_y = source_y >> 8;                                                  \
+    pixel_x = (source_x >> 8);                                                \
+    pixel_y = (source_y >> 8);                                                \
                                                                               \
     if(((u32)pixel_x < (u32)width_height) &&                                  \
      ((u32)pixel_y < (u32)width_height))                                      \
@@ -1245,8 +1249,8 @@
                                                                               \
   for(; i < end; i++)                                                         \
   {                                                                           \
-    pixel_x = source_x >> 8;                                                  \
-    pixel_y = source_y >> 8;                                                  \
+    pixel_x = (source_x >> 8);                                                \
+    pixel_y = (source_y >> 8);                                                \
                                                                               \
     if(((u32)pixel_x >= (u32)width_height) ||                                 \
      ((u32)pixel_y >= (u32)width_height))                                     \
@@ -1275,7 +1279,7 @@
 // Build affine background renderers.
 
 #define render_scanline_affine_builder(combine_op, alpha_op)                  \
-void render_scanline_affine_##combine_op##_##alpha_op(u32 layer,              \
+static void render_scanline_affine_##combine_op##_##alpha_op(u32 layer,       \
  u32 start, u32 end, void *scanline)                                          \
 {                                                                             \
   render_scanline_extra_variables_##combine_op##_##alpha_op(affine);          \
@@ -1335,11 +1339,10 @@
 
 
 #define bitmap_render_pixel_mode3(alpha_op)                                   \
-  CONVERT_PALETTE(current_pixel);                                             \
   *dest_ptr = current_pixel                                                   \
 
 #define bitmap_render_pixel_mode4(alpha_op)                                   \
-  tile_expand_base_##alpha_op(0)                                              \
+  tile_expand_base_##alpha_op##_mode4(0)                                      \
 
 #define bitmap_render_pixel_mode5(alpha_op)                                   \
   bitmap_render_pixel_mode3(alpha_op)                                         \
@@ -1360,14 +1363,15 @@
         pixel_x = 0;                                                          \
       }                                                                       \
       else                                                                    \
-                                                                              \
       if(pixel_x > 0)                                                         \
       {                                                                       \
         src_ptr += pixel_x;                                                   \
       }                                                                       \
                                                                               \
       if((pixel_x + end) >= width)                                            \
+      {                                                                       \
         end = (width - pixel_x);                                              \
+      }                                                                       \
                                                                               \
       for(i = 0; (s32)i < (s32)end; i++)                                      \
       {                                                                       \
@@ -1386,8 +1390,9 @@
           pixel_x = (source_x >> 8);                                          \
                                                                               \
           if((u32)pixel_x < (u32)width)                                       \
+          {                                                                   \
             break;                                                            \
-                                                                              \
+          }                                                                   \
           source_x += dx;                                                     \
           dest_ptr++;                                                         \
         }                                                                     \
@@ -1397,8 +1402,9 @@
           pixel_x = (source_x >> 8);                                          \
                                                                               \
           if((u32)pixel_x >= (u32)width)                                      \
+          {                                                                   \
             break;                                                            \
-                                                                              \
+          }                                                                   \
           current_pixel = src_ptr[pixel_x];                                   \
           bitmap_render_pixel_##type(alpha_op);                               \
                                                                               \
@@ -1412,12 +1418,13 @@
 #define bitmap_render_rotate(type, alpha_op, width, height)                   \
   for(i = 0; i < end; i++)                                                    \
   {                                                                           \
-    pixel_x = source_x >> 8;                                                  \
-    pixel_y = source_y >> 8;                                                  \
+    pixel_x = (source_x >> 8);                                                \
+    pixel_y = (source_y >> 8);                                                \
                                                                               \
     if(((u32)pixel_x < (u32)width) && ((u32)pixel_y < (u32)height))           \
+    {                                                                         \
       break;                                                                  \
-                                                                              \
+    }                                                                         \
     source_x += dx;                                                           \
     source_y += dy;                                                           \
     dest_ptr++;                                                               \
@@ -1429,8 +1436,9 @@
     pixel_y = (source_y >> 8);                                                \
                                                                               \
     if(((u32)pixel_x >= (u32)width) || ((u32)pixel_y >= (u32)height))         \
+    {                                                                         \
       break;                                                                  \
-                                                                              \
+    }                                                                         \
     current_pixel = src_ptr[pixel_x + (pixel_y * width)];                     \
      bitmap_render_pixel_##type(alpha_op);                                    \
                                                                               \
@@ -1443,43 +1451,34 @@
 #define render_scanline_vram_setup_mode3()                                    \
   u16 *src_ptr = (u16 *)vram                                                  \
 
-#define render_scanline_vram_setup_mode5()                                    \
-  u16 *src_ptr;                                                               \
-  if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u16 *)(vram + 0xA000);                                         \
-  else                                                                        \
-    src_ptr = (u16 *)vram                                                     \
-
-
-#ifdef RENDER_COLOR16_NORMAL
-
 #define render_scanline_vram_setup_mode4()                                    \
-  const u32 pixel_combine = 0;                                                \
+  u16 *palette = palette_ram;                                                 \
   u8 *src_ptr;                                                                \
   if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
+  {                                                                           \
+    src_ptr = vram + 0xA000;                                                  \
+  }                                                                           \
   else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-
-#else
+  {                                                                           \
+    src_ptr = vram;                                                           \
+  }                                                                           \
 
-#define render_scanline_vram_setup_mode4()                                    \
-  u16 *palette = palette_ram_converted;                                       \
-  u8 *src_ptr;                                                                \
+#define render_scanline_vram_setup_mode5()                                    \
+  u16 *src_ptr;                                                               \
   if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
+  {                                                                           \
+    src_ptr = (u16 *)(vram + 0xA000);                                         \
+  }                                                                           \
   else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-#endif
-
+  {                                                                           \
+    src_ptr = (u16 *)vram;                                                    \
+  }                                                                           \
 
 
 // Build bitmap scanline rendering functions.
 
 #define render_scanline_bitmap_builder(type, alpha_op, width, height)         \
-void render_scanline_bitmap_##type##_##alpha_op(u32 start, u32 end,           \
+static void render_scanline_bitmap_##type##_##alpha_op(u32 start, u32 end,    \
  void *scanline)                                                              \
 {                                                                             \
   /*u32 bg_control = io_registers[REG_BG2CNT];*/                                  \
@@ -1584,30 +1583,31 @@
 #define obj_tile_offset_noflip(color_depth)                                   \
 
 #define obj_tile_offset_flip(color_depth)                                     \
-  + (tile_size_##color_depth * ((obj_width - 8) / 8))                         \
+  + (tile_size_##color_depth * ((obj_width - 8) >> 3))                        \
 
 
-// Adjust the obj's starting point if it goes too far off the left edge of the screen.
+// Adjust the obj's starting point if it goes too far off the left edge of
+// the screen.
 
 #define obj_tile_right_offset_noflip(color_depth)                             \
-  tile_ptr += (partial_tile_offset / 8) * tile_size_##color_depth             \
+  tile_ptr += ((partial_tile_offset >> 3) * tile_size_##color_depth)          \
 
 #define obj_tile_right_offset_flip(color_depth)                               \
-  tile_ptr -= (partial_tile_offset / 8) * tile_size_##color_depth             \
+  tile_ptr -= ((partial_tile_offset >> 3) * tile_size_##color_depth)          \
 
 // Get the current row offset into an obj in 1D map space
 
 #define obj_tile_offset_1D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
-   + ((vertical_offset / 8) * (obj_width / 8) * tile_size_##color_depth)      \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
+   + ((vertical_offset >> 3) * (obj_width >> 3) * tile_size_##color_depth)    \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
 
 // Get the current row offset into an obj in 2D map space
 
 #define obj_tile_offset_2D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
-   + ((vertical_offset / 8) * 1024)                                           \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
+   + ((vertical_offset >> 3) << 10)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
 
@@ -1660,13 +1660,12 @@
              flip_op);                                                        \
           }                                                                   \
         }                                                                     \
-        tile_run = pixel_run / 8;                                             \
+        tile_run = pixel_run >> 3;                                            \
         multiple_tile_obj(combine_op, color_depth, alpha_op, flip_op);        \
         partial_tile_run = pixel_run % 8;                                     \
         if(partial_tile_run)                                                  \
         {                                                                     \
-          partial_tile_left_obj(combine_op, color_depth, alpha_op,            \
-           flip_op);                                                          \
+          partial_tile_left_obj(combine_op, color_depth, alpha_op, flip_op);  \
         }                                                                     \
       }                                                                       \
       else                                                                    \
@@ -1677,10 +1676,9 @@
         if(partial_tile_offset)                                               \
         {                                                                     \
           partial_tile_run = 8 - partial_tile_offset;                         \
-          partial_tile_right_obj(combine_op, color_depth, alpha_op,           \
-           flip_op);                                                          \
+          partial_tile_right_obj(combine_op, color_depth, alpha_op, flip_op); \
         }                                                                     \
-        tile_run = pixel_run / 8;                                             \
+        tile_run = pixel_run >> 3;                                            \
         multiple_tile_obj(combine_op, color_depth, alpha_op, flip_op);        \
       }                                                                       \
     }                                                                         \
@@ -1693,7 +1691,7 @@
     if((s32)pixel_run > 0)                                                    \
     {                                                                         \
       dest_ptr = scanline + obj_x;                                            \
-      tile_run = pixel_run / 8;                                               \
+      tile_run = pixel_run >> 3;                                              \
       multiple_tile_obj(combine_op, color_depth, alpha_op, flip_op);          \
       partial_tile_run = pixel_run % 8;                                       \
       if(partial_tile_run)                                                    \
@@ -1705,21 +1703,21 @@
   else                                                                        \
   {                                                                           \
     dest_ptr = scanline + obj_x;                                              \
-    tile_run = obj_width / 8;                                                 \
+    tile_run = obj_width >> 3;                                                \
     multiple_tile_obj(combine_op, color_depth, alpha_op, flip_op);            \
   }                                                                           \
 }                                                                             \
 
 #define obj_scale_offset_1D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
-   + ((vertical_offset / 8) * (max_x / 8) * tile_size_##color_depth)          \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
+   + ((vertical_offset >> 3) * (max_x >> 3) * tile_size_##color_depth)        \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
 // Get the current row offset into an obj in 2D map space
 
 #define obj_scale_offset_2D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
-   + ((vertical_offset / 8) * 1024)                                           \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
+   + ((vertical_offset >> 3) << 10)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
 #define obj_render_scale_pixel_4bpp(combine_op, alpha_op)                     \
@@ -1738,7 +1736,7 @@
 
 #define obj_render_scale_pixel_8bpp(combine_op, alpha_op)                     \
   current_pixel = tile_ptr[tile_map_offset + (tile_x & 0x07)];                \
-  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op);                          \
+  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op)                           \
 
 #define obj_render_scale(combine_op, color_depth, alpha_op, map_space)        \
 {                                                                             \
@@ -1755,8 +1753,9 @@
       tile_x = (source_x >> 8);                                               \
                                                                               \
       if((u32)tile_x < (u32)max_x)                                            \
+      {                                                                       \
         break;                                                                \
-                                                                              \
+      }                                                                       \
       source_x += dx;                                                         \
       advance_dest_ptr_##combine_op(1);                                       \
     }                                                                         \
@@ -1766,8 +1765,9 @@
       tile_x = (source_x >> 8);                                               \
                                                                               \
       if((u32)tile_x >= (u32)max_x)                                           \
+      {                                                                       \
         break;                                                                \
-                                                                              \
+      }                                                                       \
       tile_map_offset = (tile_x >> 3) * tile_size_##color_depth;              \
       obj_render_scale_pixel_##color_depth(combine_op, alpha_op);             \
                                                                               \
@@ -1779,7 +1779,7 @@
 
 
 #define obj_rotate_offset_1D(color_depth)                                     \
-  obj_tile_pitch = (max_x / 8) * tile_size_##color_depth                      \
+  obj_tile_pitch = (max_x >> 3) * tile_size_##color_depth                     \
 
 #define obj_rotate_offset_2D(color_depth)                                     \
   obj_tile_pitch = 1024                                                       \
@@ -1806,11 +1806,11 @@
 
 #define obj_render_rotate(combine_op, color_depth, alpha_op, map_space)       \
 {                                                                             \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32);                    \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5);                    \
   obj_rotate_offset_##map_space(color_depth);                                 \
                                                                               \
-  source_x += (y_delta * dmx) - (middle_x * dx);                              \
-  source_y += (y_delta * dmy) - (middle_x * dy);                              \
+  source_x += ((y_delta * dmx) - (middle_x * dx));                            \
+  source_y += ((y_delta * dmy) - (middle_x * dy));                            \
                                                                               \
   for(i = 0; i < obj_width; i++)                                              \
   {                                                                           \
@@ -1818,8 +1818,9 @@
     tile_y = (source_y >> 8);                                                 \
                                                                               \
     if(((u32)tile_x < (u32)max_x) && ((u32)tile_y < (u32)max_y))              \
+    {                                                                         \
       break;                                                                  \
-                                                                              \
+    }                                                                         \
     source_x += dx;                                                           \
     source_y += dy;                                                           \
     advance_dest_ptr_##combine_op(1);                                         \
@@ -1831,8 +1832,9 @@
     tile_y = (source_y >> 8);                                                 \
                                                                               \
     if(((u32)tile_x >= (u32)max_x) || ((u32)tile_y >= (u32)max_y))            \
+    {                                                                         \
       break;                                                                  \
-                                                                              \
+    }                                                                         \
     tile_map_offset = ((tile_x >> 3) * tile_size_##color_depth) +             \
     ((tile_y >> 3) * obj_tile_pitch);                                         \
     obj_render_rotate_pixel_##color_depth(combine_op, alpha_op);              \
@@ -1864,8 +1866,8 @@
   u32 obj_pitch = tile_width_##color_depth;                                   \
   u32 obj_tile_pitch;                                                         \
                                                                               \
-  middle_x = (obj_width / 2);                                                 \
-  middle_y = (obj_height / 2);                                                \
+  middle_x = (obj_width >> 1);                                                \
+  middle_y = (obj_height >> 1);                                               \
                                                                               \
   source_x = (middle_x << 8);                                                 \
   source_y = (middle_y << 8);                                                 \
@@ -1873,10 +1875,10 @@
                                                                               \
   if(obj_attribute_0 & 0x200)                                                 \
   {                                                                           \
-    obj_width *= 2;                                                           \
-    obj_height *= 2;                                                          \
-    middle_x *= 2;                                                            \
-    middle_y *= 2;                                                            \
+    obj_width <<= 1;                                                          \
+    obj_height <<= 1;                                                         \
+    middle_x <<= 1;                                                           \
+    middle_y <<= 1;                                                           \
   }                                                                           \
                                                                               \
   if((s32)obj_x < (s32)start)                                                 \
@@ -1887,16 +1889,20 @@
     obj_x = start;                                                            \
                                                                               \
     if((s32)obj_width <= 0)                                                   \
+    {                                                                         \
       continue;                                                               \
   }                                                                           \
+  }                                                                           \
                                                                               \
   if((s32)(obj_x + obj_width) >= (s32)end)                                    \
   {                                                                           \
     obj_width = end - obj_x;                                                  \
                                                                               \
     if((s32)obj_width <= 0)                                                   \
+    {                                                                         \
       continue;                                                               \
   }                                                                           \
+  }                                                                           \
   dest_ptr = scanline + obj_x;                                                \
                                                                               \
   y_delta = vcount - (obj_y + middle_y);                                      \
@@ -1913,28 +1919,21 @@
   }                                                                           \
 }                                                                             \
 
-u32 obj_width_table[] = { 8, 16, 32, 64, 16, 32, 32, 64, 8, 8, 16, 32 };
-u32 obj_height_table[] = { 8, 16, 32, 64, 8, 8, 16, 32, 16, 32, 32, 64 };
-
-u8 obj_priority_list[5][160][128];
-u32 obj_priority_count[5][160];
-u32 obj_alpha_count[160];
+static const u32 obj_width_table[] =
+{ 8, 16, 32, 64, 16, 32, 32, 64, 8, 8, 16, 32 };
 
+static const u32 obj_height_table[] =
+{ 8, 16, 32, 64, 8, 8, 16, 32, 16, 32, 32, 64 };
 
-// Build obj rendering functions
-
-#ifdef RENDER_COLOR16_NORMAL
+static u8 obj_priority_list[5][160][128];
+static u32 obj_priority_count[5][160];
+static u32 obj_alpha_count[160];
 
-#define render_scanline_obj_extra_variables_normal(bg_type)                   \
-  const u32 pixel_combine = (1 << 8)                                          \
 
-#else
+// Build obj rendering functions
 
 #define render_scanline_obj_extra_variables_normal(bg_type)                   \
-  u16 *palette = palette_ram_converted + 256                                  \
-
-#endif
-
+  u16 *palette = palette_ram + 256                                            \
 
 #define render_scanline_obj_extra_variables_color()                           \
   u32 dest;                                                                   \
@@ -1994,7 +1993,9 @@
     vertical_offset = vcount - obj_y;                                         \
                                                                               \
     if((obj_attribute_1 >> 13) & 0x01)                                        \
+    {                                                                         \
       vertical_offset = obj_height - vertical_offset - 1;                     \
+    }                                                                         \
                                                                               \
     switch(((obj_attribute_0 >> 12) & 0x02) |                                 \
      ((obj_attribute_1 >> 12) & 0x01))                                        \
@@ -2037,14 +2038,22 @@
 #define render_scanline_obj_prologue_copy_body(type)                          \
   copy_start = obj_x;                                                         \
   if(obj_attribute_0 & 0x200)                                                 \
-    copy_end = obj_x + (obj_width * 2);                                       \
+  {                                                                           \
+    copy_end = obj_x + (obj_width << 1);                                      \
+  }                                                                           \
   else                                                                        \
+  {                                                                           \
     copy_end = obj_x + obj_width;                                             \
+  }                                                                           \
                                                                               \
   if(copy_start < start)                                                      \
+  {                                                                           \
     copy_start = start;                                                       \
+  }                                                                           \
   if(copy_end > end)                                                          \
+  {                                                                           \
     copy_end = end;                                                           \
+  }                                                                           \
                                                                               \
   if((copy_start < end) && (copy_end > start))                                \
   {                                                                           \
@@ -2069,7 +2078,7 @@
 
 #define render_scanline_obj_builder(combine_op, alpha_op, map_space,          \
  partial_alpha_op)                                                            \
-void render_scanline_obj_##alpha_op##_##map_space(u32 priority,               \
+static void render_scanline_obj_##alpha_op##_##map_space(u32 priority,        \
  u32 start, u32 end, render_scanline_dest_##alpha_op *scanline)               \
 {                                                                             \
   render_scanline_obj_extra_variables_##alpha_op(map_space);                  \
@@ -2095,7 +2104,7 @@
                                                                               \
   for(obj_num = 0; obj_num < obj_count; obj_num++)                            \
   {                                                                           \
-    oam_ptr = oam_ram + (obj_list[obj_num] * 4);                              \
+    oam_ptr = oam_ram + (obj_list[obj_num] << 2);                             \
     obj_attribute_0 = oam_ptr[0];                                             \
     obj_attribute_1 = oam_ptr[1];                                             \
     obj_attribute_2 = oam_ptr[2];                                             \
@@ -2109,8 +2118,9 @@
     obj_y = obj_attribute_0 & 0xFF;                                           \
                                                                               \
     if(obj_y > 160)                                                           \
+    {                                                                         \
       obj_y -= 256;                                                           \
-                                                                              \
+    }                                                                         \
     obj_height = obj_height_table[obj_size];                                  \
     render_scanline_obj_##partial_alpha_op(combine_op, alpha_op, map_space);  \
   }                                                                           \
@@ -2132,10 +2142,10 @@
 render_scanline_obj_builder(copy, copy_bitmap, 2D, no_partial_alpha);
 
 
-
-void order_obj(u32 video_mode)
+static void order_obj(u32 video_mode)
 {
-  s32 obj_num, /*priority,*/ row;
+//  s32 obj_num, priority, row; 
+  s32 obj_num, row;
   s32 obj_x, obj_y;
   s32 obj_size, obj_mode;
   s32 obj_width, obj_height;
@@ -2149,23 +2159,8 @@
 //  u16 *dest_ptr;
 //  u8 *tile_base = vram + 0x10000;
 //  u8 *tile_ptr;
-/*
-  for(priority = 0; priority < 5; priority++)
-  {
-    for(row = 0; row < 160; row++)
-    {
-      obj_priority_count[priority][row] = 0;
-    }
-  }
-*/
-  memset( obj_priority_count, 0, 5*160*4 );
 
-/*
-  for(row = 0; row < 160; row++)
-  {
-    obj_alpha_count[row] = 0;
-  }
-*/
+  memset(obj_priority_count, 0, 5 * 160 * 4);
   memset( obj_alpha_count, 0, 160*4 );
 
   for(obj_num = 127; obj_num >= 0; obj_num--, oam_ptr -= 4)
@@ -2173,12 +2168,10 @@
     obj_attribute_0 = oam_ptr[0];
     obj_attribute_2 = oam_ptr[2];
     obj_size = obj_attribute_0 & 0xC000;
-    obj_priority = (obj_attribute_2 >> 10) & 0x03;
     obj_mode = (obj_attribute_0 >> 10) & 0x03;
 
     if(((obj_attribute_0 & 0x0300) != 0x0200) && (obj_size != 0xC000) &&
-     (obj_mode != 3) && ((video_mode < 3) ||
-     ((obj_attribute_2 & 0x3FF) >= 512)))
+     (obj_mode != 3) && ((video_mode < 3) || ((obj_attribute_2 & 0x3FF) >= 512)))
     {
       obj_y = obj_attribute_0 & 0xFF;
       if(obj_y > 160)
@@ -2186,13 +2179,14 @@
 
       obj_attribute_1 = oam_ptr[1];
       obj_size = ((obj_size >> 12) & 0x0C) | (obj_attribute_1 >> 14);
+      obj_priority = (obj_attribute_2 >> 10) & 0x03;
       obj_height = obj_height_table[obj_size];
       obj_width = obj_width_table[obj_size];
 
       if(obj_attribute_0 & 0x200)
       {
-        obj_height *= 2;
-        obj_width *= 2;
+        obj_height <<= 1;
+        obj_width <<= 1;
       }
 
       if(((obj_y + obj_height) > 0) && (obj_y < 160))
@@ -2242,10 +2236,10 @@
   }
 }
 
-u32 layer_order[16];
-u32 layer_count;
+static u32 layer_order[16];
+static u32 layer_count;
 
-void order_layers(u32 layer_flags)
+static void order_layers(u32 layer_flags)
 {
   s32 priority, layer_number;
   layer_count = 0;
@@ -2281,7 +2275,7 @@
 
 
 #define fill_line_color_normal()                                              \
-  color = palette_ram_converted[color]                                        \
+  color = palette_ram[color]                                                  \
 
 #define fill_line_color_alpha()                                               \
 
@@ -2290,7 +2284,7 @@
 #define fill_line_color_color32()                                             \
 
 #define fill_line_builder(type)                                               \
-void fill_line_##type(u16 color, render_scanline_dest_##type *dest_ptr,       \
+static void fill_line_##type(u16 color, render_scanline_dest_##type *dest_ptr,\
  u32 start, u32 end)                                                          \
 {                                                                             \
   fill_line_color_##type();                                                   \
@@ -2306,8 +2300,8 @@
 // Alpha blend two pixels (pixel_top and pixel_bottom).
 
 #define blend_pixel()                                                         \
-  pixel_bottom = palette_ram_converted[(pixel_pair >> 16) & 0x1FF];           \
-  pixel_bottom = (pixel_bottom | (pixel_bottom << 16)) & 0x07E0F81F;          \
+  pixel_bottom = palette_ram[(pixel_pair >> 16) & 0x1FF];                     \
+  pixel_bottom = (pixel_bottom | (pixel_bottom << 16)) & 0x03E07C1F;          \
   pixel_top = ((pixel_top * blend_a) + (pixel_bottom * blend_b)) >> 4         \
 
 
@@ -2315,26 +2309,30 @@
 // The operation is optimized towards saturation not occuring.
 
 #define blend_saturate_pixel()                                                \
-  pixel_bottom = palette_ram_converted[(pixel_pair >> 16) & 0x1FF];           \
-  pixel_bottom = (pixel_bottom | (pixel_bottom << 16)) & 0x07E0F81F;          \
+  pixel_bottom = palette_ram[(pixel_pair >> 16) & 0x1FF];                     \
+  pixel_bottom = (pixel_bottom | (pixel_bottom << 16)) & 0x03E07C1F;          \
   pixel_top = ((pixel_top * blend_a) + (pixel_bottom * blend_b)) >> 4;        \
-  if(pixel_top & 0x08010020)                                                  \
+  if(pixel_top & 0x04008020)                                                  \
   {                                                                           \
-    if(pixel_top & 0x08000000)                                                \
-      pixel_top |= 0x07E00000;                                                \
-                                                                              \
-    if(pixel_top & 0x00010000)                                                \
-      pixel_top |= 0x0000F800;                                                \
-                                                                              \
+    if(pixel_top & 0x04000000)                                                \
+    {                                                                         \
+      pixel_top |= 0x03E00000;                                                \
+    }                                                                         \
+    if(pixel_top & 0x00008000)                                                \
+    {                                                                         \
+      pixel_top |= 0x00007C00;                                                \
+    }                                                                         \
     if(pixel_top & 0x00000020)                                                \
+    {                                                                         \
       pixel_top |= 0x0000001F;                                                \
   }                                                                           \
+  }                                                                           \
 
 #define brighten_pixel()                                                      \
-  pixel_top = upper + ((pixel_top * blend) >> 4);                             \
+  pixel_top = upper + ((pixel_top * blend) >> 4)                              \
 
 #define darken_pixel()                                                        \
-  pixel_top = (pixel_top * blend) >> 4;                                       \
+  pixel_top = (pixel_top * blend) >> 4                                        \
 
 #define effect_condition_alpha                                                \
   ((pixel_pair & 0x04000200) == 0x04000200)                                   \
@@ -2343,13 +2341,13 @@
   ((pixel_source & 0x00000200) == 0x00000200)                                 \
 
 #define expand_pixel_no_dest(expand_type, pixel_source)                       \
-  pixel_top = (pixel_top | (pixel_top << 16)) & 0x07E0F81F;                   \
+  pixel_top = (pixel_top | (pixel_top << 16)) & 0x03E07C1F;                   \
   expand_type##_pixel();                                                      \
-  pixel_top &= 0x07E0F81F;                                                    \
+  pixel_top &= 0x03E07C1F;                                                    \
   pixel_top = (pixel_top >> 16) | pixel_top                                   \
 
 #define expand_pixel(expand_type, pixel_source)                               \
-  pixel_top = palette_ram_converted[pixel_source & 0x1FF];                    \
+  pixel_top = palette_ram[pixel_source & 0x1FF];                              \
   expand_pixel_no_dest(expand_type, pixel_source);                            \
   *screen_dest_ptr = pixel_top                                                \
 
@@ -2369,7 +2367,7 @@
     else                                                                      \
     {                                                                         \
       *screen_dest_ptr =                                                      \
-       palette_ram_converted[pixel_source & 0x1FF];                           \
+       palette_ram[pixel_source & 0x1FF];                                     \
     }                                                                         \
                                                                               \
     screen_src_ptr++;                                                         \
@@ -2400,7 +2398,7 @@
     else                                                                      \
     {                                                                         \
       *screen_dest_ptr =                                                      \
-       palette_ram_converted[pixel_pair & 0x1FF];                             \
+       palette_ram[pixel_pair & 0x1FF];                                       \
     }                                                                         \
                                                                               \
     screen_src_ptr++;                                                         \
@@ -2422,33 +2420,9 @@
 
 // Blend top two pixels of scanline with each other.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-void expand_normal(u16 *screen_ptr, u32 start, u32 end)
-{
-  u32 i, pixel_source;
-  screen_ptr += start;
-
-  return;
-
-  end -= start;
-
-  for(i = 0; i < end; i++)
-  {
-    pixel_source = *screen_ptr;
-    *screen_ptr = palette_ram_converted[pixel_source];
-
-    screen_ptr++;
-  }
-}
-
-#else
-
 #define expand_normal(screen_ptr, start, end)
 
-#endif
-
-void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+static void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
   u32 pixel_pair;
@@ -2478,7 +2452,7 @@
 
 // Blend scanline with white.
 
-void expand_darken(u16 *screen_src_ptr, u16 *screen_dest_ptr,
+static void expand_darken(u16 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
   u32 pixel_top;
@@ -2494,7 +2468,7 @@
 
 // Blend scanline with black.
 
-void expand_brighten(u16 *screen_src_ptr, u16 *screen_dest_ptr,
+static void expand_brighten(u16 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
   u32 pixel_top;
@@ -2505,7 +2479,7 @@
   if(blend > 16)
     blend = 16;
 
-  upper = ((0x07E0F81F * blend) >> 4) & 0x07E0F81F;
+  upper = ((0x03E07C1F * blend) >> 4) & 0x03E07C1F;
   blend = 16 - blend;
 
   expand_loop(brighten, effect_condition_fade(pixel_top), pixel_top);
@@ -2516,7 +2490,7 @@
 // Expand scanline such that if both top and bottom pass it's alpha,
 // if only top passes it's as specified, and if neither pass it's normal.
 
-void expand_darken_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+static void expand_darken_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
   s32 blend = 16 - (io_registers[REG_BLDY] & 0x1F);
@@ -2540,7 +2514,7 @@
 }
 
 
-void expand_brighten_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
+static void expand_brighten_partial_alpha(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
   s32 blend = io_registers[REG_BLDY] & 0x1F;
@@ -2555,7 +2529,7 @@
   if(blend > 16)
     blend = 16;
 
-  upper = ((0x07E0F81F * blend) >> 4) & 0x07E0F81F;
+  upper = ((0x03E07C1F * blend) >> 4) & 0x03E07C1F;
   blend = 16 - blend;
 
   if(blend_a > 16)
@@ -2574,9 +2548,13 @@
 #define render_obj_layer(type, dest, _start, _end)                            \
   current_layer &= ~0x04;                                                     \
   if(dispcnt & 0x40)                                                          \
+  {                                                                           \
     render_scanline_obj_##type##_1D(current_layer, _start, _end, dest);       \
+  }                                                                           \
   else                                                                        \
-    render_scanline_obj_##type##_2D(current_layer, _start, _end, dest)        \
+  {                                                                           \
+    render_scanline_obj_##type##_2D(current_layer, _start, _end, dest);       \
+  }                                                                           \
 
 
 // Render a target all the way with the background color as taken from the
@@ -2731,7 +2709,7 @@
   }                                                                           \
   else                                                                        \
   {                                                                           \
-    u32 pixel_top = palette_ram_converted[0];                                 \
+    u32 pixel_top = palette_ram[0];                                           \
     switch((bldcnt >> 6) & 0x03)                                              \
     {                                                                         \
       /* Fade to white */                                                     \
@@ -2743,9 +2721,10 @@
           u32 upper;                                                          \
                                                                               \
           if(blend > 16)                                                      \
+          {                                                                   \
             blend = 16;                                                       \
-                                                                              \
-          upper = ((0x07E0F81F * blend) >> 4) & 0x07E0F81F;                   \
+          }                                                                   \
+          upper = ((0x03E07C1F * blend) >> 4) & 0x03E07C1F;                   \
           blend = 16 - blend;                                                 \
                                                                               \
           expand_pixel_no_dest(brighten, pixel_top);                          \
@@ -2761,8 +2740,9 @@
           s32 blend = 16 - (io_registers[REG_BLDY] & 0x1F);                   \
                                                                               \
           if(blend < 0)                                                       \
+          {                                                                   \
             blend = 0;                                                        \
-                                                                              \
+          }                                                                   \
           expand_pixel_no_dest(darken, pixel_top);                            \
         }                                                                     \
         break;                                                                \
@@ -2775,7 +2755,7 @@
 
 // Renders an entire scanline from 0 to 240, based on current color mode.
 
-void render_scanline_tile(u16 *scanline, u32 dispcnt)
+static void render_scanline_tile(u16 *scanline, u32 dispcnt)
 {
   u32 current_layer;
   u32 layer_order_pos;
@@ -2786,14 +2766,17 @@
    render_condition_alpha, render_condition_fade, 0, 240);
 }
 
-void render_scanline_bitmap(u16 *scanline, u32 dispcnt)
+static void render_scanline_bitmap(u16 *scanline, u32 dispcnt)
 {
 //  u32 bldcnt = io_registers[REG_BLDCNT];
   render_scanline_layer_functions_bitmap();
   u32 current_layer;
   u32 layer_order_pos;
 
-  fill_line_bg(normal, scanline, 0, 240);
+  u32 *scanline32 = (u32 *)scanline;
+  u32 color = (u32)palette_ram[0];
+  color = (color << 16) || color;
+  fill_line_color32(color, scanline32, 0, 240 / 2);
 
   for(layer_order_pos = 0; layer_order_pos < layer_count; layer_order_pos++)
   {
@@ -2907,7 +2890,7 @@
 // Render all of the BG and OBJ in a tiled scanline from start to end ONLY if
 // enable_flag allows that layer/OBJ. Also conditionally render color effects.
 
-void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
+static void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
  u32 enable_flags, u32 dispcnt, u32 bldcnt, tile_layer_render_struct
  *layer_renderers)
 {
@@ -2924,9 +2907,9 @@
 // Render the BG and OBJ in a bitmap scanline from start to end ONLY if
 // enable_flag allows that layer/OBJ. Also conditionally render color effects.
 
-void render_scanline_conditional_bitmap(u32 start, u32 end, u16 *scanline,
- u32 enable_flags, u32 dispcnt, u32 bldcnt, bitmap_layer_render_struct
- *layer_renderers)
+static void render_scanline_conditional_bitmap(u32 start, u32 end, u16 *scanline,
+ u32 enable_flags, u32 dispcnt, u32 bldcnt,
+ BITMAP_LAYER_RENDER_STRUCT *layer_renderers)
 {
   u32 current_layer;
   u32 layer_order_pos;
@@ -2946,10 +2929,12 @@
     else
     {
       if(enable_flags & 0x04)
+      {
         layer_renderers->normal_render(start, end, scanline);
     }
   }
 }
+}
 
 
 #define window_x_coords(window_number)                                        \
@@ -2961,10 +2946,13 @@
    (winin >> (window_number * 8)) & 0x3F;                                     \
                                                                               \
   if(window_##window_number##_x1 > 240)                                       \
+  {                                                                           \
     window_##window_number##_x1 = 240;                                        \
-                                                                              \
+  }                                                                           \
   if(window_##window_number##_x2 > 240)                                       \
-    window_##window_number##_x2 = 240                                         \
+  {                                                                           \
+    window_##window_number##_x2 = 240;                                        \
+  }                                                                           \
 
 #define window_coords(window_number)                                          \
   u32 window_##window_number##_x1, window_##window_number##_x2;               \
@@ -3042,8 +3030,10 @@
     if(end > clip_end)                                                        \
     {                                                                         \
       if(start < clip_end)                                                    \
+      {                                                                       \
         render_window_segment_unequal(type, start, clip_end, window_type);    \
     }                                                                         \
+    }                                                                         \
     else                                                                      \
     {                                                                         \
       render_window_segment_unequal(type, start, end, window_type);           \
@@ -3077,13 +3067,16 @@
 #define render_window_clip_obj(type, start, end);                             \
   render_window_segment(type, start, end, out);                               \
   if(dispcnt & 0x40)                                                          \
+  {                                                                           \
     render_scanline_obj_copy_##type##_1D(4, start, end, scanline);            \
+  }                                                                           \
   else                                                                        \
-    render_scanline_obj_copy_##type##_2D(4, start, end, scanline)             \
+  {                                                                           \
+    render_scanline_obj_copy_##type##_2D(4, start, end, scanline);            \
+  }                                                                           \
 
 
-#define render_window_segment_clip_obj(type, clip_start, clip_end, start,     \
- end)                                                                         \
+#define render_window_segment_clip_obj(type, clip_start, clip_end, start, end)\
 {                                                                             \
   if(start != end)                                                            \
   {                                                                           \
@@ -3102,7 +3095,6 @@
       }                                                                       \
     }                                                                         \
     else                                                                      \
-                                                                              \
     if(end > clip_end)                                                        \
     {                                                                         \
       if(start < clip_end)                                                    \
@@ -3180,7 +3172,7 @@
   }                                                                           \
 
 #define render_scanline_window_builder(type)                                  \
-void render_scanline_window_##type(u16 *scanline, u32 dispcnt)                \
+static void render_scanline_window_##type(u16 *scanline, u32 dispcnt)         \
 {                                                                             \
   u32 vcount = io_registers[REG_VCOUNT];                                      \
   u32 winout = io_registers[REG_WINOUT];                                      \
@@ -3259,13 +3251,13 @@
 render_scanline_window_builder(tile);
 render_scanline_window_builder(bitmap);
 
-u32 active_layers[6] = { 0x1F, 0x17, 0x1C, 0x14, 0x14, 0x14 };
+static const u32 active_layers[6] = { 0x1F, 0x17, 0x1C, 0x14, 0x14, 0x14 };
 
-u32 small_resolution_width = 240;
-u32 small_resolution_height = 160;
-u32 resolution_width, resolution_height;
+// u32 small_resolution_width = 240;
+// u32 small_resolution_height = 160;
+// u32 resolution_width, resolution_height;
 
-void update_scanline()
+void update_scanline(void)
 {
   u32 pitch = get_screen_pitch();
   u32 dispcnt = io_registers[REG_DISPCNT];
@@ -3291,7 +3283,7 @@
   // If the screen is in in forced blank draw pure white.
   if(dispcnt & 0x80)
   {
-    fill_line_color16(0xFFFF, screen_offset, 0, 240);
+    fill_line_color16(0x7FFF, screen_offset, 0, 240);
   }
   else
   {
@@ -3309,11 +3301,15 @@
     else
     {
       if(dispcnt >> 13)
+      {
         render_scanline_window_bitmap(screen_offset, dispcnt);
+      }
       else
+      {
         render_scanline_bitmap(screen_offset, dispcnt);
     }
   }
+  }
 
   affine_reference_x[0] += (s16)io_registers[REG_BG2PB];
   affine_reference_y[0] += (s16)io_registers[REG_BG2PD];
@@ -3321,56 +3317,29 @@
   affine_reference_y[1] += (s16)io_registers[REG_BG3PD];
 }
 
-u32 screen_flip = 0;
-
-void flip_screen()
-{
-  if(video_direct == 0)
-  {
-    u32 *old_ge_cmd_ptr = ge_cmd_ptr;
-    sceKernelDcacheWritebackAll();
-
-    // Render the current screen
-    ge_cmd_ptr = ge_cmd + 2;
-    GE_CMD(TBP0, ((u32)screen_pixels & 0x00FFFFFF));
-    GE_CMD(TBW0, (((u32)screen_pixels & 0xFF000000) >> 8) |
-     GBA_SCREEN_WIDTH);
-    ge_cmd_ptr = old_ge_cmd_ptr;
-
-    sceGeListEnQueue(ge_cmd, ge_cmd_ptr, gecbid, NULL);
-
-    // Flip to the next screen
-    screen_flip ^= 1;
-
-    if(screen_flip)
-      screen_pixels = screen_texture + (240 * 160 * 2);
-    else
-      screen_pixels = screen_texture;
-  }
-}
 
-u32 frame_to_render;
+static u32 screen_flip = 0;
+// u32 frame_to_render;
 
-void update_screen()
+void update_screen(void)
 {
   if(!skip_next_frame)
     flip_screen();
 }
 
-void init_video()
+void init_video(void)
 {
   sceDisplaySetMode(0, PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT);
 
   sceDisplayWaitVblankStart();
   sceDisplaySetFrameBuf((void*)psp_gu_vram_base, PSP_LINE_SIZE,
-   PSP_DISPLAY_PIXEL_FORMAT_565, PSP_DISPLAY_SETBUF_NEXTFRAME);
+   PSP_DISPLAY_PIXEL_FORMAT_5551, PSP_DISPLAY_SETBUF_NEXTFRAME);
 
   sceGuInit();
 
   sceGuStart(GU_DIRECT, display_list);
-  sceGuDrawBuffer(GU_PSM_5650, (void*)0, PSP_LINE_SIZE);
-  sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT,
-   (void*)0, PSP_LINE_SIZE);
+  sceGuDrawBuffer(GU_PSM_5551, (void*)0, PSP_LINE_SIZE);
+  sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT, (void*)0, PSP_LINE_SIZE);
   sceGuClear(GU_COLOR_BUFFER_BIT);
 
   sceGuOffset(2048 - (PSP_SCREEN_WIDTH / 2), 2048 - (PSP_SCREEN_HEIGHT / 2));
@@ -3378,7 +3347,7 @@
 
   sceGuScissor(0, 0, PSP_SCREEN_WIDTH + 1, PSP_SCREEN_HEIGHT + 1);
   sceGuEnable(GU_SCISSOR_TEST);
-  sceGuTexMode(GU_PSM_5650, 0, 0, GU_FALSE);
+  sceGuTexMode(GU_PSM_5551, 0, 0, GU_FALSE);
   sceGuTexFunc(GU_TFX_REPLACE, GU_TCC_RGBA);
   sceGuTexFilter(GU_LINEAR, GU_LINEAR);
   sceGuEnable(GU_TEXTURE_2D);
@@ -3399,16 +3368,16 @@
   gecb.finish_arg = NULL;
   gecbid = sceGeSetCallback(&gecb);
 
-  screen_vertex[0] = 0 + 0.5;
-  screen_vertex[1] = 0 + 0.5;
-  screen_vertex[2] = 0 + 0.5;
-  screen_vertex[3] = 0 + 0.5;
-  screen_vertex[4] = 0;
+  screen_vertex[0] = 0.0 + 0.5;
+  screen_vertex[1] = 0.0 + 0.5;
+  screen_vertex[2] = 0.0 + 0.5;
+  screen_vertex[3] = 0.0 + 0.5;
+  screen_vertex[4] = 0.0;
   screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
   screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
   screen_vertex[7] = PSP_SCREEN_WIDTH - 0.5;
   screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
-  screen_vertex[9] = 0;
+  screen_vertex[9] = 0.0;
 
   // Set framebuffer to PSP VRAM
   GE_CMD(FBP, ((u32)psp_gu_vram_base & 0x00FFFFFF));
@@ -3442,15 +3411,47 @@
   GE_CMD(NOP, 0);
 }
 
-//video_scale_type screen_scale = scaled_aspect;
-//video_scale_type current_scale = scaled_aspect;
-//video_filter_type screen_filter = filter_bilinear;
-
-u32 screen_scale = scaled_aspect;
-u32 current_scale = scaled_aspect;
-u32 screen_filter = filter_bilinear;
+void video_exit(void)
+{
+  sceGuDisplay(GU_FALSE);
+  sceGuTerm();
+}
+
+
+VIDEO_SCALE_TYPE screen_scale = scaled_aspect;
+VIDEO_SCALE_TYPE current_scale = scaled_aspect;
+VIDEO_FILTER_TYPE screen_filter = filter_bilinear;
+
+void flip_screen(void)
+{
+  if(video_direct == 0)
+  {
+    u32 *old_ge_cmd_ptr = ge_cmd_ptr;
+    sceKernelDcacheWritebackAll();
+
+    // Render the current screen
+    ge_cmd_ptr = ge_cmd + 2;
+    GE_CMD(TBP0, ((u32)screen_pixels & 0x00FFFFFF));
+    GE_CMD(TBW0, (((u32)screen_pixels & 0xFF000000) >> 8) | GBA_SCREEN_WIDTH);
+    ge_cmd_ptr = old_ge_cmd_ptr;
+
+    sceGeListEnQueue(ge_cmd, ge_cmd_ptr, gecbid, NULL);
+
+    // Flip to the next screen
+    screen_flip ^= 1;
+
+    if(screen_flip)
+    {
+      screen_pixels = screen_texture + (240 * 160 * 2);
+    }
+    else
+    {
+      screen_pixels = screen_texture;
+    }
+  }
+}
 
-void video_resolution_large()
+void video_resolution_large(void)
 {
   if(video_direct != 1)
   {
@@ -3458,8 +3459,22 @@
     screen_pixels = psp_gu_vram_base;
     screen_pitch = 512;
     sceGuStart(GU_DIRECT, display_list);
-    sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT,
-     (void*)0, PSP_LINE_SIZE);
+    sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT, (void*)0, PSP_LINE_SIZE);
+    sceGuFinish();
+  }
+}
+
+void video_resolution_small(void)
+{
+  if(video_direct != 0)
+  {
+    set_gba_resolution(screen_scale);
+    video_direct = 0;
+    screen_pixels = screen_texture;
+    screen_flip = 0;
+    screen_pitch = 240;
+    sceGuStart(GU_DIRECT, display_list);
+    sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT, (void*)0, PSP_LINE_SIZE);
     sceGuFinish();
   }
 }
@@ -3471,24 +3486,36 @@
   switch(scale)
   {
     case unscaled:
-      screen_vertex[2] = 120 + 0.5;
-      screen_vertex[3] = 56 + 0.5;
-      screen_vertex[7] = GBA_SCREEN_WIDTH + 120 - 0.5;
-      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56 - 0.5;
+      screen_vertex[0] = 0.0;
+      screen_vertex[1] = 0.0;
+      screen_vertex[2] = 120.0;
+      screen_vertex[3] = 56.0;
+      screen_vertex[5] = (float)GBA_SCREEN_WIDTH;
+      screen_vertex[6] = (float)GBA_SCREEN_HEIGHT;
+      screen_vertex[7] = GBA_SCREEN_WIDTH + 120.0;
+      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56.0;
       break;
 
     case scaled_aspect:
-      screen_vertex[2] = 36 + 0.5;
-      screen_vertex[3] = 0 + 0.5;
-      screen_vertex[7] = 408 + 36 - 0.5;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 36.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = 408.0 + 36.0;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
 
     case fullscreen:
-      screen_vertex[2] = 0;
-      screen_vertex[3] = 0;
-      screen_vertex[7] = PSP_SCREEN_WIDTH;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 0.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = (float)PSP_SCREEN_WIDTH;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
   }
 
@@ -3504,47 +3531,16 @@
   clear_screen(0x0000);
 }
 
-void video_resolution_small()
-{
-  if(video_direct != 0)
-  {
-    set_gba_resolution(screen_scale);
-    video_direct = 0;
-    screen_pixels = screen_texture;
-    screen_flip = 0;
-    screen_pitch = 240;
-    sceGuStart(GU_DIRECT, display_list);
-    sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT,
-     (void*)0, PSP_LINE_SIZE);
-    sceGuFinish();
-  }
-}
-
 void clear_screen(u16 color)
 {
   u32 i = 512 * 272;
   u16 *src_ptr = get_screen_pixels();
 
-  sceGuSync(0, 0);
-
   while (i--) *src_ptr++ = color;
-
-  // I don't know why this doesn't work.
-/*  color = (((color & 0x1F) * 255 / 31) << 0) |
-   ((((color >> 5) & 0x3F) * 255 / 63) << 8) |
-   ((((color >> 11) & 0x1F) * 255 / 31) << 16) | (0xFF << 24);
-
-  sceGuStart(GU_DIRECT, display_list);
-  sceGuDrawBuffer(GU_PSM_5650, (void*)0, PSP_LINE_SIZE);
-  //sceGuDispBuffer(PSP_SCREEN_WIDTH, PSP_SCREEN_HEIGHT,
-  // (void*)0, PSP_LINE_SIZE);
-  sceGuClearColor(color);
-  sceGuClear(GU_COLOR_BUFFER_BIT);
-  sceGuFinish();
-  sceGuSync(0, 0); */
 }
 
-u16 *copy_screen()
+
+u16 *copy_screen(void)
 {
   u16 *copy = malloc(240 * 160 * 2);
   memcpy(copy, get_screen_pixels(), 240 * 160 * 2);
@@ -3570,124 +3567,28 @@
   }
 }
 
-void print_string_ext(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y, void *_dest_ptr, u32 pitch, u32 pad)
+
+void print_string_ext(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y,
+ void *_dest_ptr, u32 pitch, u32 pad)
 {
-  fbm_printVRAM( _dest_ptr, pitch, 0, x, y,
+  fbm_printVRAM(_dest_ptr, pitch, x, y,
     str, fg_color, bg_color, FBM_FONT_FILL | FBM_BACK_FILL, 100, pad);
 }
 
-void print_string(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y)
+void print_string(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y)
 {
-  fbm_printVRAM( get_screen_pixels(), get_screen_pitch(), 0, x, y,
+  fbm_printVRAM(get_screen_pixels(), get_screen_pitch(), x, y,
     str, fg_color, bg_color, FBM_FONT_FILL | FBM_BACK_FILL, 100, 0);
 }
 
-void print_string_pad(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y, u32 pad)
+void print_string_pad(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y,
+ u32 pad)
 {
-  fbm_printVRAM( get_screen_pixels(), get_screen_pitch(), 0, x, y,
+  fbm_printVRAM(get_screen_pixels(), get_screen_pitch(), x, y,
     str, fg_color, bg_color, FBM_FONT_FILL | FBM_BACK_FILL, 100, pad);
 }
 
 
-u32 debug_cursor_x = 0;
-u32 debug_cursor_y = 0;
-
-#ifdef STDIO_DEBUG
-
-void debug_screen_clear()
-{
-}
-
-void debug_screen_start()
-{
-}
-
-void debug_screen_end()
-{
-}
-
-void debug_screen_update()
-{
-}
-
-void debug_screen_printf(const char *format, ...)
-{
-  va_list ap;
-
-  va_start(ap, format);
-  vprintf(format, ap);
-  va_end(ap);
-}
-
-void debug_screen_newline(u32 count)
-{
-  printf("\n");
-}
-
-
-#else
-
-void debug_screen_clear()
-{
-  debug_cursor_x = 0;
-  debug_cursor_y = 0;
-  clear_screen(0x0000);
-}
-
-void debug_screen_start()
-{
-  video_resolution_large();
-  debug_screen_clear();
-}
-
-void debug_screen_end()
-{
-  video_resolution_small();
-}
-
-void debug_screen_update()
-{
-  flip_screen();
-}
-
-void debug_screen_printf(const char *format, ...)
-{
-  char str_buffer[512];
-  u32 str_buffer_length;
-  va_list ap;
-
-  va_start(ap, format);
-  str_buffer_length = vsnprintf(str_buffer, 512, format, ap);
-  va_end(ap);
-
-  printf("printing debug string %s at %d %d\n", str_buffer,
-   (int)debug_cursor_x, (int)debug_cursor_y);
-
-  print_string(str_buffer, 0xFFFF, 0x0000, debug_cursor_x, debug_cursor_y);
-  debug_cursor_x += FONT_WIDTH * str_buffer_length;
-}
-
-void debug_screen_newline(u32 count)
-{
-  debug_cursor_x = 0;
-  debug_cursor_y += FONT_HEIGHT * count;
-}
-
-#endif
-
-void debug_screen_printl(const char *format, ...)
-{
-  va_list ap;
-
-  va_start(ap, format);
-  debug_screen_printf(format, ap);
-  debug_screen_printf("\n");
-  va_end(ap);
-}
-
 #define video_savestate_body(type)                                            \
 {                                                                             \
   FILE_##type##_ARRAY(savestate_file, affine_reference_x);                    \
diff -ruibwEB --strip-trailing-cr -I RE old/video.h mod/video.h
--- old/video.h	2007-08-26 00:49:54.984782600 +0900
+++ mod/video.h	2007-10-27 22:43:43.741035200 +0900
@@ -21,37 +21,30 @@
 #ifndef VIDEO_H
 #define VIDEO_H
 
-#define FONT_WIDTH  6
-#define FONT_HEIGHT 10
 
-void update_scanline();
-void update_screen();
-void init_video();
-void video_resolution_large();
-void video_resolution_small();
-void print_string(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y);
-void print_string_pad(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y, u32 pad);
-void print_string_ext(char *str, u16 fg_color, u16 bg_color,
- u32 x, u32 y, void *_dest_ptr, u32 pitch, u32 pad);
+void update_scanline(void);
+void update_screen(void);
+
+void init_video(void);
+void video_exit(void);
+
+void video_resolution_large(void);
+void video_resolution_small(void);
+
+void print_string(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y);
+void print_string_pad(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y,
+ u32 pad);
+void print_string_ext(char *str, u32 fg_color, u32 bg_color, u32 x, u32 y,
+ void *_dest_ptr, u32 pitch, u32 pad);
+
 void clear_screen(u16 color);
 void blit_to_screen(u16 *src, u32 w, u32 h, u32 x, u32 y);
-u16 *copy_screen();
-void flip_screen();
+u16 *copy_screen(void);
+void flip_screen(void);
+
 void video_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void video_read_savestate(FILE_TAG_TYPE savestate_file);
 
-void debug_screen_clear();
-void debug_screen_start();
-void debug_screen_end();
-void debug_screen_printf(const char *format, ...);
-void debug_screen_printl(const char *format, ...);
-void debug_screen_newline(u32 count);
-void debug_screen_update();
-
-extern u32 frame_speed;
-
 extern s32 affine_reference_x[2];
 extern s32 affine_reference_y[2];
 
@@ -89,14 +82,11 @@
   filter_bilinear
 } video_filter_type;
 
-//extern video_scale_type screen_scale;
-//extern video_scale_type current_scale;
-//extern video_filter_type screen_filter;
-
-extern u32 screen_scale;
-extern u32 current_scale;
-extern u32 screen_filter;
+extern VIDEO_SCALE_TYPE screen_scale;
+extern VIDEO_SCALE_TYPE current_scale;
+extern VIDEO_FILTER_TYPE screen_filter;
 
 void set_gba_resolution(video_scale_type scale);
 
-#endif
+
+#endif /* VIDEO_H */
diff -ruibwEB --strip-trailing-cr -I RE old/zip.c mod/zip.c
--- old/zip.c	2007-08-26 00:49:54.922782600 +0900
+++ mod/zip.c	2007-10-27 22:43:57.631008000 +0900
@@ -33,7 +33,7 @@
 
 struct SZIPFileHeader
 {
-  char Sig[4]; // EDIT: Used to be s32 Sig;
+  char Sig[4];
   s16 VersionToExtract;
   s16 GeneralBitFlag;
   s16 CompressionMethod;
@@ -44,30 +44,23 @@
   s16 ExtraFieldLength;
 }  __attribute__((packed));
 
-u32 load_file_zip(char *filename)
+s32 load_file_zip(char *filename)
 {
+  FILE_TAG_TYPE fd;
   struct SZIPFileHeader data;
   char tmp[1024];
   s32 retval = -1;
   u8 *buffer = NULL;
   u8 *cbuffer;
   char *ext;
-  FILE_ID fd;
 
   FILE_OPEN(fd, filename, READ);
 
   if(!FILE_CHECK_VALID(fd))
     return -1;
 
-#if 0 // EDIT: Why this while(1) is used is unknown and can cause a crash.
-  while(1)
-#endif
-  {
     FILE_READ(fd, &data, sizeof(struct SZIPFileHeader));
 
-    // EDIT: Check if this is a zip file without worrying about endian
-	// It checks for the following: 0x50 0x4B 0x03 0x04 (PK..)
-    // Used to be: if(data.Sig != 0x04034b50) break;
 	if( data.Sig[0] != 0x50 || data.Sig[1] != 0x4B ||
 		data.Sig[2] != 0x03 || data.Sig[3] != 0x04 )
 	{
@@ -82,8 +75,7 @@
 
     if(data.GeneralBitFlag & 0x0008)
     {
-      FILE_READ(fd, &data.DataDescriptor,
-       sizeof(struct SZIPFileDataDescriptor));
+    FILE_READ(fd, &data.DataDescriptor, sizeof(struct SZIPFileDataDescriptor));
     }
 
     ext = strrchr(tmp, '.') + 1;
@@ -117,12 +108,12 @@
 
           stream.next_out = (Bytef*)buffer;
 
-		  // EDIT: Now uses proper conversion of data types for retval.
 		  retval = (u32)data.DataDescriptor.UncompressedSize;
 		  stream.avail_out = data.DataDescriptor.UncompressedSize;
 
           stream.zalloc = (alloc_func)0;
           stream.zfree = (free_func)0;
+        stream.opaque = (voidpf)0;
 
           err = inflateInit2(&stream, -MAX_WBITS);
 
@@ -148,7 +139,6 @@
         }
       }
     }
-  }
 
 outcode:
   FILE_CLOSE(fd);
diff -ruibwEB --strip-trailing-cr -I RE old/zip.h mod/zip.h
--- old/zip.h	2007-08-26 00:49:54.966782600 +0900
+++ mod/zip.h	2007-10-27 22:44:09.548144000 +0900
@@ -21,7 +21,7 @@
 #ifndef ZIP_H
 #define ZIP_H
 
-u32 load_file_zip(char *filename);
+s32 load_file_zip(char *filename);
 
-#endif
 
+#endif /* ZIP_H */
