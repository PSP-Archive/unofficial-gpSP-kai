Only in 30_new/: #sound.c#
diff -ru 30_orig/common.h 30_new/common.h
--- 30_orig/common.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/common.h	2007-08-05 23:04:12.000000000 +0900
@@ -157,7 +157,7 @@
 #define DBGOUT(...) fprintf(dbg_file, __VA_ARGS__)
 FILE *dbg_file;
 
-//#include "SDL.h"
+#include "SDL.h"
 #include "cpu.h"
 #include "memory.h"
 #include "video.h"
diff -ru 30_orig/cpu.c 30_new/cpu.c
--- 30_orig/cpu.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/cpu.c	2007-08-06 23:46:02.000000000 +0900
@@ -459,7 +459,7 @@
   n_flag = reg[REG_CPSR] >> 31;                                               \
   z_flag = (reg[REG_CPSR] >> 30) & 0x01;                                      \
   c_flag = (reg[REG_CPSR] >> 29) & 0x01;                                      \
-  v_flag = (reg[REG_CPSR] >> 28) & 0x01;                                      \
+  v_flag = (reg[REG_CPSR] >> 28) & 0x01                                       \
 
 #define collapse_flags()                                                      \
   reg[REG_CPSR] = (n_flag << 31) | (z_flag << 30) | (c_flag << 29) |          \
@@ -638,7 +638,7 @@
 
 #define arm_multiply_flags_yes(_dest)                                         \
   calculate_z_flag(_dest);                                                    \
-  calculate_n_flag(_dest);                                                    \
+  calculate_n_flag(_dest)                                                     \
 
 #define arm_multiply_flags_no(_dest)                                          \
 
@@ -659,7 +659,7 @@
 }                                                                             \
 
 #define arm_multiply_long_addop(type)                                         \
-  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]));                  \
+  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]))                   \
 
 #define arm_multiply_long(add_op, flags, type)                                \
 {                                                                             \
@@ -1332,7 +1332,7 @@
   address += offset + 4                                                       \
 
 #define thumb_block_address_postadjust_push_lr()                              \
-  store_memory_u32(address + offset, reg[REG_LR]);                            \
+  store_memory_u32(address + offset, reg[REG_LR])                             \
 
 #define thumb_block_memory_wb_load(base_reg)                                  \
   if(!((reg_list >> base_reg) & 0x01))                                        \
@@ -1393,10 +1393,10 @@
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
   MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_USER, MODE_FIQ, MODE_IRQ, MODE_SUPERVISOR, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_ABORT, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED, MODE_INVALID, MODE_INVALID,
-  MODE_USER
+  MODE_INVALID, MODE_USER,    MODE_FIQ,     MODE_IRQ,     MODE_SUPERVISOR,
+  MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_ABORT,   MODE_INVALID,
+  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED,MODE_INVALID,MODE_INVALID,
+  MODE_INVALID, MODE_USER
 };
 
 u32 cpu_modes_cpsr[7] = { 0x10, 0x11, 0x12, 0x13, 0x17, 0x1B, 0x1F };
@@ -1888,7 +1888,7 @@
       else                                                                    \
       {                                                                       \
         /* RSC rd, rn, reg_op */                                              \
-        arm_data_proc(reg_sh - reg[rn] + c_flag - 1, reg);                    \
+        arm_data_proc(reg_sh - (reg[rn] + (c_flag ^ 1)), reg);                \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -1921,7 +1921,7 @@
       else                                                                    \
       {                                                                       \
         /* RSCS rd, rn, reg_op */                                             \
-        arm_data_proc_sub_flags((reg_sh + c_flag - 1), reg[rn], reg);         \
+        arm_data_proc_sub_flags(reg_sh, reg[rn] + (c_flag ^ 1), reg);         \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -2351,7 +2351,7 @@
                                                                               \
     case 0x2C:                                                                \
       /* SBC rd, rn, imm */                                                   \
-      arm_data_proc(reg[rn] - imm + c_flag - 1, imm);                         \
+      arm_data_proc(reg[rn] - (imm + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2D:                                                                \
@@ -2361,12 +2361,12 @@
                                                                               \
     case 0x2E:                                                                \
       /* RSC rd, rn, imm */                                                   \
-      arm_data_proc(imm - reg[rn] + c_flag - 1, imm);                         \
+      arm_data_proc(imm - (reg[rn] + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2F:                                                                \
       /* RSCS rd, rn, imm */                                                  \
-      arm_data_proc_sub_flags((imm + c_flag - 1), reg[rn], imm);              \
+      arm_data_proc_sub_flags(imm, reg[rn] + (c_flag ^ 1), imm);              \
       break;                                                                  \
                                                                               \
     case 0x30 ... 0x31:                                                       \
@@ -2919,22 +2919,7 @@
       arm_block_memory(load, up, up, yes);                                    \
       break;                                                                  \
                                                                               \
-    case 0xA0:                                                                \
-    case 0xA1:                                                                \
-    case 0xA2:                                                                \
-    case 0xA3:                                                                \
-    case 0xA4:                                                                \
-    case 0xA5:                                                                \
-    case 0xA6:                                                                \
-    case 0xA7:                                                                \
-    case 0xA8:                                                                \
-    case 0xA9:                                                                \
-    case 0xAA:                                                                \
-    case 0xAB:                                                                \
-    case 0xAC:                                                                \
-    case 0xAD:                                                                \
-    case 0xAE:                                                                \
-    case 0xAF:                                                                \
+    case 0xA0 ... 0xAF:                                                       \
     {                                                                         \
       /* B offset */                                                          \
       arm_decode_branch();                                                    \
@@ -2963,13 +2948,13 @@
       switch(swi_comment >> 16)                                               \
       {                                                                       \
         /* Jump to BIOS SWI handler */                                        \
-        case 0x00 ... 0x2b:                                                   \
+        case 0x00 ... 0x2A:                                                   \
           reg_mode[MODE_SUPERVISOR][6] = pc + 4;                              \
           collapse_flags();                                                   \
           spsr[MODE_SUPERVISOR] = reg[REG_CPSR];                              \
           reg[REG_PC] = 0x00000008;                                           \
           arm_update_pc();                                                    \
-          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x3F) | 0x13;                     \
+          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x1F) | 0x13;                     \
           set_cpu_mode(MODE_SUPERVISOR);                                      \
           break;                                                              \
       }                                                                       \
@@ -3596,7 +3581,7 @@
       thumb_add_noflags(imm, 7, reg[REG_SP], (imm * 4));                      \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
diff -ru 30_orig/cpu_threaded.c 30_new/cpu_threaded.c
--- 30_orig/cpu_threaded.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/cpu_threaded.c	2007-08-06 23:45:56.000000000 +0900
@@ -49,7 +49,9 @@
 u32 allow_smc_ram_u8 = 1;
 u32 allow_smc_ram_u16 = 1;
 u32 allow_smc_ram_u32 = 1;
-u32 waitstate_cycles_sequential[16][3];
+u8 waitstate_cycles_seq[2][16];
+u8 waitstate_cycles_non_seq[2][16];
+u8 cpu_waitstate_cycles_seq[2][16];
 
 u32 bios_mode;
 
@@ -78,7 +80,7 @@
   u32 rn = (opcode >> 16) & 0x0F;                                             \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_psr_reg()                                                  \
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
@@ -89,7 +91,7 @@
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_branchx()                                                  \
   u32 rn = opcode & 0x0F                                                      \
@@ -1639,7 +1641,7 @@
     }                                                                         \
   }                                                                           \
                                                                               \
-  pc += 4;                                                                    \
+  pc += 4                                                                     \
 
 #define arm_flag_status()                                                     \
 
@@ -1931,7 +1933,8 @@
                                                                               \
         case 0x01:                                                            \
           /* MUL rd, rs */                                                    \
-          thumb_data_proc(alu_op, muls, reg, rd, rd, rs);                     \
+       /* thumb_data_proc(alu_op, muls, reg, rd, rd, rs); */                  \
+          thumb_data_proc_muls(alu_op, reg, rd, rd, rs);                      \
           break;                                                              \
                                                                               \
         case 0x02:                                                            \
@@ -2246,7 +2249,7 @@
       thumb_load_sp(7);                                                       \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
@@ -2577,9 +2580,17 @@
       }                                                                       \
       break;                                                                  \
                                                                               \
-    /* TST, NEG, CMP, CMN */                                                  \
     case 0x42:                                                                \
-      thumb_flag_modifies_all();                                              \
+      if((opcode >> 6) & 0x03)                                                \
+      {                                                                       \
+        /* NEG, CMP, CMN */                                                   \
+        thumb_flag_modifies_all();                                            \
+      }                                                                       \
+      else                                                                    \
+      {                                                                       \
+        /* TST rd, rs */                                                      \
+        thumb_flag_modifies_zn();                                             \
+      }                                                                       \
       break;                                                                  \
                                                                               \
     /* ORR, MUL, BIC, MVN */                                                  \
@@ -2937,7 +2948,7 @@
 #define arm_instruction_width 4
 
 #define arm_base_cycles()                                                     \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][2]                     \
+  cycle_count += cpu_waitstate_cycles_seq[1][pc >> 24]                        \
 
 // For now this just sets a variable that says flags should always be
 // computed.
@@ -2983,22 +2994,21 @@
   }                                                                           \
   else                                                                        \
                                                                               \
-  if(opcode < 0xF800)                                                         \
+  if(opcode < 0xE800)                                                         \
   {                                                                           \
-    branch_target = block_end_pc + 2 + ((s32)((opcode & 0x7FF) << 21) >> 20); \
+    branch_target = block_end_pc + 2 + (((s32)(opcode & 0x7FF) << 21) >> 20); \
   }                                                                           \
   else                                                                        \
+                                                                              \
+  if((last_opcode >= 0xF000) && (last_opcode < 0xF800))                       \
   {                                                                           \
-    if((last_opcode >= 0xF000) && (last_opcode < 0xF800))                     \
-    {                                                                         \
-      branch_target =                                                         \
-       (block_end_pc + ((s32)((last_opcode & 0x07FF) << 21) >> 9) +           \
-       ((opcode & 0x07FF) * 2));                                              \
-    }                                                                         \
-    else                                                                      \
-    {                                                                         \
-      goto no_direct_branch;                                                  \
-    }                                                                         \
+    branch_target =                                                           \
+     (block_end_pc + (((s32)(last_opcode & 0x07FF) << 21) >> 9) +             \
+     ((s32)(opcode & 0x07FF) * 2));                                           \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    goto no_direct_branch;                                                    \
   }                                                                           \
 
 #define thumb_set_condition(_condition)                                       \
@@ -3012,7 +3022,7 @@
 #define thumb_instruction_width 2
 
 #define thumb_base_cycles()                                                   \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][1]                     \
+  cycle_count += cpu_waitstate_cycles_seq[0][pc >> 24]                        \
 
 // Here's how this works: each instruction has three different sets of flag
 // attributes, each consisiting of a 4bit mask describing how that instruction
@@ -3150,7 +3160,7 @@
     block_data[block_data_position].update_cycles = 0;                        \
     block_data_position++;                                                    \
     if((block_data_position == MAX_BLOCK_SIZE) ||                             \
-     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFFF0))             \
+     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFF0))              \
     {                                                                         \
       break;                                                                  \
     }                                                                         \
diff -ru 30_orig/fbm_print.c 30_new/fbm_print.c
--- 30_orig/fbm_print.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/fbm_print.c	2007-08-06 23:47:04.000000000 +0900
@@ -301,7 +301,7 @@
 
 
 	sceDisplayGetMode(&unk, &pwidth, &pheight);
-	sceDisplayGetFrameBuf(&vram, &bufferwidth, &pixelformat, unk);
+	sceDisplayGetFrameBuf(&vram, &bufferwidth, &pixelformat, &unk);
 
 	return fbm_printVRAM(vram, bufferwidth, pixelformat, x, y, str, color, back, fill, rate, 0);
 }
Only in 30_new/: game_config.txt
diff -ru 30_orig/gui.c 30_new/gui.c
--- 30_orig/gui.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/gui.c	2007-08-06 23:47:38.000000000 +0900
@@ -251,6 +251,7 @@
 static char font16[MAX_PATH];
 static u32 menu_cheat_page = 0;
 static u32 gamepad_config_line_to_button[] = { 8, 6, 7, 9, 1, 2, 3, 0, 4, 5, 11, 10 };
+static u32 clock_speed_number;
 
 /******************************************************************************
  * ローカル関数の宣言
@@ -761,6 +762,10 @@
       if(game_config_clock_speed < 33)
         game_config_clock_speed = 33;
 
+      /* メニュー終了時は clock_speed_number を元にクロックが変更される */
+      /* 起動時のファイルリストからの場合は、game_config_clock_speed */
+      clock_speed_number = (game_config_clock_speed / 33) - 1;
+
       if(game_config_frameskip_value < 0)
         game_config_frameskip_value = 0;
 
@@ -780,9 +785,11 @@
 
   // 読み込めなかった場合の初期値の設定
   game_config_frameskip_type = auto_frameskip;
-  game_config_frameskip_value = 4;
+  /* 一瞬負荷が上がる場合、スキップを増やした方がスムーズに動作する。 */
+  game_config_frameskip_value = 9;
   game_config_random_skip = 0;
   game_config_clock_speed = 333;
+  clock_speed_number = 9;
 
   for(i = 0; i < MAX_CHEATS; i++)
   {
@@ -823,9 +830,11 @@
       audio_buffer_size_number = file_options[3] % 11;
       update_backup_flag = file_options[4] % 2;
       global_enable_analog = file_options[5] % 2;
-      analog_sensitivity_level = file_options[6] % 8;
+      analog_sensitivity_level = file_options[6] % 10;
 
-      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+      /* 何故ここで変更しているのか不明。*/
+      /* config_fileが存在しないとクロックは変更されない。*/
+//      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
 
       // Sanity check: Make sure there's a MENU or FRAMESKIP
       // key, if not assign to triangle
@@ -857,7 +866,6 @@
 
 u32 menu(u16 *original_screen)
 {
-  u32 clock_speed_number = (game_config_clock_speed / 33) - 1;
   char print_buffer[81];
 //  u32 _current_option = 0;
   gui_action_type gui_action;
@@ -978,7 +986,9 @@
 
   void menu_save_ss()
   {
-    save_ss_bmp(original_screen);
+    /* 「未ロード．」のスクリーンショットが出来上がります。 */
+    if(!first_load)
+      save_ss_bmp(original_screen);
   }
 
   void menu_change_state()
@@ -1011,6 +1021,7 @@
   {
     char *file_ext[] = { ".svs", NULL };
     char load_filename[512];
+
     if(load_file(file_ext, load_filename, DEFAULT_SAVE_DIR) != -1)
     {
       load_state(load_filename);
@@ -1028,7 +1039,7 @@
   {
     char *file_ext[] = { ".cht", NULL };
     char load_filename[MAX_FILE];
-    u32 i;
+//    u32 i;
     
     if(load_file(file_ext, load_filename, DEFAULT_CHEAT_DIR) != -1)
     {
@@ -1170,7 +1181,7 @@
 
     STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_G_S_MENU_HELP_5], 9),
 
-    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 10, msg[MSG_G_S_MENU_HELP_6], 11),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 11, msg[MSG_G_S_MENU_HELP_6], 11),
 
     ACTION_OPTION(menu_save_ss, NULL, msg[MSG_G_S_MENU_7], msg[MSG_G_S_MENU_HELP_7], 12),
 
@@ -1327,10 +1338,12 @@
 
   video_resolution_large();
 
-//  SDL_LockMutex(sound_mutex);
-//  SDL_PauseAudio(1);
-//  sceKernelSleepThread();
-//  SDL_UnlockMutex(sound_mutex);
+  SDL_LockMutex(sound_mutex);
+  SDL_PauseAudio(1);
+  SDL_UnlockMutex(sound_mutex);
+
+  clock_speed_number = (game_config_clock_speed / 33) - 1;
+  set_cpu_clock(222);
 
   if(gamepak_filename[0] == 0)
   {
@@ -1339,6 +1352,12 @@
     print_string_ext(msg[MSG_NON_LOAD_GAME], 0xFFFF, 0x0000, 60, 75,original_screen, 240, 0);
   }
 
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
+    gamepak_file_large = -2;
+  }
+
   choose_menu(&main_menu);
 
   for(i = 0; i < MAX_CHEATS; i++)
@@ -1475,16 +1494,39 @@
 
 // menu終了時の処理
 
+  /* スリープから復帰直後にはファイルを開けない。*/
+  /* タイミングによって、開ける様になるまでの時間にばらつきがある。 */
+  /* すぐにファイル開けるようなら即復帰させたいので、ウェイトは短め */
+  /* でリトライさせる。 */
+  if(gamepak_file_large == -2)
+  {
+    for(i = 0; i < 5; i++)
+    {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    printf("Failed to load gemepak.\n");
+    delay_us(3000000);
+    quit();
+
+    success_open_gamepak:;
+  }
+
   while(sceCtrlPeekBufferPositive(&ctrl_data, 1), ctrl_data.Buttons != 0);
 
   set_gba_resolution(screen_scale);
   video_resolution_small();
 
-  game_config_clock_speed = (clock_speed_number + 1) * 33;
+  game_config_clock_speed = (clock_speed_number + 1) * 333 / 10;
+  set_cpu_clock(game_config_clock_speed);
 
-  scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+  SDL_PauseAudio(0);
 
-//  SDL_PauseAudio(0);
   return return_value;
 }
 
@@ -1910,15 +1952,17 @@
 
 static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
 {
-  int id;
+//  int id;
   char *weekday_strings[] =
   {
     msg[MSG_WDAY_0], msg[MSG_WDAY_1], msg[MSG_WDAY_2], msg[MSG_WDAY_3],
     msg[MSG_WDAY_4], msg[MSG_WDAY_5], msg[MSG_WDAY_6], ""
   };
 
-  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
-  switch(id)
+  /* 表示更新の度にフラッシュから設定を読み込んでいるためメニューの動作が遅い。*/
+//  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
+//  switch(id)
+  switch(date_format)
   {
     case PSP_SYSTEMPARAM_DATE_FORMAT_YYYYMMDD:
       sprintf(buffer, msg[msg_id    ], year, mon, day, weekday_strings[wday], hour, min, sec, msec / 1000);
diff -ru 30_orig/input.c 30_new/input.c
--- 30_orig/input.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/input.c	2007-08-06 23:46:08.000000000 +0900
@@ -104,19 +104,24 @@
     quit();
 
   sceCtrlPeekBufferPositive(&ctrl_data, 1);
-  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
-  if(ctrl_data.Lx < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_LEFT;
+  /* HOLD時アナログPADも動作しないようにする */
+  if(!(ctrl_data.Buttons & PSP_CTRL_HOLD))
+  {
+    if(ctrl_data.Lx < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_LEFT;
 
-  if(ctrl_data.Lx > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_RIGHT;
+    if(ctrl_data.Lx > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_RIGHT;
 
-  if(ctrl_data.Ly < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_UP;
+    if(ctrl_data.Ly < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_UP;
 
-  if(ctrl_data.Ly > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_DOWN;
+    if(ctrl_data.Ly > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_DOWN;
+  }
+
+  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
   new_buttons = (last_buttons ^ ctrl_data.Buttons) & ctrl_data.Buttons;
   last_buttons = ctrl_data.Buttons;
@@ -260,7 +265,8 @@
 
   buttons = ctrl_data.Buttons;
 
-  if(global_enable_analog)
+  /* HOLD時アナログPADも動作しないようにする */
+  if((global_enable_analog) && !(ctrl_data.Buttons & PSP_CTRL_HOLD))
   {
     if(ctrl_data.Lx < analog_sensitivity)
       buttons |= PSP_CTRL_ANALOG_LEFT;
diff -ru 30_orig/main.c 30_new/main.c
--- 30_orig/main.c	2007-08-06 13:57:48.000000000 +0900
+++ 30_new/main.c	2007-08-06 23:47:24.000000000 +0900
@@ -23,8 +23,11 @@
  ******************************************************************************/
 #include "common.h"
 
-PSP_MODULE_INFO("gpSP", PSP_MODULE_KERNEL, VERSION_MAJOR, VERSION_MINOR);
-PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_VFPU);
+// 改造SDLを使用し、カーネルモードに設定
+// PSP_MODULE_INFO("gpSP", 0x1000, VERSION_MAJOR, VERSION_MINOR);
+//PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_USER | PSP_THREAD_ATTR_VFPU);
+// PSP_MAIN_THREAD_ATTR(0);
+
 
 /******************************************************************************
  * 変数の定義
@@ -32,7 +35,7 @@
 
 TIMER_TYPE timer[4];                              // タイマー
 u32 game_config_frameskip_type = auto_frameskip;  // フレームスキップの種類
-u32 game_config_frameskip_value = 4;              // フレームスキップ数
+u32 game_config_frameskip_value = 9;              // フレームスキップ数
 u32 game_config_random_skip = 0;                  // ランダムスキップのon/off
 u32 game_config_clock_speed = 333;                // クロック数
 
@@ -72,7 +75,8 @@
 char main_path[MAX_PATH];
 
 u32 quit_flag;
-u32 power_flag;
+// u32 power_flag;
+u8 sleep_flag;
 
 char *lang[9] =
   { "japanese",   // 0
@@ -87,6 +91,7 @@
     };
 
 int lang_num;
+int date_format;
 
 u32 prescale_table[] = { 0, 6, 8, 10 };
 
@@ -111,7 +116,7 @@
     {                                                                         \
       timer[timer_number].count -= execute_cycles;                            \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale);  \
     }                                                                         \
                                                                               \
     if(timer[timer_number].count <= 0)                                        \
@@ -124,9 +129,12 @@
       {                                                                       \
         timer[timer_number + 1].count--;                                      \
         io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
-        0xFFFF   - (timer[timer_number + 1].count);                          \
+         0xFFFF   - (timer[timer_number + 1].count);                          \
       }                                                                       \
                                                                               \
+      u32 timer_reload                                                        \
+           = timer[timer_number].reload << timer[timer_number].prescale;      \
+                                                                              \
       if(timer_number < 2)                                                    \
       {                                                                       \
         if(timer[timer_number].direct_sound_channels & 0x01)                  \
@@ -134,12 +142,21 @@
                                                                               \
         if(timer[timer_number].direct_sound_channels & 0x02)                  \
           sound_timer(timer[timer_number].frequency_step, 1);                 \
+                                                                              \
+        /* 新しいリロード値は、オーバーフロー後カウンタの値に適用される。*/   \
+        /* リロード値とカウンター値にずれが生じるがどちらを使えばいい  */     \
+        /* のだろうか？ */                                                    \
+        if(timer[timer_number].reload_update)                                 \
+        {                                                                     \
+          sound_update_frequency_step(timer_number);                          \
+          timer[timer_number].reload_update = 0;                              \
+        }                                                                     \
       }                                                                       \
                                                                               \
-      timer[timer_number].count +=                                            \
-       (timer[timer_number].reload << timer[timer_number].prescale);          \
+      timer[timer_number].count += timer_reload;                              \
+                                                                              \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale);  \
     }                                                                         \
   }                                                                           \
 
@@ -149,12 +166,20 @@
 int main(int argc, char *argv[]);
 void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str);
 void trigger_ext_event();
-u32 check_power();
+// u32 check_power();
+void loop_sleep();
 int exit_callback(int arg1, int arg2, void *common);
 int power_callback(int unknown, int powerInfo, void *common);
 int CallbackThread(SceSize args, void *argp);
 int SetupCallbacks();
-int user_main(int argc, char *argv[]);
+
+
+
+void set_cpu_clock(u32 clock)
+{
+  scePowerSetClockFrequency(clock, clock, clock / 2);
+}
+
 
 void init_main()
 {
@@ -187,108 +212,9 @@
   flush_translation_cache_bios();
 }
 
-volatile u32 home_button;
-volatile u32 home_active;
-
-static int home_button_thread(SceSize args, void *argp)
-{
-  SceCtrlData paddata;
-
-  home_active = 1;
-
-  while (home_active)
-  {
-    sceCtrlPeekBufferPositive(&paddata, 1);
-    home_button = paddata.Buttons & PSP_CTRL_HOME;
-    sceKernelDelayThread(200);
-  }
-
-  sceKernelExitThread(0);
-
-  return 0;
-}
-int exit_callback(int arg1, int arg2, void *common)
-{
-  quit_flag = 1;
-  return 0;
-}
-
-int power_callback(int unknown, int powerInfo, void *common)
-{
-  if (powerInfo & PSP_POWER_CB_SUSPENDING) power_flag = 1;
-  return 0;
-}
-
-int CallbackThread(SceSize args, void *argp)
-{
-  int cbid, power_callback_id;
-
-  // 終了周りのコールバック 
-  cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
-  sceKernelRegisterExitCallback(cbid);
-
-  // 電源周りのコールバック 
-  power_callback_id = sceKernelCreateCallback("Power Callback", power_callback, NULL); 
-  scePowerRegisterCallback(0, power_callback_id);
-
-  sceKernelSleepThreadCB();
-
-  return 0;
-}
-
-int SetupCallbacks()
-{
-  int thid = 0;
-
-  thid = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);
-  if (thid >= 0)
-  {
-    sceKernelStartThread(thid, 0, 0);
-  }
-
-  return thid;
-}
-
-void quit()
-{
-//  if(!update_backup_flag)
-    update_backup_force();
-
-  sound_exit();
-  fbm_freeall();
-
-  fclose(dbg_file);
-
-  scePowerSetClockFrequency(222, 222, 111);
-  sceKernelExitThread(0);
-}
-
+// SDL.hにより、SDL_mainとして定義される
 int main(int argc, char *argv[])
 {
-  SceUID main_thread;
-  SceUID home_thread;
-
-  getcwd(main_path, 512);
-
-//  pspSdkLoadAdhocModules();
-
-  home_thread = sceKernelCreateThread("Home Button Thread", home_button_thread, 0x11, 0x200, 0, NULL);
-  main_thread = sceKernelCreateThread("User Mode Thread", user_main, 0x11, 256 * 1024, PSP_THREAD_ATTR_USER, NULL);
-
-  sceKernelStartThread(home_thread, 0, 0);
-
-  sceKernelStartThread(main_thread, 0, 0);
-  sceKernelWaitThreadEnd(main_thread, NULL);
-
-  home_active = 0;
-  sceKernelWaitThreadEnd(home_thread, NULL);
-
-  sceKernelExitGame();
-  return 0;
-}
-
-int user_main(int argc, char *argv[])
-{
 //  u32 i;
 //  u32 vcount = 0;
 //  u32 ticks;
@@ -297,7 +223,8 @@
   char filename[512];
 
   quit_flag = 0;
-  power_flag = 0;
+//  power_flag = 0;
+  sleep_flag = 0;
   SetupCallbacks();
 
   sceKernelRegisterSubIntrHandler(PSP_VBLANK_INT, 0, vblank_interrupt_handler, NULL);
@@ -307,9 +234,10 @@
   dbg_file = fopen(DBG_FILE_NAME, "awb");
 
   // Copy the directory path of the executable into main_path
-//  getcwd(main_path, 512);
-  chdir(main_path);
+  getcwd(main_path, 512);
+
   sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_LANGUAGE, &lang_num);
+  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&date_format);
 
   if (load_dircfg("settings/dir.cfg") != 0)
   {
@@ -336,31 +264,14 @@
     error_msg("font init Error!!");
     quit();
   }
-/*
+/* 起動できないので一時削除
   // adhoc用モジュールのロード
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_COMMON) != 0)
-  {
-    error_msg("not load modules common\n");
-  }
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_INET) != 0)
-  {
-    error_msg("not load modules inet\n");
-  }
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_ADHOC) != 0)
+  if(pspSdkLoadAdhocModules() != 0)
   {
-    error_msg("not load modules adhoc\n");
-  }
-
-  if(pspSdkInetInit() != 0)
-  {
-    error_msg("not init inet\n");
-  }
+    error_msg("not use wlan!!");
+  } */
+//  u32 test = adhocInit("test");
 
-  if (adhocInit("test") != 0)
-  {
-    error_msg("not use wlan!! \n");
-  }
-*/
   init_gamepak_buffer();
 
   load_config_file();
@@ -377,7 +288,7 @@
 
   video_resolution_large();
 
-  u32 bios_ret = load_bios("./gba_bios.bin");
+  u32 bios_ret = load_bios("gba_bios.bin");
 
   if(bios_ret == -1) // 読込めない場合
   {
@@ -406,6 +317,7 @@
 
     init_cpu();
     init_memory();
+    reset_sound();
   }
   else
   {
@@ -432,6 +344,9 @@
   }
 
   last_frame = 0;
+  /* 起動時のファイルリストからromをロードした場合、メニュー終了時の */
+  /* クロック変更が適用されないので、ここでクロック変更。 */
+  set_cpu_clock(game_config_clock_speed);
 
   // We'll never actually return from here.
 
@@ -561,6 +476,7 @@
   event_number++;
 }
 
+/*
 u32 check_power()
   {
     if (power_flag == 0) return 0;
@@ -572,6 +488,46 @@
     FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
     return ret_val;
   }
+*/
+/* スリープ時にファイルを閉じて、復帰後開き直す。 */
+/* 再び開けるようになるまでには、タイミングによってばらつきがある。*/
+
+void loop_sleep()
+{
+  SDL_PauseAudio(1);
+
+  if(FILE_CHECK_VALID(gamepak_file_large))
+  {
+    FILE_CLOSE(gamepak_file_large);
+
+    while(sleep_flag)
+      delay_us(500000);
+
+    u8 i;
+    for(i = 0; i < 5; i++)
+    {
+      FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
+
+      if(gamepak_file_large < 0)
+        delay_us(500000);
+      else
+        goto success_open_gamepak;
+    }
+
+    printf("Failed to load gemepak.\n");
+    delay_us(3000000);
+    quit_flag = 1;
+
+    success_open_gamepak:;
+  }
+  else
+  {
+    while(sleep_flag)
+      delay_us(500000);
+  }
+
+  SDL_PauseAudio(0);
+}
 
 u32 update_gba()
 {
@@ -664,12 +620,15 @@
           dispstat &= ~0x01;
 //          frame_ticks++;
 
+          if(sleep_flag)
+            loop_sleep();
+
           if (update_input())
             continue;
-
+/*
           if (check_power())
             continue;
-
+*/
           if (quit_flag == 1)
             quit();
 
@@ -858,6 +817,20 @@
 */
 }
 
+void quit()
+{
+//  if(!update_backup_flag)
+    update_backup_force();
+
+  sound_exit();
+  fbm_freeall();
+
+  fclose(dbg_file);
+
+  set_cpu_clock(222);
+  sceKernelExitGame();
+}
+
 void reset_gba()
 {
   init_main();
@@ -912,6 +885,57 @@
 void main_write_mem_savestate(FILE_TAG_TYPE savestate_file)
 MAIN_SAVESTATE_BODY(WRITE_MEM);
 
+int exit_callback(int arg1, int arg2, void *common)
+{
+  quit_flag = 1;
+  return 0;
+}
+
+int power_callback(int unknown, int powerInfo, void *common)
+{
+  if(powerInfo & PSP_POWER_CB_SUSPENDING)
+  {
+    sleep_flag = 1;
+  }
+  else
+  if(powerInfo & PSP_POWER_CB_RESUME_COMPLETE)
+  {
+    sleep_flag = 0;
+  }
+  return 0;
+}
+
+int CallbackThread(SceSize args, void *argp)
+{
+  int cbid, power_callback_id;
+
+  // 終了周りのコールバック 
+  cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
+  sceKernelRegisterExitCallback(cbid);
+
+  // 電源周りのコールバック 
+  power_callback_id = sceKernelCreateCallback("Power Callback", power_callback, NULL); 
+  scePowerRegisterCallback(0, power_callback_id);
+
+  sceKernelSleepThreadCB();
+
+  return 0;
+}
+
+int SetupCallbacks()
+{
+  int thid = 0;
+
+  thid = sceKernelCreateThread("update_thread", CallbackThread, 
+    0x11, 0xFA0, 0, 0);
+  if (thid >= 0)
+  {
+    sceKernelStartThread(thid, 0, 0);
+  }
+
+  return thid;
+}
+
 void error_msg(char *text)
 {
     gui_action_type gui_action = CURSOR_NONE;
diff -ru 30_orig/main.h 30_new/main.h
--- 30_orig/main.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/main.h	2007-08-06 23:46:36.000000000 +0900
@@ -46,6 +46,7 @@
 {
   s32 count;
   u32 reload;
+  u8 reload_update;
   u32 prescale;
   u32 stop_cpu_ticks;
   FIXED16_16 frequency_step;
@@ -93,6 +94,9 @@
 extern u32 num_skipped_frames;
 extern u64 frame_count_initial_timestamp;
 
+extern int date_format;
+void set_cpu_clock(u32 clock);
+
 u32 update_gba();
 void reset_gba();
 void synchronize();
@@ -110,12 +114,7 @@
 
 #define count_timer(timer_number)                                             \
   timer[timer_number].reload = 0x10000 - value;                               \
-  if(timer_number < 2)                                                        \
-  {                                                                           \
-    u32 timer_reload =                                                        \
-     timer[timer_number].reload << timer[timer_number].prescale;              \
-    sound_update_frequency_step(timer_number);                                \
-  }                                                                           \
+  timer[timer_number].reload_update = 1                                       \
 
 #define adjust_sound_buffer(timer_number, channel)                            \
   if(timer[timer_number].direct_sound_channels & (0x01 << channel))           \
@@ -154,7 +153,7 @@
       {                                                                       \
         u32 buffer_adjust =                                                   \
          (u32)(((float)(cpu_ticks - timer[timer_number].stop_cpu_ticks) *     \
-         SOUND_FREQUENCY) / 16777216.0) * 2;                                  \
+         sound_frequency) / 16777216.0) * 2;                                  \
                                                                               \
         sound_update_frequency_step(timer_number);                            \
         adjust_sound_buffer(timer_number, 0);                                 \
diff -ru 30_orig/memory.c 30_new/memory.c
--- 30_orig/memory.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/memory.c	2007-08-06 23:47:14.000000000 +0900
@@ -68,40 +68,39 @@
 
 // This table is configured for sequential access on system defaults
 
-u32 waitstate_cycles_sequential[16][3] =
+// read data (sequential)
+u8 waitstate_cycles_seq[2][16] =
 {
-  { 1, 1, 1 }, // BIOS
-  { 1, 1, 1 }, // Invalid
-  { 3, 3, 6 }, // EWRAM (default settings)
-  { 1, 1, 1 }, // IWRAM
-  { 1, 1, 1 }, // IO Registers
-  { 1, 1, 2 }, // Palette RAM
-  { 1, 1, 2 }, // VRAM
-  { 1, 1, 2 }, // OAM
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 9, 9, 17 }, // Gamepak (wait 2)
-  { 9, 9, 17 }, // Gamepak (wait 2)
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
+};
+
+// read data (non sequential)
+u8 waitstate_cycles_non_seq[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 7, 7, 9, 9,13,13, 1, 1 }  /* 32bit */
 };
 
 // Different settings for gamepak ws0-2 sequential (2nd) access
 
-u32 gamepak_waitstate_sequential[2][3][3] =
+u8 gamepak_waitstate_seq[2][2][3] =
 {
-  {
-    { 3, 3, 6 },
-    { 5, 5, 9 },
-    { 9, 9, 17 }
-  },
-  {
-    { 2, 2, 3 },
-    { 2, 2, 3 },
-    { 2, 2, 3 }
-  }
+  {{ 3, 5, 9 }, { 5, 9,17 }},
+  {{ 2, 2, 2 }, { 3, 3, 3 }}
 };
 
+// read opecode
+u8 cpu_waitstate_cycles_seq[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
+};
+
+
 u16 palette_ram[512];
 u16 oam_ram[512];
 u16 palette_ram_converted[512];
@@ -465,9 +464,16 @@
     case 0x00:                                                                \
       /* BIOS */                                                              \
       if(reg[REG_PC] >= 0x4000)                                               \
-        value = ADDRESS##type(&bios_read_protect, address & 0x03);            \
+      {                                                                       \
+        if(address < 0x4000)                                                  \
+          value = ADDRESS##type(&bios_read_protect, address & 0x03);          \
+        else                                                                  \
+          read_open##type();                                                  \
+      }                                                                       \
       else                                                                    \
+      {                                                                       \
         value = ADDRESS##type(bios_rom, address & 0x3FFF);                    \
+      }                                                                       \
       break;                                                                  \
                                                                               \
     case 0x02:                                                                \
@@ -482,7 +488,10 @@
                                                                               \
     case 0x04:                                                                \
       /* I/O registers */                                                     \
-      value = ADDRESS##type(io_registers, address & 0xFFF);                   \
+      if(address < 0x04000400)                                                \
+        value = ADDRESS##type(io_registers, address & 0x3FF);                 \
+      else                                                                    \
+        read_open##type();                                                    \
       break;                                                                  \
                                                                               \
     case 0x05:                                                                \
@@ -492,11 +501,10 @@
                                                                               \
     case 0x06:                                                                \
       /* VRAM */                                                              \
-      address &= 0x1FFFF;                                                     \
-      if(address >= 0x18000)                                                  \
-        address -= 0x8000;                                                    \
-                                                                              \
-      value = ADDRESS##type(vram, address);                                   \
+      if(address & 0x10000)                                                   \
+        value = ADDRESS##type(vram, address & 0x17FFF);                       \
+      else                                                                    \
+        value = ADDRESS##type(vram, address & 0x1FFFF);                       \
       break;                                                                  \
                                                                               \
     case 0x07:                                                                \
@@ -504,11 +512,7 @@
       value = ADDRESS##type(oam_ram, address & 0x3FF);                        \
       break;                                                                  \
                                                                               \
-    case 0x08:                                                                \
-    case 0x09:                                                                \
-    case 0x0A:                                                                \
-    case 0x0B:                                                                \
-    case 0x0C:                                                                \
+    case 0x08 ... 0x0C:                                                       \
       /* gamepak ROM */                                                       \
       if((address & 0x1FFFFFF) >= gamepak_size)                               \
       {                                                                       \
@@ -612,6 +616,67 @@
   }                                                                           \
 
 
+// configure game pak access timings
+#define waitstate_control()                                                   \
+{                                                                             \
+  u8 i;                                                                       \
+  u8 waitstate_table[4] = { 5, 4, 3, 9 };                                     \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x0e] = waitstate_cycles_seq[0][0x0e]           \
+   = waitstate_table[value & 0x03];                                           \
+                                                                              \
+  for(i = 0; i < 2; i++)                                                      \
+  {                                                                           \
+    waitstate_cycles_seq[i][0x08] = waitstate_cycles_seq[i][0x09]             \
+     = gamepak_waitstate_seq[(value >> 4) & 0x01][i][0];                      \
+    waitstate_cycles_seq[i][0x0A] = waitstate_cycles_seq[i][0x0B]             \
+     = gamepak_waitstate_seq[(value >> 7) & 0x01][i][1];                      \
+    waitstate_cycles_seq[i][0x0C] = waitstate_cycles_seq[i][0x0D]             \
+     = gamepak_waitstate_seq[(value >> 10) & 0x01][i][2];                     \
+  }                                                                           \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x08] = waitstate_cycles_non_seq[0][0x09]       \
+   = waitstate_table[(value >> 2) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0A] = waitstate_cycles_non_seq[0][0x0B]       \
+   = waitstate_table[(value >> 5) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0C] = waitstate_cycles_non_seq[0][0x0D]       \
+   = waitstate_table[(value >> 8) & 0x03];                                    \
+                                                                              \
+  /* 32bit access ( split into two 16bit accsess ) */                         \
+  waitstate_cycles_non_seq[1][0x08] = waitstate_cycles_non_seq[1][0x09]       \
+   = (waitstate_cycles_non_seq[0][0x08] + waitstate_cycles_seq[0][0x08] - 1); \
+  waitstate_cycles_non_seq[1][0x0A] = waitstate_cycles_non_seq[1][0x0B]       \
+   = (waitstate_cycles_non_seq[0][0x0A] + waitstate_cycles_seq[0][0x0A] - 1); \
+  waitstate_cycles_non_seq[1][0x0C] = waitstate_cycles_non_seq[1][0x0D]       \
+  =  (waitstate_cycles_non_seq[0][0x0C] + waitstate_cycles_seq[0][0x0C] - 1); \
+                                                                              \
+  /* gamepak prefetch */                                                      \
+  if(value & 0x4000)                                                          \
+  {                                                                           \
+    for(i = 0x08; i <= 0x0D; i++)                                             \
+    {                                                                         \
+      cpu_waitstate_cycles_seq[0][i] = 1;                                     \
+      cpu_waitstate_cycles_seq[1][i] = 2;                                     \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    for(i = 0; i < 2; i++)                                                    \
+    {                                                                         \
+      cpu_waitstate_cycles_seq[i][0x08] = cpu_waitstate_cycles_seq[i][0x09]   \
+       = waitstate_cycles_seq[i][0x08];                                       \
+      cpu_waitstate_cycles_seq[i][0x0A] = cpu_waitstate_cycles_seq[i][0x0B]   \
+       = waitstate_cycles_seq[i][0x0A];                                       \
+      cpu_waitstate_cycles_seq[i][0x0C] = cpu_waitstate_cycles_seq[i][0x0D]   \
+       = waitstate_cycles_seq[i][0x0C];                                       \
+    }                                                                         \
+  }                                                                           \
+                                                                              \
+  ADDRESS16(io_registers, 0x204) =                                            \
+   (ADDRESS16(io_registers, 0x204) & 0x8000) | (value & 0x7FFF);              \
+}                                                                             \
+
+
 #define access_register8_high(address)                                        \
   value = (value << 8) | (ADDRESS8(io_registers, address))                    \
 
@@ -648,6 +713,7 @@
     // VCOUNT
     case 0x06:
     case 0x07:
+      /* Read only */
       break;
 
     // BG2 reference X
@@ -773,7 +839,7 @@
       break;
 
     case 0x61:
-      access_register8_low(0x60);
+      access_register8_high(0x60);
       gbc_sound_tone_control_sweep();
       break;
 
@@ -910,33 +976,35 @@
       break;
 
     // Sound FIFO A
-    case 0xA0:
-      sound_timer_queue8(0, value);
+    case 0xA0 ... 0xA3:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
-    case 0xA4:
-      sound_timer_queue8(1, value);
+    case 0xA4 ... 0xA7:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control (trigger byte)
     case 0xBB:
-      access_register8_low(0xBA);
+      access_register8_high(0xBA);
       trigger_dma(0);
       break;
 
     case 0xC7:
-      access_register8_low(0xC6);
+      access_register8_high(0xC6);
       trigger_dma(1);
       break;
 
     case 0xD3:
-      access_register8_low(0xD2);
+      access_register8_high(0xD2);
       trigger_dma(2);
       break;
 
     case 0xDF:
-      access_register8_low(0xDE);
+      access_register8_high(0xDE);
       trigger_dma(3);
       break;
 
@@ -983,25 +1051,31 @@
 
     // Timer control (trigger byte)
     case 0x103:
-      access_register8_low(0x102);
+      access_register8_high(0x102);
       trigger_timer(0);
       break;
 
     case 0x107:
-      access_register8_low(0x106);
+      access_register8_high(0x106);
       trigger_timer(1);
       break;
 
     case 0x10B:
-      access_register8_low(0x10A);
+      access_register8_high(0x10A);
       trigger_timer(2);
       break;
 
     case 0x10F:
-      access_register8_low(0x10E);
+      access_register8_high(0x10E);
       trigger_timer(3);
       break;
 
+    // P1
+    case 0x130:
+    case 0x131:
+      /* Read only */
+      break;
+
     // RCNT
     case 0x134:
       ADDRESS16(io_registers, 0x134) = value;
@@ -1009,22 +1083,29 @@
 
     // IF
     case 0x202:
-      ADDRESS8(io_registers, 0x202) &= ~value;
+    case 0x203:
+      ADDRESS8(io_registers, address) &= ~value;
       break;
 
-    case 0x203:
-      ADDRESS8(io_registers, 0x203) &= ~value;
+    // WAITCNT
+    case 0x204:
+      access_register8_low(0x204);
+      waitstate_control();
+      break;
+
+    case 0x205:
+      access_register8_high(0x204);
+      waitstate_control();
       break;
 
     // Halt
     case 0x301:
-      if((value & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x80)
         reg[CPU_HALT_STATE] = CPU_STOP;
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
 
       return CPU_ALERT_HALT;
-      break;
 
     default:
       ADDRESS8(io_registers, address) = value;
@@ -1056,6 +1137,7 @@
 
     // VCOUNT
     case 0x06:
+      /* Read only */
       break;
 
     // BG2 reference X
@@ -1184,12 +1266,16 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue16(0, value);
+    case 0xA2:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue16(1, value);
+    case 0xA6:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control
@@ -1245,6 +1331,7 @@
 
     // P1
     case 0x130:
+      /* Read only */
       break;
 
     // RCNT
@@ -1259,14 +1346,15 @@
 
     // WAITCNT
     case 0x204:
+      waitstate_control();
       break;
 
     // Halt
     case 0x300:
-      if(((value >> 8) & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x8000)
         reg[CPU_HALT_STATE] = CPU_STOP;
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
 
       return CPU_ALERT_HALT;
 
@@ -1309,12 +1397,14 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue32(0, value);
+      ADDRESS32(io_registers, 0xA0) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue32(1, value);
+      ADDRESS32(io_registers, 0xA4) = value;
+      sound_timer_queue32(1);
       break;
 
     default:
@@ -1336,6 +1426,13 @@
 }
 
 #define write_palette8(address, value)                                        \
+{                                                                             \
+  u32 palette_address = address & ~0x01;                                      \
+  u16 double_value = ((value << 8) | value);                                  \
+  ADDRESS16(palette_ram, palette_address) = double_value;                     \
+  CONVERT_PALETTE(double_value);                                              \
+  ADDRESS16(palette_ram_converted, palette_address) = double_value;           \
+}                                                                             \
 
 #define write_palette16(address, value)                                       \
 {                                                                             \
@@ -1493,14 +1590,35 @@
 #define write_backup32()                                                      \
 
 #define write_vram8()                                                         \
-  address &= ~0x01;                                                           \
-  ADDRESS16(vram, address) = ((value << 8) | value)                           \
+  if(address & 0x10000)                                                       \
+    ADDRESS16(vram, address & 0x17FFe) = ((value << 8) | value);              \
+  else                                                                        \
+    ADDRESS16(vram, address & 0x1FFFe) = ((value << 8) | value)               \
 
 #define write_vram16()                                                        \
-  ADDRESS16(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+    ADDRESS16(vram, address & 0x17FFF) = value;                               \
+  else                                                                        \
+    ADDRESS16(vram, address & 0x1FFFF) = value                                \
 
 #define write_vram32()                                                        \
-  ADDRESS32(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+    ADDRESS32(vram, address & 0x17FFF) = value;                               \
+  else                                                                        \
+    ADDRESS32(vram, address & 0x1FFFF) = value                                \
+
+
+#define write_oam_ram8()                                                      \
+/*  Write 8bit data is ignore */                                              \
+
+#define write_oam_ram16()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS16(oam_ram, address & 0x3FF) = value                                 \
+
+#define write_oam_ram32()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS32(oam_ram, address & 0x3FF) = value                                 \
+
 
 // RTC code derived from VBA's (due to lack of any real publically available
 // documentation...)
@@ -1783,7 +1901,9 @@
                                                                               \
     case 0x04:                                                                \
       /* I/O registers */                                                     \
-      return write_io_register##type(address & 0xFFF, value);                 \
+      if(address < 0x04000400)                                                \
+        return write_io_register##type(address & 0x3FF, value);               \
+      break;                                                                  \
                                                                               \
     case 0x05:                                                                \
       /* palette RAM */                                                       \
@@ -1792,17 +1912,12 @@
                                                                               \
     case 0x06:                                                                \
       /* VRAM */                                                              \
-      address &= 0x1FFFF;                                                     \
-      if(address >= 0x18000)                                                  \
-        address -= 0x8000;                                                    \
-                                                                              \
       write_vram##type();                                                     \
       break;                                                                  \
                                                                               \
     case 0x07:                                                                \
       /* OAM RAM */                                                           \
-      oam_update = 1;                                                         \
-      ADDRESS##type(oam_ram, address & 0x3FF) = value;                        \
+      write_oam_ram##type();                                                  \
       break;                                                                  \
                                                                               \
     case 0x08:                                                                \
@@ -1810,10 +1925,6 @@
       write_rtc##type();                                                      \
       break;                                                                  \
                                                                               \
-    case 0x09 ... 0x0C:                                                       \
-      /* gamepak ROM space */                                                 \
-      break;                                                                  \
-                                                                              \
     case 0x0D:                                                                \
       write_eeprom(address, value);                                           \
       break;                                                                  \
@@ -1821,6 +1932,10 @@
     case 0x0E:                                                                \
       write_backup##type();                                                   \
       break;                                                                  \
+                                                                              \
+    default:                                                                  \
+      /* unwritable */                                                        \
+      break;                                                                  \
   }                                                                           \
 
 u8 read_memory8(u32 address)
@@ -2103,6 +2218,7 @@
   bios_rom[0x2C] = 0x00;
   translation_gate_targets = 0;
   flash_device_id = FLASH_DEVICE_MACRONIX_64KB;
+  backup_type = BACKUP_NONE;
 
   sprintf(config_path, "%s/%s", main_path, CONFIG_FILENAME);
 
@@ -2115,22 +2231,22 @@
       if(parse_config_line(current_line, current_variable, current_value)
        != -1)
       {
-        if(strcmp(current_variable, "game_name") ||
-         strcmp(current_value, gamepak_title))
+        if(strcasecmp(current_variable, "game_name") ||
+         strcasecmp(current_value, gamepak_title))
           continue;
 
         if(!fgets(current_line, 256, config_file) ||
          (parse_config_line(current_line, current_variable,
            current_value) == -1) ||
-         strcmp(current_variable, "game_code") ||
-         strcmp(current_value, gamepak_code))
+         strcasecmp(current_variable, "game_code") ||
+         strcasecmp(current_value, gamepak_code))
           continue;
 
         if(!fgets(current_line, 256, config_file) ||
          (parse_config_line(current_line, current_variable,
            current_value) == -1) ||
-         strcmp(current_variable, "vender_code") ||
-          strcmp(current_value, gamepak_maker))
+         strcasecmp(current_variable, "vender_code") ||
+          strcasecmp(current_value, gamepak_maker))
           continue;
 
         while(fgets(current_line, 256, config_file))
@@ -2138,13 +2254,13 @@
           if(parse_config_line(current_line, current_variable, current_value)
            != -1)
           {
-            if(!strcmp(current_variable, "game_name"))
+            if(!strcasecmp(current_variable, "game_name"))
             {
               fclose(config_file);
               return 0;
             }
 
-            if(!strcmp(current_variable, "idle_loop_eliminate_target"))
+            if(!strcasecmp(current_variable, "idle_loop_eliminate_target"))
             {
               if(idle_loop_targets < MAX_IDLE_LOOPS)
               {
@@ -2154,7 +2270,7 @@
               }
             }
 
-            if(!strcmp(current_variable, "translation_gate_target"))
+            if(!strcasecmp(current_variable, "translation_gate_target"))
             {
               if(translation_gate_targets < MAX_TRANSLATION_GATES)
               {
@@ -2164,26 +2280,42 @@
               }
             }
 
-            if(!strcmp(current_variable, "iwram_stack_optimize") &&
-              !strcmp(current_value, "no"))
+            if(!strcasecmp(current_variable, "iwram_stack_optimize") &&
+              !strcasecmp(current_value, "no"))
             {
                 iwram_stack_optimize = 0;
             }
 
-            if(!strcmp(current_variable, "flash_rom_type") &&
-              !strcmp(current_value, "128KB"))
+            if(!strcasecmp(current_variable, "flash_rom_type") &&
+              !strcasecmp(current_value, "128KB"))
             {
               flash_device_id = FLASH_DEVICE_MACRONIX_128KB;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_39") &&
-              !strcmp(current_value, "yes"))
+            /* eepromだけでも良いのですが、なんとなく全部指定できるように。 */
+            /* DBZLGCYGOKU2 のプロテクト回避。 */
+            /* EEPROM_V124で特殊な物(現在判別不可) で指定すれば動作可。*/
+
+            if(!strcasecmp(current_variable, "save_type"))
+            {
+              if(!strcasecmp(current_value, "sram"))
+                backup_type = BACKUP_SRAM;
+              else
+              if(!strcasecmp(current_value, "flash"))
+                backup_type = BACKUP_FLASH;
+              else
+              if(!strcasecmp(current_value, "eeprom"))
+                backup_type = BACKUP_EEPROM;
+            }
+
+            if(!strcasecmp(current_variable, "bios_rom_hack_39") &&
+              !strcasecmp(current_value, "yes"))
             {
               bios_rom[0x39] = 0xC0;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_2C") &&
-              !strcmp(current_value, "yes"))
+            if(!strcasecmp(current_variable, "bios_rom_hack_2C") &&
+              !strcasecmp(current_value, "yes"))
             {
                bios_rom[0x2C] = 0x02;
             }
@@ -2210,27 +2342,26 @@
   {
     u32 gamepak_size = file_length(name, gamepak_file);
 
-    // First, close the last one if it was open, we won't
-    // be needing it anymore.
-    if(FILE_CHECK_VALID(gamepak_file_large))
-      FILE_CLOSE(gamepak_file_large);
-
     // If it's a big file size keep it don't close it, we'll
     // probably want to load it later
     if(gamepak_size <= gamepak_ram_buffer_size)
     {
       FILE_READ(gamepak_file, gamepak_rom, gamepak_size);
       FILE_CLOSE(gamepak_file);
-
-      gamepak_file_large = -1;
     }
     else
     {
       // Read in just enough for the header
       FILE_READ(gamepak_file, gamepak_rom, 0x100);
       gamepak_file_large = gamepak_file;
-      strcpy(gamepak_filename_raw, name);
+//      strcpy(gamepak_filename_raw, name);
 //      FILE_CLOSE(gamepak_file);
+      /* ファイルリストでカレントディレクトリを変更された場合 */
+      /* ファイルが読めなくなるので、フルパス指定。*/
+      /* 適当なのが無かったのですが、こんなコードで良いのかは？？ */
+      getcwd(gamepak_filename_raw, 512);
+      strcat(gamepak_filename_raw, "/");
+      strcat(gamepak_filename_raw, name);
     }
 
     return gamepak_size;
@@ -2239,16 +2370,32 @@
   return -1;
 }
 
-u32 load_gamepak(char *name)
+s32 load_gamepak(char *name)
 {
   char *dot_position = strrchr(name, '.');
   s32 file_size;
   char cheats_filename[256];
 
-  if(!strcmp(dot_position, ".zip"))
+/* zip romをロードする場合、オープンのままなのでここへ。*/
+/* 今は、メニューに入るときにクローズしているので不要。*/
+  // First, close the last one if it was open, we won't
+  // be needing it anymore.
+//  if(FILE_CHECK_VALID(gamepak_file_large))
+//    FILE_CLOSE(gamepak_file_large);
+
+  gamepak_file_large = -1;
+
+  if(!strcasecmp(dot_position, ".zip"))
+  {
+    /* メニューで222Mに変更したので333Mへ。変更しないのであれば不要 */
+    /* rom 16Mだと数秒展開の時間が違います。*/
+    set_cpu_clock(333); 
     file_size = load_file_zip(name);
+  }
   else
+  {
     file_size = load_gamepak_raw(name);
+  }
 
   if(file_size != -1)
   {
@@ -2380,6 +2527,11 @@
   dma_smc_vars_##type()                                                       \
 
 #define dma_vars_vram(type)                                                   \
+  if(type##_ptr & 0x10000)                                                    \
+    type##_ptr &= ~0x08000                                                    \
+/* vramのread,writeでアドレスを変更するとスプライトが表示されないことがある */
+/* とりあえず、ここで変更。*/
+/* 例）逆転裁判のいとのこさん、腕とか頭が欠ける。 */
 
 #define dma_vars_palette_ram(type)                                            \
 
@@ -2528,7 +2680,7 @@
 #define dma_epilogue_ext()                                                    \
 
 #define print_line()                                                          \
-  dma_print(src_op, dest_op, transfer_size, wb);                              \
+  dma_print(src_op, dest_op, transfer_size, wb)                               \
 
 #define dma_transfer_loop_region(src_region_type, dest_region_type, src_op,   \
  dest_op, transfer_size, wb)                                                  \
@@ -2549,7 +2701,7 @@
   break;                                                                      \
 }                                                                             \
 
-#define dma_transfer_loop(src_op, dest_op, transfer_size, wb);                \
+#define dma_transfer_loop(src_op, dest_op, transfer_size, wb)                 \
 {                                                                             \
   u32 src_region = src_ptr >> 24;                                             \
   u32 dest_region = dest_ptr >> 24;                                           \
@@ -2896,14 +3048,14 @@
   {
     src_ptr &= ~0x01;
     dest_ptr &= ~0x01;
-    cycle_dma16_words += length;
+//    cycle_dma16_words += length;
     dma_transfer_expand(16);
   }
   else
   {
     src_ptr &= ~0x03;
     dest_ptr &= ~0x03;
-    cycle_dma32_words += length;
+//    cycle_dma32_words += length;
     dma_transfer_expand(32);
   }
 
@@ -3131,7 +3283,7 @@
   map_ram_region(read, 0x3000000, 0x4000000, 1, iwram);
   map_region(read, 0x4000000, 0x5000000, 1, io_registers);
   map_null(read, 0x5000000, 0x6000000);
-  map_null(read, 0x6000000, 0x7000000);
+//  map_null(read, 0x6000000, 0x7000000);
   map_vram(read);
   map_null(read, 0x7000000, 0x8000000);
   init_memory_gamepak();
@@ -3184,7 +3336,7 @@
   io_registers[REG_BG3PD] = 0x100;
   io_registers[REG_RCNT] = 0x8000;
 
-  backup_type = BACKUP_NONE;
+//  backup_type = BACKUP_NONE;
 
   sram_size = SRAM_SIZE_32KB;
   flash_size = FLASH_SIZE_64KB;
@@ -3243,7 +3395,7 @@
     u32 i;
     u32 current_color;
 
-    u32 file_size = file_length(savestate_path, (s32)NULL);
+    u32 file_size = file_length(savestate_path, savestate_file);
     if (file_size == SAVESTATE_SIZE)
       FILE_SEEK(savestate_file, (240 * 160 * 2) + sizeof(u64), SEEK_SET);
     else
diff -ru 30_orig/memory.h 30_new/memory.h
--- 30_orig/memory.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/memory.h	2007-08-06 23:46:28.000000000 +0900
@@ -185,7 +185,7 @@
 extern CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma);
 extern u8 *memory_region(u32 address, u32 *memory_limit);
 extern s32 load_bios(char *name);
-extern u32 load_gamepak(char *name);
+extern s32 load_gamepak(char *name);
 extern u8 *load_gamepak_page(u32 physical_index);
 extern u32 load_backup(char *name);
 extern void init_memory();
diff -ru 30_orig/mips_emit.h 30_new/mips_emit.h
--- 30_orig/mips_emit.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/mips_emit.h	2007-08-06 23:45:02.000000000 +0900
@@ -821,12 +821,12 @@
 
 #define generate_shift_reg_lsr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_lsr_flags_reg)                    \
 
 #define generate_shift_reg_asr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_asr_flags_reg)                    \
 
 #define generate_shift_reg_ror_flags(_rm, _rs)                                \
@@ -949,7 +949,7 @@
   u32 _address = (u32)(address);                                              \
   u32 _address_hi = (_address + 0x8000) >> 16;                                \
   generate_load_imm(ireg, address);                                           \
-  mips_emit_lui(ireg, _address_hi >> 16)                                      \
+  mips_emit_lui(ireg, _address_hi >> 16);                                     \
   generate_load_memory_##type(ireg, _address - (_address_hi << 16));          \
 }                                                                             \
 
@@ -1410,7 +1410,8 @@
 
 #define generate_op_adcs_reg(_rd, _rn, _rm)                                   \
   mips_emit_addu(reg_temp, _rm, reg_c_cache);                                 \
-  generate_add_flags_prologue(_rn, _rm);                                      \
+/*  generate_add_flags_prologue(_rn, _rm); */                                 \
+  generate_add_flags_prologue(_rn, reg_temp);                                 \
   mips_emit_addu(_rd, _rn, reg_temp);                                         \
   generate_add_flags_epilogue(_rd)                                            \
 
@@ -1537,20 +1538,54 @@
   arm_generate_op_imm(name, load_op)                                          \
 
 
+/* 1S+x+y */
+/* x=1I cycles if Op2 shifted-by-register. y=1S+1N cycles if Rd=R15. */
+#define cycle_arm_data_proc_reg()                                             \
+  cycle_count++;                                                              \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_reg_flags()                                       \
+  cycle_arm_data_proc_reg()                                                   \
+
+#define cycle_arm_data_proc_imm()                                             \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_imm_flags()                                       \
+  cycle_arm_data_proc_imm()                                                   \
+
+/* 1S+x */
+#define cycle_arm_data_proc_test_reg()                                        \
+  cycle_count++                                                               \
+
+#define cycle_arm_data_proc_test_reg_flags()                                  \
+  cycle_arm_data_proc_test_reg()                                              \
+
+#define cycle_arm_data_proc_test_imm()                                        \
+
+#define cycle_arm_data_proc_test_imm_flags()                                  \
+
+/* AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, ORR, BIC  1S+x+y */
 #define arm_data_proc(name, type, flags_op)                                   \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
+/* TST, TEQ, CMP, CMN  1S+x */
 #define arm_data_proc_test(name, type)                                        \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_test_##type();                                          \
 }                                                                             \
 
+/* MOV, MVN  1S+x+y */
 #define arm_data_proc_unary(name, type, flags_op)                             \
 {                                                                             \
   arm_generate_op_##type(name, no);                                           \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
@@ -1566,9 +1601,36 @@
   mips_emit_mflo(reg_temp);                                                   \
   mips_emit_addu(arm_to_mips_reg[rd], reg_temp, arm_to_mips_reg[rn])          \
 
+u32 cycle_multiply(_rs)
+{
+  u32 mult_rs = arm_to_mips_reg[_rs];
+  if(((s32)mult_rs) < 0)
+    mult_rs = ~mult_rs;
+
+  if((mult_rs & 0xFFFFFF00) == 0)  /* m=1 for Bit 31-8 */
+    return 1;
+  else
+  if((mult_rs & 0xFFFF0000) == 0)  /* m=2 for Bit 31-16 */
+    return 2;
+  else
+  if((mult_rs & 0xFF000000) == 0)  /* m=3 for Bit 31-24 */
+    return 3;
+  else                             /* m=4 otherwise */
+    return 4;
+}
+
+/* 1S+mI */
+#define cycle_arm_multiply_add_no()                                           \
+  cycle_count += cycle_multiply(rs)                                           \
+
+/* 1S+mI+1I */
+#define cycle_arm_multiply_add_yes()                                          \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
 #define arm_multiply(add_op, flags)                                           \
 {                                                                             \
   arm_decode_multiply();                                                      \
+  cycle_arm_multiply_add_##add_op();                                          \
   mips_emit_multu(arm_to_mips_reg[rm], arm_to_mips_reg[rs]);                  \
   arm_multiply_add_##add_op();                                                \
   arm_multiply_flags_##flags(arm_to_mips_reg[rd]);                            \
@@ -1590,9 +1652,18 @@
 #define arm_multiply_long_add_no(name)                                        \
   generate_multiply_##name()                                                  \
 
+/* 1S+mI+1I */
+#define cycle_arm_multiply_long_add_no()                                      \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
+/* 1S+mI+2I */
+#define cycle_arm_multiply_long_add_yes()                                     \
+  cycle_count += 2 + cycle_multiply(rs)                                       \
+
 #define arm_multiply_long(name, add_op, flags)                                \
 {                                                                             \
   arm_decode_multiply_long();                                                 \
+  cycle_arm_multiply_long_add_##add_op();                                     \
   arm_multiply_long_add_##add_op(name);                                       \
   mips_emit_mflo(arm_to_mips_reg[rdlo]);                                      \
   mips_emit_mfhi(arm_to_mips_reg[rdhi]);                                      \
@@ -1642,15 +1713,50 @@
   arm_psr_##transfer_type(op_type, psr_reg);                                  \
 }                                                                             \
 
+/* LDR: 1S+1N+1I. LDR PC: 2S+2N+1I. STR: 2N. */
+#define cycle_arm_access_memory_load_u32()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_u16()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_s16()                                    \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_u8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_s8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_store_u32()                                   \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_u16()                                   \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_s16()                                   \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_u8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_s8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
 #define arm_access_memory_load(mem_type)                                      \
-  cycle_count += 2;                                                           \
+  cycle_arm_access_memory_load_##mem_type();                                  \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 8));                                         \
   generate_store_reg(reg_rv, rd);                                             \
   check_store_reg_pc_no_flags(rd)                                             \
 
 #define arm_access_memory_store(mem_type)                                     \
-  cycle_count++;                                                              \
+  cycle_arm_access_memory_store_##mem_type();                                 \
   generate_load_pc(reg_a2, (pc + 4));                                         \
   generate_load_reg_pc(reg_a1, rd, 12);                                       \
   generate_function_call_swap_delay(execute_store_##mem_type)                 \
@@ -1737,11 +1843,22 @@
 #define sprint_yes(access_type, pre_op, post_op, wb)                          \
   printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
 
+/* LDM, nS+1N+1I. LDM PC, (n+1)S+2N+1I. STM (n-1)S+2N. */
 #define arm_block_memory_load()                                               \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define arm_block_memory_store()                                              \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_load_reg_pc(reg_a1, i, 8);                                         \
   generate_function_call_swap_delay(execute_aligned_store32)                  \
 
@@ -1754,10 +1871,13 @@
   generate_load_reg(reg_a1, i)                                                \
 
 #define arm_block_memory_adjust_pc_store()                                    \
+  cycle_count++;                                                              \
 
 #define arm_block_memory_adjust_pc_load()                                     \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_mov(reg_a0, reg_rv);                                             \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
@@ -1775,8 +1895,10 @@
 #define arm_block_memory_sp_adjust_pc_store()                                 \
 
 #define arm_block_memory_sp_adjust_pc_load()                                  \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
 
@@ -1847,7 +1969,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -1866,149 +1987,6 @@
   }                                                                           \
 }                                                                             \
 
-#define arm_block_writeback_no()
-
-#define arm_block_writeback_yes()                                             \
-  mips_emit_addu(arm_to_mips_reg[rn], reg_a2, reg_zero)                       \
-
-#define arm_block_address_preadjust_up_full(wb)                               \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   ((word_bit_count(reg_list)) * 4));                                         \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_up(wb)                                    \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn], 4);                            \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down_full(wb)                             \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -((word_bit_count(reg_list)) * 4));                                        \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down(wb)                                  \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -(((word_bit_count(reg_list)) * 4) - 4));                                  \
-  arm_block_writeback_##wb()
-
-#define arm_block_address_preadjust_no(wb)                                    \
-  mips_emit_addu(reg_a2, arm_to_mips_reg[rn], reg_zero)                       \
-
-#define arm_block_address_postadjust_no()                                     \
-
-#define arm_block_address_postadjust_up()                                     \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   ((word_bit_count(reg_list)) * 4))                                          \
-
-#define arm_block_address_postadjust_down()                                   \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   -((word_bit_count(reg_list)) * 4))                                         \
-
-#define sprint_no(access_type, pre_op, post_op, wb)                           \
-
-#define sprint_yes(access_type, pre_op, post_op, wb)                          \
-  printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
-
-#define arm_block_memory_load()                                               \
-  generate_function_call_swap_delay(execute_aligned_load32);                  \
-  generate_store_reg(reg_rv, i)                                               \
-
-#define arm_block_memory_store()                                              \
-  generate_load_reg_pc(reg_a1, i, 8);                                         \
-  generate_function_call_swap_delay(execute_aligned_store32)                  \
-
-#define arm_block_memory_final_load()                                         \
-  arm_block_memory_load()                                                     \
-
-#define arm_block_memory_final_store()                                        \
-  generate_load_pc(reg_a2, (pc + 4));                                         \
-  mips_emit_jal(mips_absolute_offset(execute_store_u32));                     \
-  generate_load_reg(reg_a1, i)                                                \
-
-#define arm_block_memory_adjust_pc_store()                                    \
-
-#define arm_block_memory_adjust_pc_load()                                     \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_mov(reg_a0, reg_rv);                                             \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define arm_block_memory_sp_load()                                            \
-  mips_emit_lw(arm_to_mips_reg[i], reg_a1, offset);                           \
-
-#define arm_block_memory_sp_store()                                           \
-{                                                                             \
-  u32 store_reg = i;                                                          \
-  check_load_reg_pc(arm_reg_a0, store_reg, 8);                                \
-  mips_emit_sw(arm_to_mips_reg[store_reg], reg_a1, offset);                   \
-}                                                                             \
-
-#define arm_block_memory_sp_adjust_pc_store()                                 \
-
-#define arm_block_memory_sp_adjust_pc_load()                                  \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define old_arm_block_memory(access_type, pre_op, post_op, wb, s_bit)         \
-{                                                                             \
-  arm_decode_block_trans();                                                   \
-  u32 i;                                                                      \
-  u32 offset = 0;                                                             \
-  u32 base_reg = arm_to_mips_reg[rn];                                         \
-                                                                              \
-  arm_block_address_preadjust_##pre_op(wb);                                   \
-  arm_block_address_postadjust_##post_op();                                   \
-                                                                              \
-  sprint_##s_bit(access_type, pre_op, post_op, wb);                           \
-                                                                              \
-  if((rn == REG_SP) && iwram_stack_optimize)                                  \
-  {                                                                           \
-    mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
-    generate_load_imm(reg_a0, ((u32)(iwram + 0x8000)));                       \
-    mips_emit_addu(reg_a1, reg_a1, reg_a0);                                   \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        arm_block_memory_sp_##access_type();                                  \
-        offset += 4;                                                          \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_sp_adjust_pc_##access_type();                            \
-  }                                                                           \
-  else                                                                        \
-  {                                                                           \
-    mips_emit_ins(reg_a2, reg_zero, 0, 2);                                    \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        mips_emit_addiu(reg_a0, reg_a2, offset);                              \
-        if(reg_list & ~((2 << i) - 1))                                        \
-        {                                                                     \
-          arm_block_memory_##access_type();                                   \
-          offset += 4;                                                        \
-        }                                                                     \
-        else                                                                  \
-        {                                                                     \
-          arm_block_memory_final_##access_type();                             \
-          break;                                                              \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_adjust_pc_##access_type();                               \
-  }                                                                           \
-}
-
-
 
 // This isn't really a correct implementation, may have to fix later.
 
@@ -2047,6 +2025,13 @@
   thumb_generate_op_##rn_type(name, _rd, _rs, _rn);                           \
 }                                                                             \
 
+#define thumb_data_proc_muls(type, rn_type, _rd, _rs, _rn)                    \
+{                                                                             \
+  thumb_decode_##type();                                                      \
+  cycle_count += cycle_multiply(_rs); /* 1S+mI */                             \
+  thumb_generate_op_##rn_type(muls, _rd, _rs, _rn);                           \
+}                                                                             \
+
 #define thumb_data_proc_test(type, name, rn_type, _rs, _rn)                   \
 {                                                                             \
   thumb_decode_##type();                                                      \
@@ -2068,6 +2053,8 @@
 #define thumb_data_proc_hi(name)                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   u32 dest_rd = rd;                                                           \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   check_load_reg_pc(arm_reg_a1, rd, 4);                                       \
@@ -2102,6 +2089,8 @@
 #define thumb_data_proc_mov_hi()                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   mips_emit_addu(arm_to_mips_reg[rd], arm_to_mips_reg[rs], reg_zero);         \
   check_store_reg_pc_thumb(rd);                                               \
@@ -2157,8 +2146,15 @@
   mips_emit_addu(arm_to_mips_reg[original_rd], reg_a0, reg_zero);             \
 }                                                                             \
 
+#define cycle_thumb_shift_shift()                                             \
+
+/* ALU operations LSL,LSR,ASR,ROR  1S+1I */
+#define cycle_thumb_shift_alu_op()                                            \
+  cycle_count++                                                               \
+
 #define thumb_shift(decode_type, op_type, value_type)                         \
 {                                                                             \
+  cycle_thumb_shift_##decode_type();                                          \
   thumb_decode_##decode_type();                                               \
   thumb_generate_shift_##value_type(op_type);                                 \
   generate_op_logic_flags(arm_to_mips_reg[rd]);                               \
@@ -2166,14 +2162,45 @@
 
 // Operation types: imm, mem_reg, mem_imm
 
+/* LDR 1S+1N+1I, STR 2N */
+#define cycle_thumb_access_memory_load_u32()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_u16()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_s16()                                  \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_u8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_s8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_store_u32()                                 \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_u16()                                 \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_s16()                                 \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_u8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_s8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
 #define thumb_access_memory_load(mem_type, reg_rd)                            \
-  cycle_count += 2;                                                           \
+  cycle_thumb_access_memory_load_##mem_type();                                \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 4));                                         \
   generate_store_reg(reg_rv, reg_rd)                                          \
 
 #define thumb_access_memory_store(mem_type, reg_rd)                           \
-  cycle_count++;                                                              \
+  cycle_thumb_access_memory_store_##mem_type();                               \
   generate_load_pc(reg_a2, (pc + 2));                                         \
   mips_emit_jal(mips_absolute_offset(execute_store_##mem_type));              \
   generate_load_reg(reg_a1, reg_rd)                                           \
@@ -2236,10 +2263,20 @@
 #define thumb_block_address_postadjust_push_lr(base_reg)                      \
 
 #define thumb_block_memory_load()                                             \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define thumb_block_memory_store()                                            \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   mips_emit_jal(mips_absolute_offset(execute_aligned_store32));               \
   generate_load_reg(reg_a1, i)                                                \
 
@@ -2300,8 +2337,17 @@
   generate_indirect_branch_cycle_update(thumb)                                \
 
 #define thumb_block_memory_sp_extra_push_lr()                                 \
+  cycle_count--;                                                              \
   mips_emit_sw(reg_r14, reg_a1, (bit_count[reg_list] * 4))                    \
 
+#define cycle_thumb_block_memory_load()                                       \
+  cycle_count++;                                                              \
+  if(reg_list & 0x8000)                                                       \
+    cycle_count += 2                                                          \
+
+#define cycle_thumb_block_memory_store()                                      \
+  cycle_count++                                                               \
+
 #define thumb_block_memory(access_type, pre_op, post_op, base_reg)            \
 {                                                                             \
   thumb_decode_rlist();                                                       \
@@ -2311,6 +2357,8 @@
   thumb_block_address_preadjust_##pre_op(base_reg);                           \
   thumb_block_address_postadjust_##post_op(base_reg);                         \
                                                                               \
+  cycle_thumb_block_memory_##access_type();                                   \
+                                                                              \
   if((base_reg == REG_SP) && iwram_stack_optimize)                            \
   {                                                                           \
     mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
@@ -2337,7 +2385,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -2354,10 +2401,11 @@
                                                                               \
     thumb_block_memory_extra_##post_op();                                     \
   }                                                                           \
-}
+}                                                                             \
 
 #define thumb_conditional_branch(condition)                                   \
 {                                                                             \
+  cycle_count +=2;                                                            \
   condition_check_type condition_check;                                       \
   generate_condition_##condition();                                           \
   generate_branch_no_cycle_update(                                            \
@@ -2368,35 +2416,42 @@
 }                                                                             \
 
 #define arm_conditional_block_header()                                        \
-  generate_condition();                                                       \
+  generate_condition()                                                        \
 
 #define arm_b()                                                               \
+  cycle_count += 2;                                                           \
   generate_branch()                                                           \
 
 #define arm_bl()                                                              \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, (pc + 4));                                        \
   generate_branch()                                                           \
 
 #define arm_bx()                                                              \
+  cycle_count += 2;                                                           \
   arm_decode_branchx();                                                       \
   generate_load_reg(reg_a0, rn);                                              \
   /*generate_load_pc(reg_a2, pc);*/                                           \
   generate_indirect_branch_dual()                                             \
 
 #define arm_swi()                                                             \
-  if (((opcode >> 16) &0xFF) >= 0x2B) break;                                  \
+  if(((opcode >> 16) & 0xFF) > 0x2A)                                          \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler((opcode >> 16) & 0xFF);                            \
   generate_load_pc(reg_a0, (pc + 4));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
-  generate_branch();                                                          \
+  generate_branch()                                                           \
 
 #define thumb_b()                                                             \
+  cycle_count += 2;                                                           \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
   block_exit_position++                                                       \
 
 #define thumb_bl()                                                            \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
@@ -2408,12 +2463,13 @@
   thumb_decode_branch();                                                      \
   generate_alu_imm(addiu, addu, reg_a0, reg_r14, (offset * 2));               \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
-  generate_indirect_branch_cycle_update(dual);                                \
+  generate_indirect_branch_cycle_update(thumb);                               \
   break;                                                                      \
 }                                                                             \
 
 #define thumb_bx()                                                            \
 {                                                                             \
+  cycle_count += 2;                                                           \
   thumb_decode_hireg_op();                                                    \
   generate_load_reg_pc(reg_a0, rs, 4);                                        \
   /*generate_load_pc(reg_a2, pc);*/                                           \
@@ -2421,14 +2477,16 @@
 }                                                                             \
 
 #define thumb_swi()                                                           \
-  if ((opcode & 0xFF) >= 0x2B) break;                                         \
+  if((opcode & 0xFF) > 0x2A)                                                  \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler(opcode & 0xFF);                                    \
   generate_load_pc(reg_a0, (pc + 2));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
-  block_exit_position++;                                                      \
+  block_exit_position++                                                       \
 
 u8 swi_hle_handle[256][2] =
 { /* use bios , emu bios */
diff -ru 30_orig/mips_stub.S 30_new/mips_stub.S
--- 30_orig/mips_stub.S	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/mips_stub.S	2007-08-06 23:46:18.000000000 +0900
@@ -132,10 +132,10 @@
 .endm
 
 .macro collapse_flags
-  lw $2, REG_CPSR($16)            # $2 = [$16 + REG_CPSR]		# load CPSR
-  andi $2, $2, 0xFF               # $2 = $2 and 0xFF			# isolate lower 8bits
-  collapse_flag 20, 31            # # store flags
-  collapse_flag 21, 30            #
+  lw $2, REG_CPSR($16)            # load CPSR
+  andi $2, $2, 0xFF               # isolate lower 8bits
+  collapse_flag 20, 31            # store flags
+  collapse_flag 21, 30
   collapse_flag 22, 29
   collapse_flag 23, 28
   sw $2, REG_CPSR($16)            # store CPSR
@@ -268,29 +268,24 @@
 .macro patch_handler ftable, force_open
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
   addiu $1, $0, (\force_open * 4)
 
 1:
   lui $2, %hi(\ftable)
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
-  srl $2, $2, 2                   # remove lower two bits
 
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -303,32 +298,25 @@
 .macro patch_handler_align ftable, alignment
   srl $1, $4, 24                  # $1 = address region
   sltu $2, $1, 0x0F               # check if the value is open
-  bne $2, $0, 1f
-  sll $1, $1, 2                   # make address word indexed (delay)
-
-  addiu $1, $0, 4                 # force address to 0x1 (open)
+  sll $1, $1, 2                   # make address word indexed
+  beql $2, $0, 1f
+  addiu $1, $0, 4                 # force address to 0x1 (open) delay
 
 1:
   ins $1, $4, 6, \alignment       # place alignment bits into offset
   lui $2, %hi(\ftable)
-
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
 
-  srl $2, $2, 2                   # remove lower two bits
-
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -449,53 +437,51 @@
 
 
 .macro translate_region_vram_core
-  addiu $2, $2, -3                # see if it's 3
   ext $4, $4, 0, 17               # generate 17bit offset
-  bne $2, $0, 1f                  # if $2 != $0 then j 1:
-  lui $1, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $2, $0, 1f                 # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 1:
+  lui $1, %hi(vram)               # start loading vram address
   addu $2, $1, $4                 # $2 = (hi)vram + address
 .endm
 
 .macro translate_region_vram patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align16 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align32 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align16 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align32 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
@@ -506,7 +492,7 @@
   srl $2, $4, 15                  # $2 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $2 = memory_map_read[address >> 15]
-  lw $2, -32768($2)               # 
+  lw $2, -32768($2)
   bne $2, $0, 1f                  # if it's non-NULL continue
   andi $1, $4, \mask              # $1 = low 15bits of address (delay slot)
 
@@ -517,8 +503,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -565,8 +551,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -579,20 +565,18 @@
 
 .macro eeprom_load_a patch_handler
   region_check 0xD, \patch_handler
-
   sw $ra, REG_SAVE($16)           # save the return address (delay)
-  sw $6, REG_SAVE2($16)           # save a2
 
   save_registers                  # save the registers
 
   jal read_eeprom                 # get eeprom value in $2
-  nop
+  sw $6, REG_SAVE2($16)           # save a2 (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -634,7 +618,7 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
@@ -650,13 +634,13 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -690,13 +674,13 @@
 .macro open_load8_core
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x03               # isolate lower 3bits from address (delay)
+  andi $4, $4, 0x03               # in ARM mode, isolate lower 2bits from address
 
-  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  andi $4, $4, 0x01               # in Thumb mode, isolate one more bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory8                # get instruction at PC
@@ -718,13 +702,13 @@
 .macro open_load16_core
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
-  beq $2, $0, 1f                  # branch if ARM mode
-  andi $4, $4, 0x02               # isolate bit 1 from address (delay)
+  andi $4, $4, 0x02               # in ARM mode, isolate bit 1 from address
 
-  addu $4, $0, $0                 # zero out address bit
+  bnel $2, $0, 1f                 # branch if Thumb mode
+  addu $4, $0, $0                 # in Thumb mode, zero out address bit (delay)
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory16               # get instruction at PC
@@ -757,14 +741,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:                                # join point
   restore_registers               # restore the other registers
@@ -775,7 +759,6 @@
 
 .macro open_load32_a patch_handler
   region_check_open \patch_handler
-
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
 
@@ -786,14 +769,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:
   restore_registers               # restore the other registers
@@ -820,7 +803,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -837,7 +820,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -961,9 +944,9 @@
 
 execute_load_bios_u8:
   region_check 0, patch_load_u8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -994,9 +977,18 @@
   load_u8 (iwram + 0x8000)
 
 execute_load_io_u8:
-  translate_region 4, patch_load_u8, io_registers, 0xFFF
+  region_check 4, patch_load_u8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u8 io_registers
 
+1:
+  open_load8_core
+  nop
+
 execute_load_palette_u8:
   translate_region 5, patch_load_u8, palette_ram, 0x3FF
   load_u8 palette_ram
@@ -1067,9 +1059,9 @@
 
 execute_load_bios_s8:
   region_check 0, patch_load_s8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1097,9 +1089,18 @@
   load_s8 (iwram + 0x8000)
 
 execute_load_io_s8:
-  translate_region 4, patch_load_s8, io_registers, 0xFFF
+  region_check 4, patch_load_s8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s8 io_registers
 
+1:
+  open_load8_core
+  seb $2, $2
+
 execute_load_palette_s8:
   translate_region 5, patch_load_s8, palette_ram, 0x3FF
   load_s8 palette_ram
@@ -1170,9 +1171,9 @@
 
 execute_load_bios_u16:
   region_check_align 0, 1, 0, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1199,9 +1200,18 @@
   load_u16 (iwram + 0x8000)
 
 execute_load_io_u16:
-  translate_region_align 4, 1, 0, patch_load_u16, io_registers, 0xFFF
+  region_check 4, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16 io_registers
 
+1:
+  open_load16_core
+  nop
+
 execute_load_palette_u16:
   translate_region_align 5, 1, 0, patch_load_u16, palette_ram, 0x3FF
   load_u16 palette_ram
@@ -1250,9 +1260,9 @@
 
 execute_load_bios_u16u:
   region_check_align 0, 1, 1, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1280,9 +1290,18 @@
   load_u16_unaligned (iwram + 0x8000)
 
 execute_load_io_u16u:
-  translate_region_align 4, 1, 1, patch_load_u16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16_unaligned io_registers
 
+1:
+  open_load16_core
+  ror $2, $2, 8
+
 execute_load_palette_u16u:
   translate_region_align 5, 1, 1, patch_load_u16, palette_ram, 0x3FE
   load_u16_unaligned palette_ram
@@ -1341,6 +1360,7 @@
   .long execute_load_gamepakA_u16 # 0x0A gamepak
   .long execute_load_gamepakB_u16 # 0x0B gamepak
   .long execute_load_gamepakC_u16 # 0x0C gamepak
+
   .long execute_load_eeprom_u16   # 0x0D gamepak/eeprom
   .long execute_load_backup_u16   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u16     # 0x0F open
@@ -1405,9 +1425,9 @@
 
 execute_load_bios_s16:
   region_check_align 0, 1, 0, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1435,9 +1455,18 @@
   load_s16 (iwram + 0x8000)
 
 execute_load_io_s16:
-  translate_region_align 4, 1, 0, patch_load_s16, io_registers, 0xFFF
+  region_check_align 4, 1, 0, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16 io_registers
 
+1:
+  open_load16_core
+  seh $2, $2
+
 execute_load_palette_s16:
   translate_region_align 5, 1, 0, patch_load_s16, palette_ram, 0x3FF
   load_s16 palette_ram
@@ -1486,9 +1515,9 @@
 
 execute_load_bios_s16u:
   region_check_align 0, 1, 1, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1515,9 +1544,18 @@
   load_s16_unaligned (iwram + 0x8000)
 
 execute_load_io_s16u:
-  translate_region_align 4, 1, 1, patch_load_s16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16_unaligned io_registers
 
+1:
+  open_load16_core
+  seb $2, $2
+
 execute_load_palette_s16u:
   translate_region_align 5, 1, 1, patch_load_s16, palette_ram, 0x3FE
   load_s16_unaligned palette_ram
@@ -1605,9 +1643,9 @@
 
 execute_load_bios_u32:
   region_check_align 0, 2, 0, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1634,9 +1672,18 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32:
-  translate_region_align 4, 2, 0, patch_load_u32, io_registers, 0xFFF
+  region_check_align 4, 2, 0, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_core
+  nop
+
 execute_load_palette_u32:
   translate_region_align 5, 2, 0, patch_load_u32, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -1685,9 +1732,9 @@
 
 execute_load_bios_u32u1:
   region_check_align 0, 2, 1, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1712,9 +1759,18 @@
   load_u32_unaligned (iwram + 0x8000), 1
 
 execute_load_io_u32u1:
-  translate_region_align 4, 2, 1, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 1, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 1
 
+1:
+  open_load32_core
+  ror $2, $2, 8
+
 execute_load_palette_u32u1:
   translate_region_align 5, 2, 1, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 1
@@ -1763,9 +1819,9 @@
 
 execute_load_bios_u32u2:
   region_check_align 0, 2, 2, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1790,9 +1846,18 @@
   load_u32_unaligned (iwram + 0x8000), 2
 
 execute_load_io_u32u2:
-  translate_region_align 4, 2, 2, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 2, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 2
 
+1:
+  open_load32_core
+  ror $2, $2, 16
+
 execute_load_palette_u32u2:
   translate_region_align 5, 2, 2, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 2
@@ -1840,9 +1905,9 @@
 
 execute_load_bios_u32u3:
   region_check_align 0, 2, 3, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1867,9 +1932,18 @@
   load_u32_unaligned (iwram + 0x8000), 3
 
 execute_load_io_u32u3:
-  translate_region_align 4, 2, 3, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 3, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 3
 
+1:
+  open_load32_core
+  ror $2, $2, 24
+
 execute_load_palette_u32u3:
   translate_region_align 5, 2, 3, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 3
@@ -1928,6 +2002,7 @@
   .long execute_load_gamepakA_u32 # 0x0A gamepak
   .long execute_load_gamepakB_u32 # 0x0B gamepak
   .long execute_load_gamepakC_u32 # 0x0C gamepak
+
   .long execute_load_eeprom_u32   # 0x0D gamepak/eeprom
   .long execute_load_backup_u32   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u32     # 0x0F open
@@ -1992,9 +2067,9 @@
 
 execute_load_bios_u32a:
   region_check 0, patch_load_u32a
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -2008,7 +2083,6 @@
 
 2:
   open_load32_a
-  nop
 
 execute_load_ewram_u32a:
   translate_region_ewram patch_load_u32a
@@ -2020,9 +2094,17 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32a:
-  translate_region 4, patch_load_u32a, io_registers, 0xFFF
+  region_check 4, patch_load_u32a
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_a
+
 execute_load_palette_u32a:
   translate_region 5, patch_load_u32a, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -2060,7 +2142,6 @@
 
 execute_load_backup_u32a:
   backup_load_a patch_load_u32a
-  nop
 
 execute_load_open_u32a:
   open_load32_a patch_load_u32a
@@ -2106,14 +2187,16 @@
 
 execute_store_io_u8:
   region_check 4, patch_store_u8
-  andi $5, $5, 0xFF               # make value 8bit
+  andi $5, $5, 0xFF               # make value 8bit (delay)
   andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register8          # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2124,6 +2207,7 @@
   andi $4, $4, 0x3FE              # align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2137,10 +2221,7 @@
   store_u8_double vram
 
 execute_store_oam_u8:
-  translate_region 7, patch_store_u8, oam_ram, 0x3FE
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  store_u8_double oam_ram
+  ignore_region 7, patch_store_u8 # Write 8bit data is ignore
 
 execute_store_ignore8_u8:
   ignore_region 8, patch_store_u8
@@ -2207,14 +2288,16 @@
 
 execute_store_io_u16:
   region_check 4, patch_store_u16
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $5, $5, 0xFFFF             # make value 16bit (delay)
   andi $4, $4, 0x3FE              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register16         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2224,6 +2307,7 @@
   andi $4, $4, 0x3FE              # wrap/align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2312,12 +2396,14 @@
   region_check 4, patch_store_u32
   nop
   andi $4, $4, 0x3FC              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register32         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2421,21 +2507,18 @@
 
 execute_store_io_u32a:
   region_check 4, patch_store_u32a
-  nop
+  sw $ra, REG_SAVE2($16)          # save ra (delay)
   sw $6, REG_SAVE($16)            # save a2
-  sw $ra, REG_SAVE2($16)          # save ra
-
-  andi $4, $4, 0x3FC              # wrap around/align address
 
   save_registers
   jal write_io_register32         # write the value out
-  nop
+  andi $4, $4, 0x3FC              # wrap around/align address (delay)
 
   restore_registers
 
   lw $ra, REG_SAVE2($16)          # restore ra
   jr $ra
-  lw $6, REG_SAVE($16)            # restore a2
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 execute_store_palette_u32a:
   region_check 5, patch_store_u32a
@@ -2495,22 +2578,22 @@
   ignore_high patch_store_u32a
 
 store_u32a_ftable:
-  .long execute_store_ignore0_u32a# 0x00 BIOS
-  .long execute_store_ignore1_u32a# 0x01 open address
-  .long execute_store_ewram_u32a  # 0x02 EWRAM
-  .long execute_store_iwram_u32a  # 0x03 IWRAM
-  .long execute_store_io_u32a     # 0x04 I/O registers
-  .long execute_store_palette_u32a# 0x05 Palette RAM
-  .long execute_store_vram_u32a   # 0x06 VRAM
-  .long execute_store_oam_u32a    # 0x07 OAM RAM
-  .long execute_store_ignore8_u32a# 0x08 gamepak
-  .long execute_store_ignore9_u32a# 0x09 gamepak
-  .long execute_store_ignoreA_u32a# 0x0A gamepak
-  .long execute_store_ignoreB_u32a# 0x0B gamepak
-  .long execute_store_ignoreC_u32a# 0x0C gamepak
-  .long execute_store_eeprom_u32a # 0x0D gamepak/eeprom
-  .long execute_store_ignoreE_u32a# 0x0E Flash ROM/SRAM
-  .long execute_store_ignoreF_u32a# 0x0F open address
+  .long execute_store_ignore0_u32a # 0x00 BIOS
+  .long execute_store_ignore1_u32a # 0x01 open address
+  .long execute_store_ewram_u32a   # 0x02 EWRAM
+  .long execute_store_iwram_u32a   # 0x03 IWRAM
+  .long execute_store_io_u32a      # 0x04 I/O registers
+  .long execute_store_palette_u32a # 0x05 Palette RAM
+  .long execute_store_vram_u32a    # 0x06 VRAM
+  .long execute_store_oam_u32a     # 0x07 OAM RAM
+  .long execute_store_ignore8_u32a # 0x08 gamepak
+  .long execute_store_ignore9_u32a # 0x09 gamepak
+  .long execute_store_ignoreA_u32a # 0x0A gamepak
+  .long execute_store_ignoreB_u32a # 0x0B gamepak
+  .long execute_store_ignoreC_u32a # 0x0C gamepak
+  .long execute_store_eeprom_u32a  # 0x0D gamepak/eeprom
+  .long execute_store_ignoreE_u32a # 0x0E Flash ROM/SRAM
+  .long execute_store_ignoreF_u32a # 0x0F open address
 
 patch_store_u32a:
   patch_handler store_u32a_ftable, 0x0F
@@ -2521,7 +2604,7 @@
 execute_load_full_u8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_u8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2534,9 +2617,11 @@
 ext_load_u8:
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)                   # store return address
+
   save_registers
   jal read_memory8                # read the value
   nop
+
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # return
@@ -2546,7 +2631,7 @@
 execute_load_full_s8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_s8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2573,7 +2658,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_u16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2581,7 +2666,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lhu $2, ($1)                    # read the value
+  lhu $2, ($1)                    # read the value (delay)
 
 ext_load_u16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2599,7 +2684,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_s16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2607,7 +2692,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lh $2, ($1)                     # read the value
+  lh $2, ($1)                     # read the value (delay)
 
 ext_load_s16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2626,7 +2711,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 2                # or unaligned (bottom two bits)
   bne $1, $0, ext_load_u32        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2634,7 +2719,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_load_u32:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2650,7 +2735,7 @@
 #execute_aligned_load32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_load32  # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($1)
@@ -2658,7 +2743,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_aligned_load32:
   addiu $sp, $sp, -8              # make room on the stack for $ra
@@ -2689,12 +2774,8 @@
   nop
   collapse_flags                  # make sure flags are good for update_gba
 
-alert_loop:
   jal update_gba                  # process the next event
   nop
-  lw $1, CPU_HALT_STATE($16)      # check if CPU is sleeping
-  bne $1, $0, alert_loop          # see if it hasn't changed
-  nop
 
   addu $17, $2, $0                # $17 = new cycle counter
   lw $4, REG_PC($16)              # $4 = new PC
@@ -2705,20 +2786,19 @@
 irq_alert:
   restore_registers
   j lookup_pc                     # PC has changed, get a new one
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 no_alert:
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 smc_dma:
-  addiu $sp, $sp, 4               # fix the stack
   jal flush_translation_cache_ram # flush translation cache
   nop
   j lookup_pc
-  nop
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 ext_store_eeprom:
@@ -2730,14 +2810,14 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 # 8bit ext memory routines
 
 ext_store_io8:
   andi $5, $5, 0xFF               # make value 8bit
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2747,34 +2827,27 @@
   nop
 
 ext_store_palette8:
+  ins $5, $5, 8, 8                # value = (value << 8) | value
   j ext_store_palette16b          # perform 16bit palette write
   andi $4, $4, 0x3FE              # wrap + align (delay)
 
 ext_store_vram8:
   ins $5, $5, 8, 8                # value = (value << 8) | value
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
   ins $4, $0, 0, 1                # align out bottom bit
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # if $4 >= $1 then $1 = 0 else $1 = 1
-  bne $1, $0, ext_store_vram8b    # if $1 != 0 then j ext_store_vram8b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram8b   # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram8b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
 
 ext_store_oam8:
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  andi $4, $4, 0x3FE              # wrap around address and align to 16bits
-  ins $5, $5, 8, 8                # value = (value << 8) | value
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
-  jr $ra                          # return
-  sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  jr $ra                          # Write 8bit data is ignore
+  nop
 
 ext_store_backup:
   andi $5, $5, 0xFF               # make value 8bit
@@ -2787,25 +2860,25 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u8_jtable:
-  .long ext_store_ignore  # 0x00 BIOS
-  .long ext_store_ignore  # 0x01 invalid
+  .long ext_store_ignore    # 0x00 BIOS
+  .long ext_store_ignore    # 0x01 invalid
   .long ext_store_ignore    # 0x02 EWRAM
   .long ext_store_ignore    # 0x03 IWRAM
   .long ext_store_io8       # 0x04 I/O registers
   .long ext_store_palette8  # 0x05 Palette RAM
   .long ext_store_vram8     # 0x06 VRAM
   .long ext_store_oam8      # 0x07 OAM RAM
-  .long ext_store_ignore  # 0x08 gamepak (no RTC accepted in 8bit)
-  .long ext_store_ignore  # 0x09 gamepak, ignore
-  .long ext_store_ignore  # 0x0A gamepak, ignore
-  .long ext_store_ignore  # 0x0B gamepak, ignore
-  .long ext_store_ignore  # 0x0C gamepak, ignore
-  .long ext_store_eeprom   # 0x0D EEPROM (possibly)
-  .long ext_store_backup   # 0x0E Flash ROM/SRAM
-  .long ext_store_ignore  # 0x0F invalid
+  .long ext_store_ignore    # 0x08 gamepak (no RTC accepted in 8bit)
+  .long ext_store_ignore    # 0x09 gamepak, ignore
+  .long ext_store_ignore    # 0x0A gamepak, ignore
+  .long ext_store_ignore    # 0x0B gamepak, ignore
+  .long ext_store_ignore    # 0x0C gamepak, ignore
+  .long ext_store_eeprom    # 0x0D EEPROM (possibly)
+  .long ext_store_backup    # 0x0E Flash ROM/SRAM
+  .long ext_store_ignore    # 0x0F invalid
 
 
 
@@ -2844,7 +2917,7 @@
 # 16bit ext memory routines
 
 ext_store_io16:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   andi $5, $5, 0xFFFF             # make value 16bit
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
@@ -2861,6 +2934,7 @@
   lui $2, %hi(palette_ram)
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2870,15 +2944,13 @@
   sh $1, %lo(palette_ram_converted)($2)
 
 ext_store_vram16:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram16b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram16b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram16b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2886,6 +2958,7 @@
 ext_store_oam16:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -2893,7 +2966,7 @@
   sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
 
 ext_store_rtc:
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $4, $4, 0xFF               # wrap address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2902,7 +2975,7 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u16_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -2952,15 +3025,10 @@
 
 
 
-
-
-
-
-
 # 32bit ext memory routines
 
 ext_store_io32:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2979,15 +3047,13 @@
   addu $ra, $6, $0                # restore return address (delay)
 
 ext_store_vram32:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram32b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram32b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram32b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sw $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2995,6 +3061,7 @@
 ext_store_oam32:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -3031,6 +3098,7 @@
   nop
 
 #execute_store_u32:
+execute_store_full_u32:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_store_u32       # if it is, perform an extended write
   srl $2, $4, 15                  # $1 = page number of address (delay slot)
@@ -3050,20 +3118,22 @@
 # 32bit ext aligned, non a2 destroying routines
 
 ext_store_io32a:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register32         # write the value out
-  sw $6, REG_SAVE($16)            # save a2
-  lw $6, REG_SAVE($16)            # restore a2
+  sw $6, REG_SAVE($16)            # save a2 (delay)
+
   j write_io_epilogue             # handle any state changes
-  nop
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 ext_store_palette32a:
   sw $ra, REG_SAVE($16)           # save return address
   jal ext_store_palette16b        # write out palette entry
   andi $4, 0x3FF                  # wrap address (delay)
+
   addiu $4, $4, 2                 # go to next location
   srl $5, $5, 16                  # shift to next 16bit value
   j ext_store_palette16b          # write out next palette entry
@@ -3101,7 +3171,7 @@
 #execute_aligned_store32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_store32 # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_write[address >> 15]
   lw $1, 256($1)
@@ -3149,31 +3219,36 @@
   lw $1, CPU_MODE($16)            # $1 = cpu_mode
   lui $2, %hi(spsr)
   sll $1, $1, 2                   # adjust to word offset size
-  addu $2, $2, $1
+  addu $1, $2, $1
   jr $ra                          # return
-  lw $2, %lo(spsr)($2)            # $2 = spsr[cpu_mode] (delay slot)
+  lw $2, %lo(spsr)($1)            # $2 = spsr[cpu_mode] (delay slot)
 
 # Switch into SWI, has to collapse flags
 # $4: Current pc
 
 execute_swi:
-  add $sp, $sp, -4                # push $ra
-  sw $ra, ($sp)
   lui $1, %hi(SUPERVISOR_LR)
   sw $4, %lo(SUPERVISOR_LR)($1)   # store next PC in the supervisor's LR
   collapse_flags                  # get cpsr in $2
   lui $5, %hi(SUPERVISOR_SPSR)
   sw $2, %lo(SUPERVISOR_SPSR)($5) # save cpsr in SUPERVISOR_CPSR
+
+  addiu $sp, $sp, -4              # push $ra
+  sw $ra, ($sp)
+
   ins $2, $0, 0, 6                # zero out bottom 6 bits of CPSR
   ori $2, 0x13                    # set mode to supervisor
   sw $2, REG_CPSR($16)            # write back CPSR
+
   save_registers
+  jal bios_region_read_allow
+  nop
   jal set_cpu_mode                # set the CPU mode to supervisor
   li $4, 3                        # 3 is supervisor mode (delay slot)
   restore_registers
   lw $ra, ($sp)                   # pop $ra
   jr $ra                          # return
-  add $sp, $sp, 4                 # fix stack (delay slot)
+  addiu $sp, $sp, 4               # fix stack (delay slot)
 
 # $4: pc to restore to
 # returns in $4
@@ -3183,14 +3258,15 @@
 
   beq $1, $0, no_spsr_restore     # only restore if the cpu isn't usermode
   lui $2, %hi(spsr)               # start loading SPSR (delay)
-
   sll $1, $1, 2                   # adjust to word offset size
   addu $2, $2, $1
   lw $1, %lo(spsr)($2)            # $1 = spsr[cpu_mode]
-  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
-  extract_flags_body              # extract flags from $1
+
   addiu $sp, $sp, -4
   sw $ra, ($sp)
+
+  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
+  extract_flags_body              # extract flags from $1
   save_registers
   jal execute_spsr_restore_body   # do the dirty work in this C function
   nop
@@ -3272,15 +3348,15 @@
   sllv $4, $4, $5                 # return (value << shift) (delay)
 
 lsl_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsl_shift_done      # jump if shift == 32
-  andi $22, $4, 1                 # c flag = value & 0x01 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  andi $22, $4, 1                 # c flag = value & 0x01
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsl_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsl_shift_done:
   jr $ra                          # return
-  add $4, $0, $0                  # value = 0 no matter what
+  add $4, $0, $0                  # value = 0 no matter what (delay)
 
 
 execute_lsr_flags_reg:
@@ -3297,11 +3373,11 @@
   srlv $4, $4, $5                 # return (value >> shift) (delay)
 
 lsr_shift_high:
-  sltiu $1, $5, 33                # $1 = (shift < 33) (delay)
-  bne $1, $0, lsr_shift_done      # jump if shift == 32
-  srl $22, $4, 31                 # c flag = value >> 31 (delay)
+  sltiu $1, $5, 33                # $1 = (shift < 33)
+  srl $22, $4, 31                 # c flag = value >> 31
 
-  add $22, $0, $0                 # c flag = 0 otherwise
+  beql $1, $0, lsr_shift_done     # jump if shift == 32
+  add $22, $0, $0                 # c flag = 0 otherwise (delay)
 
 lsr_shift_done:
   jr $ra                          # return
@@ -3341,28 +3417,17 @@
 # $4: cycle counter argument
 
 execute_arm_translate:
-  addu $17, $4, $0                # load cycle counter register
   lui $16, %hi(reg)               # load base register
   addiu $16, %lo(reg)
-  extract_flags                   # load flag variables
-
-  and $1, $1, 0x20                # see if Thumb bit is set in flags
+  addu $17, $4, $0                # load cycle counter register
 
-  bne $1, $0, 1f
+  jal block_lookup_address_arm    # lookup initial jump address
   lw $4, REG_PC($16)              # load PC into $4 (delay)
 
-  jal block_lookup_address_arm    # lookup initial jump address
-  nop
   restore_registers               # load initial register values
   jr $2                           # jump to return
   nop
 
-1:
-  jal block_lookup_address_thumb  # lookup initial jump address
-  nop
-  restore_registers               # load initial register values
-  jr $2                           # jump to return
-  nop
 
 # sceKernelInvalidateIcacheRange gives me problems, trying this instead
 # Invalidates an n byte region starting at the start address
@@ -3377,9 +3442,7 @@
   nop
 
 iir_loop:
-##  cache 8, ($4)                   # invalidate icache line
-##  cache 8, ($4)                   # do it again for good luck :P
-  cache 0x08, ($4)                # hit invalidate icache line
+  cache 0x08, ($4)                # invalidate icache line
   addiu $2, $2, -1                # next loop iteration
   bne $2, $0, iir_loop            # loop
   addiu $4, $4, 64                # go to next cache line (delay slot)
@@ -3413,3 +3476,4 @@
 
 memory_map_write:
   .space 0x8000
+
Only in 30_new/psp: EBOOT.PBP
diff -ru 30_orig/psp/Makefile 30_new/psp/Makefile
--- 30_orig/psp/Makefile	2007-08-06 02:50:38.000000000 +0900
+++ 30_new/psp/Makefile	2007-08-06 23:10:24.000000000 +0900
@@ -23,9 +23,11 @@
 PSP_EBOOT_TITLE = UnOfficial_gpSP_kai_${VERSION_MAJOR}.${VERSION_MINOR} ${VERSION_OPT}
 
 VPATH           += ..
-CFLAGS          += -O3 -DPSP_BUILD -G0 -Wall -Wredundant-decls -Wmissing-declarations -funsigned-char -ffast-math -fforce-addr -fmerge-all-constants -floop-optimize2 -funsafe-loop-optimizations -ftree-loop-linear
+CFLAGS          += -O3 -G0 -funsigned-char
+#CFLAGS          += -ffast-math -fforce-addr -fmerge-all-constants -floop-optimize2 -funsafe-loop-optimizations -ftree-loop-linear
+#CFLAGS          +=  -Wall -fno-exceptions -Wredundant-decls -Wmissing-declarations
 #CFLAGS          += -Wredundant-decls -Wmissing-declarations
-#CFLAGS          += ${shell ${PREFIX}/bin/sdl-config --cflags}
+CFLAGS          += ${shell ${PREFIX}/bin/sdl-config --cflags}
 
 CFLAGS          += -DVERSION_MAJOR=${VERSION_MAJOR}
 CFLAGS          += -DVERSION_MINOR=${VERSION_MINOR}
@@ -34,9 +36,7 @@
 ASFLAGS         = ${CFLAGS}
 EXTRA_TARGETS   = EBOOT.PBP
 
-LIBS            += -lpspgu -lpsprtc -lpspaudio
-LIBS            += -lz -lpsppower -lpspnet -lpspwlan -lpspnet_adhoc -lpspnet_adhocctl -lpspnet_adhocmatching
-#LIBS            += ${shell ${PREFIX}/bin/sdl-config --libs}
+LIBS            += ${shell ${PREFIX}/bin/sdl-config --libs} -lz -lpsppower -lpspnet -lpspwlan -lpspnet_adhoc -lpspnet_adhocctl -lpspnet_adhocmatching
 
 include ${PSPSDK}/lib/build.mak
 
Only in 30_new/psp: PARAM.SFO
Only in 30_new/psp: UO_gpSP_kai.elf
Only in 30_new/psp: adhoc.o
Only in 30_new/psp: bios.o
Only in 30_new/psp: cheats.o
Only in 30_new/psp: cpu.o
Only in 30_new/psp: cpu_threaded.o
Only in 30_new/psp: fbm_print.o
Only in 30_new/psp: gui.o
Only in 30_new/psp: input.o
Only in 30_new/psp: main.o
Only in 30_new/psp: memory.o
Only in 30_new/psp: mips_stub.o
Only in 30_new/psp: sound.o
Only in 30_new/psp: video.o
Only in 30_new/psp: zip.o
diff -ru 30_orig/readme_kai_jp.txt 30_new/readme_kai_jp.txt
--- 30_orig/readme_kai_jp.txt	2007-08-06 02:28:34.000000000 +0900
+++ 30_new/readme_kai_jp.txt	2007-08-05 23:04:12.000000000 +0900
@@ -268,4 +268,4 @@
 		gpSP CFGファイルのサイズが56byte -> 72byteに変更。
 
 takka takka@tfact.net
-http://sourceforge.jp/projects/gpsp-kai
+http://www.tfact.jp/psp/wiki/
diff -ru 30_orig/sound.c 30_new/sound.c
--- 30_orig/sound.c	2007-08-06 08:29:46.000000000 +0900
+++ 30_new/sound.c	2007-08-06 23:47:50.000000000 +0900
@@ -18,63 +18,232 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/******************************************************************************
- * sound.c
- * サウンド周りの処理
- ******************************************************************************/
-
-/******************************************************************************
- * ヘッダファイルの読込み
- ******************************************************************************/
 #include "common.h"
 
-/******************************************************************************
- * マクロ等の定義
- ******************************************************************************/
+u32 global_enable_audio = 1;
+
+direct_sound_struct direct_sound_channel[2];
+gbc_sound_struct gbc_sound_channel[4];
+
+u32 sound_frequency = 44100;
+
+SDL_AudioSpec sound_settings;
+SDL_mutex *sound_mutex;
+SDL_cond *sound_cv;
+
+u32 audio_buffer_size_number = 1;
+u32 audio_buffer_size;
+u32 audio_buffer_size_x2;
+u32 sound_on = 0;
+s16 sound_buffer[BUFFER_SIZE];
+u32 sound_buffer_base = 0;
+
+u32 sound_last_cpu_ticks = 0;
+FIXED16_16 gbc_sound_tick_step;
+
+u32 gbc_sound_wave_update;
+
+// u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
+
+void sound_callback(void *userdata, Uint8 *stream, int length);
+void init_noise_table(u32 *table, u32 period, u32 bit_length);
 
-#define SOUND_TIMER_QUEUE(size, value)                                        \
-  *((s##size *)(ds->fifo + ds->fifo_top)) = value;                            \
-  ds->fifo_top = (ds->fifo_top + 1) % 32;                                     \
 
-#define RENDER_SAMPLE_NULL()                                                  \
+/* マジカルバケーションの不具合修正 */
+void sound_timer_queue32(u8 channel)
+{
+  direct_sound_struct *ds = direct_sound_channel + channel;
+  u8 offset = channel * 4;
+  u8 i;
+
+  for(i = 0xA0; i <= 0xA3; i++)
+  {
+    ds->fifo[ds->fifo_top] = ADDRESS8(io_registers, i + offset);
+    ds->fifo_top = (ds->fifo_top + 1) % 32;
+  }
+}
 
-#define RENDER_SAMPLE_LEFT()                                                  \
+// Unqueue 1 sample from the base of the DS FIFO and place it on the audio
+// buffer for as many samples as necessary. If the DS FIFO is 16 bytes or
+// smaller and if DMA is enabled for the sound channel initiate a DMA transfer
+// to the DS FIFO.
+
+#define render_sample_null()                                                  \
+
+#define render_sample_left()                                                  \
   sound_buffer[buffer_index] += current_sample +                              \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
 
-#define RENDER_SAMPLE_RIGHT()                                                 \
+#define render_sample_right()                                                 \
   sound_buffer[buffer_index + 1] += current_sample +                          \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
 
-#define RENDER_SAMPLE_BOTH()                                                  \
+#define render_sample_both()                                                  \
   dest_sample = current_sample +                                              \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional);          \
   sound_buffer[buffer_index] += dest_sample;                                  \
   sound_buffer[buffer_index + 1] += dest_sample                               \
 
-#define RENDER_SAMPLES(type)                                                  \
+#define render_samples(type)                                                  \
   while(fifo_fractional <= 0xFFFF)                                            \
   {                                                                           \
-    RENDER_SAMPLE_##type();                                                   \
+    render_sample_##type();                                                   \
     fifo_fractional += frequency_step;                                        \
     buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
   }                                                                           \
 
-#define UPDATE_VOLUME_CHANNEL_ENVELOPE(channel)                               \
+void sound_timer(FIXED16_16 frequency_step, u32 channel)
+{
+  direct_sound_struct *ds = direct_sound_channel + channel;
+
+  FIXED16_16 fifo_fractional = ds->fifo_fractional;
+  u32 buffer_index = ds->buffer_index;
+  s16 current_sample, next_sample, dest_sample;
+
+  current_sample = ds->fifo[ds->fifo_base] << 4;
+  ds->fifo_base = (ds->fifo_base + 1) % 32;
+  next_sample = ds->fifo[ds->fifo_base] << 4;
+
+  if(sound_on == 1)
+  {
+    if(ds->volume == DIRECT_SOUND_VOLUME_50)
+    {
+      current_sample >>= 1;
+      next_sample >>= 1;
+    }
+
+    switch(ds->status)
+    {
+      case DIRECT_SOUND_INACTIVE:
+        render_samples(null);
+        break;
+
+      case DIRECT_SOUND_RIGHT:
+        render_samples(right);
+        break;
+
+      case DIRECT_SOUND_LEFT:
+        render_samples(left);
+        break;
+
+      case DIRECT_SOUND_LEFTRIGHT:
+        render_samples(both);
+        break;
+    }
+  }
+  else
+  {
+    render_samples(null);
+  }
+
+  ds->buffer_index = buffer_index;
+  ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
+
+  /* マジカルバケーションで動作が遅くなるのが改善される */
+  u8 fifo_length;
+
+  if(ds->fifo_top > ds->fifo_base)
+    fifo_length = ds->fifo_top - ds->fifo_base;
+  else
+    fifo_length = ds->fifo_top + (32 - ds->fifo_base);
+
+  if(fifo_length <= 16)
+  {
+    if(dma[1].direct_sound_channel == channel)
+      dma_transfer(dma + 1);
+
+    if(dma[2].direct_sound_channel == channel)
+      dma_transfer(dma + 2);
+  }
+}
+
+void sound_reset_fifo(u32 channel)
+{
+  direct_sound_struct *ds = direct_sound_channel + channel;
+
+  memset(ds->fifo, 0, 32);
+}
+
+// Initial pattern data = 4bits (signed)
+// Channel volume = 12bits
+// Envelope volume = 14bits
+// Master volume = 2bits
+
+// Recalculate left and right volume as volume changes.
+// To calculate the current sample, use (sample * volume) >> 16
+
+// Square waves range from -8 (low) to 7 (high)
+
+s8 square_pattern_duty[4][8] =
+{
+  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
+  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
+  { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
+  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 }
+};
+
+s8 wave_samples[64];
+
+u32 noise_table15[1024];
+u32 noise_table7[4];
+
+u32 gbc_sound_master_volume_table[4] = { 1, 2, 4, 0 };
+
+u32 gbc_sound_channel_volume_table[8] =
+{
+  FIXED_DIV(0, 7, 12),
+  FIXED_DIV(1, 7, 12),
+  FIXED_DIV(2, 7, 12),
+  FIXED_DIV(3, 7, 12),
+  FIXED_DIV(4, 7, 12),
+  FIXED_DIV(5, 7, 12),
+  FIXED_DIV(6, 7, 12),
+  FIXED_DIV(7, 7, 12)
+};
+
+u32 gbc_sound_envelope_volume_table[16] =
+{
+  FIXED_DIV(0, 15, 14),
+  FIXED_DIV(1, 15, 14),
+  FIXED_DIV(2, 15, 14),
+  FIXED_DIV(3, 15, 14),
+  FIXED_DIV(4, 15, 14),
+  FIXED_DIV(5, 15, 14),
+  FIXED_DIV(6, 15, 14),
+  FIXED_DIV(7, 15, 14),
+  FIXED_DIV(8, 15, 14),
+  FIXED_DIV(9, 15, 14),
+  FIXED_DIV(10, 15, 14),
+  FIXED_DIV(11, 15, 14),
+  FIXED_DIV(12, 15, 14),
+  FIXED_DIV(13, 15, 14),
+  FIXED_DIV(14, 15, 14),
+  FIXED_DIV(15, 15, 14)
+};
+
+u32 gbc_sound_buffer_index = 0;
+u32 gbc_sound_last_cpu_ticks = 0;
+u32 gbc_sound_partial_ticks = 0;
+
+u32 gbc_sound_master_volume_left;
+u32 gbc_sound_master_volume_right;
+u32 gbc_sound_master_volume;
+
+#define update_volume_channel_envelope(channel)                               \
   volume_##channel = gbc_sound_envelope_volume_table[envelope_volume] *       \
    gbc_sound_channel_volume_table[gbc_sound_master_volume_##channel] *        \
    gbc_sound_master_volume_table[gbc_sound_master_volume]                     \
 
-#define UPDATE_VOLUME_CHANNEL_NOENVELOPE(channel)                             \
+#define update_volume_channel_noenvelope(channel)                             \
   volume_##channel = gs->wave_volume *                                        \
    gbc_sound_channel_volume_table[gbc_sound_master_volume_##channel] *        \
    gbc_sound_master_volume_table[gbc_sound_master_volume]                     \
 
-#define UPDATE_VOLUME(type)                                                   \
+#define update_volume(type)                                                   \
   update_volume_channel_##type(left);                                         \
   update_volume_channel_##type(right)                                         \
 
-#define UPDATE_TONE_SWEEP()                                                   \
+#define update_tone_sweep()                                                   \
   if(gs->sweep_status)                                                        \
   {                                                                           \
     u32 sweep_ticks = gs->sweep_ticks - 1;                                    \
@@ -88,14 +257,15 @@
       else                                                                    \
         rate = rate + (rate >> gs->sweep_shift);                              \
                                                                               \
-      if(rate > 2048) {                                                       \
-        rate = 0;                                                             \
-        frequency_step = 0;                                                   \
-      } else {                                                                \
-        frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)  \
-        / SOUND_FREQUENCY);                                                   \
+      if(rate > 2047)                                                         \
+      {                                                                       \
+        gs->active_flag = 0;                                                  \
+        break;                                                                \
       }                                                                       \
                                                                               \
+      frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)    \
+       / sound_frequency);                                                    \
+                                                                              \
       gs->frequency_step = frequency_step;                                    \
       gs->rate = rate;                                                        \
                                                                               \
@@ -104,9 +274,9 @@
     gs->sweep_ticks = sweep_ticks;                                            \
   }                                                                           \
 
-#define UPDATE_TONE_NOSWEEP()                                                 \
+#define update_tone_nosweep()                                                 \
 
-#define UPDATE_TONE_ENVELOPE()                                                \
+#define update_tone_envelope()                                                \
   if(gs->envelope_status)                                                     \
   {                                                                           \
     u32 envelope_ticks = gs->envelope_ticks - 1;                              \
@@ -125,7 +295,7 @@
           envelope_volume = gs->envelope_volume - 1;                          \
       }                                                                       \
                                                                               \
-      UPDATE_VOLUME(envelope);                                                \
+      update_volume(envelope);                                                \
                                                                               \
       gs->envelope_volume = envelope_volume;                                  \
       gs->envelope_ticks = gs->envelope_initial_ticks;                        \
@@ -136,12 +306,14 @@
     }                                                                         \
   }                                                                           \
 
-#define UPDATE_TONE_NOENVELOPE()                                              \
+#define update_tone_noenvelope()                                              \
 
-#define UPDATE_TONE_COUNTERS(envelope_op, sweep_op)                           \
+#define update_tone_counters(envelope_op, sweep_op)                           \
   tick_counter += gbc_sound_tick_step;                                        \
   if(tick_counter > 0xFFFF)                                                   \
   {                                                                           \
+    tick_counter &= 0xFFFF;                                                   \
+                                                                              \
     if(gs->length_status)                                                     \
     {                                                                         \
       u32 length_ticks = gs->length_ticks - 1;                                \
@@ -156,21 +328,19 @@
                                                                               \
     update_tone_##envelope_op();                                              \
     update_tone_##sweep_op();                                                 \
-                                                                              \
-    tick_counter &= 0xFFFF;                                                   \
   }                                                                           \
 
-#define GBC_SOUND_RENDER_SAMPLE_RIGHT()                                       \
+#define gbc_sound_render_sample_right()                                       \
   sound_buffer[buffer_index + 1] += (current_sample * volume_right) >> 22     \
 
-#define GBC_SOUND_RENDER_SAMPLE_LEFT()                                        \
+#define gbc_sound_render_sample_left()                                        \
   sound_buffer[buffer_index] += (current_sample * volume_left) >> 22          \
 
-#define GBC_SOUND_RENDER_SAMPLE_BOTH()                                        \
-  GBC_SOUND_RENDER_SAMPLE_RIGHT();                                            \
-  GBC_SOUND_RENDER_SAMPLE_LEFT()                                              \
+#define gbc_sound_render_sample_both()                                        \
+  gbc_sound_render_sample_right();                                            \
+  gbc_sound_render_sample_left()                                              \
 
-#define GBC_SOUND_RENDER_SAMPLES(type, sample_length, envelope_op, sweep_op)  \
+#define gbc_sound_render_samples(type, sample_length, envelope_op, sweep_op)  \
   for(i = 0; i < buffer_ticks; i++)                                           \
   {                                                                           \
     current_sample =                                                          \
@@ -180,24 +350,24 @@
     sample_index += frequency_step;                                           \
     buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
                                                                               \
-    UPDATE_TONE_COUNTERS(envelope_op, sweep_op);                              \
+    update_tone_counters(envelope_op, sweep_op);                              \
   }                                                                           \
 
-#define GBC_NOISE_WRAP_FULL 32767
+#define gbc_noise_wrap_full 32767
 
-#define GBC_NOISE_WRAP_HALF 126
+#define gbc_noise_wrap_half 126
 
-#define GET_NOISE_SAMPLE_FULL()                                               \
+#define get_noise_sample_full()                                               \
   current_sample =                                                            \
    ((s32)(noise_table15[FP16_16_TO_U32(sample_index) >> 5] <<                 \
    (FP16_16_TO_U32(sample_index) & 0x1F)) >> 31) & 0x0F                       \
 
-#define GET_NOISE_SAMPLE_HALF()                                               \
+#define get_noise_sample_half()                                               \
   current_sample =                                                            \
    ((s32)(noise_table7[FP16_16_TO_U32(sample_index) >> 5] <<                  \
    (FP16_16_TO_U32(sample_index) & 0x1F)) >> 31) & 0x0F                       \
 
-#define GBC_SOUND_RENDER_NOISE(type, noise_type, envelope_op, sweep_op)       \
+#define gbc_sound_render_noise(type, noise_type, envelope_op, sweep_op)       \
   for(i = 0; i < buffer_ticks; i++)                                           \
   {                                                                           \
     get_noise_sample_##noise_type();                                          \
@@ -209,16 +379,16 @@
       sample_index -= U32_TO_FP16_16(gbc_noise_wrap_##noise_type);            \
                                                                               \
     buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
-    UPDATE_TONE_COUNTERS(envelope_op, sweep_op);                              \
+    update_tone_counters(envelope_op, sweep_op);                              \
   }                                                                           \
 
-#define GBC_SOUND_RENDER_CHANNEL(type, sample_length, envelope_op, sweep_op)  \
+#define gbc_sound_render_channel(type, sample_length, envelope_op, sweep_op)  \
   buffer_index = gbc_sound_buffer_index;                                      \
   sample_index = gs->sample_index;                                            \
   frequency_step = gs->frequency_step;                                        \
   tick_counter = gs->tick_counter;                                            \
                                                                               \
-  UPDATE_VOLUME(envelope_op);                                                 \
+  update_volume(envelope_op);                                                 \
                                                                               \
   switch(gs->status)                                                          \
   {                                                                           \
@@ -239,9 +409,9 @@
   }                                                                           \
                                                                               \
   gs->sample_index = sample_index;                                            \
-  gs->tick_counter = tick_counter;                                            \
+  gs->tick_counter = tick_counter                                             \
 
-#define GBC_SOUND_LOAD_WAVE_RAM(bank)                                         \
+#define gbc_sound_load_wave_ram(bank)                                         \
   wave_bank = wave_samples + (bank * 32);                                     \
   for(i = 0, i2 = 0; i < 16; i++, i2 += 2)                                    \
   {                                                                           \
@@ -250,238 +420,10 @@
     wave_bank[i2 + 1] = ((current_sample & 0x0F) - 8);                        \
   }                                                                           \
 
-#define SOUND_COPY_NORMAL()                                                   \
-  current_sample = source[i]                                                  \
-
-#define SOUND_COPY(source_offset, length, render_type)                        \
-  _length = (length) / 2;                                                     \
-  source = (s16 *)(sound_buffer + source_offset);                             \
-  for(i = 0; i < _length; i++)                                                \
-  {                                                                           \
-    sound_copy_##render_type();                                               \
-    if(current_sample > 2047)                                                 \
-      current_sample = 2047;                                                  \
-    if(current_sample < -2048)                                                \
-      current_sample = -2048;                                                 \
-                                                                              \
-    stream_base[i] = current_sample << 4;                                     \
-    source[i] = 0;                                                            \
-  }                                                                           \
-
-#define SOUND_COPY_NULL(source_offset, length)                                \
-  _length = (length) >> 2;                                                    \
-  source = (s16 *)(sound_buffer + source_offset);                             \
-  {                                                                           \
-    u32 *ptr1 = (u32 *) stream_base;                                          \
-    u32 *ptr2 = (u32 *) source;                                               \
-    while (_length--) *ptr1++ = *ptr2++ = 0;                                  \
-  }                                                                           \
-
-/******************************************************************************
- * グローバル変数の定義
- ******************************************************************************/
-
-/******************************************************************************
- * ローカル変数の定義
- ******************************************************************************/
-
-/******************************************************************************
- * ローカル関数の宣言
- ******************************************************************************/
-
-
-u32 global_enable_audio = 1;
-
-direct_sound_struct direct_sound_channel[2];
-gbc_sound_struct gbc_sound_channel[4];
-
-//u32 sound_frequency = 44100;
-
-u32 audio_buffer_size_number = 1;
-u32 audio_buffer_size;
-u32 audio_buffer_size_x2;
-u32 sound_on = 0;
-s16 sound_buffer[BUFFER_SIZE];    // サウンド バッファ 2n = Left / 2n+1 = Right
-u32 sound_buffer_base = 0;
-static int sound_handle;          // サウンド スレッドのハンドル
-static SceUID sound_thread;
-
-u32 sound_last_cpu_ticks = 0;
-FIXED16_16 gbc_sound_tick_step;
-
-u32 gbc_sound_wave_update;
-
-u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
-
-void sound_callback(/*void *userdata, Uint8 *stream, int length*/);
-void init_noise_table(u32 *table, u32 period, u32 bit_length);
-
-// Queue 1, 2, or 4 samples to the top of the DS FIFO, wrap around circularly
-
-
-void sound_timer_queue8(u32 channel, u8 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  SOUND_TIMER_QUEUE(8, value);
-}
-
-void sound_timer_queue16(u32 channel, u16 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  SOUND_TIMER_QUEUE(8, value & 0xFF);
-  SOUND_TIMER_QUEUE(8, value >> 8);
-}
-
-void sound_timer_queue32(u32 channel, u32 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-
-  SOUND_TIMER_QUEUE(8, value & 0xFF);
-  SOUND_TIMER_QUEUE(8, (value >> 8) & 0xFF);
-  SOUND_TIMER_QUEUE(8, (value >> 16) & 0xFF);
-  SOUND_TIMER_QUEUE(8, value >> 24);
-}
-
-// Unqueue 1 sample from the base of the DS FIFO and place it on the audio
-// buffer for as many samples as necessary. If the DS FIFO is 16 bytes or
-// smaller and if DMA is enabled for the sound channel initiate a DMA transfer
-// to the DS FIFO.
-
-
-void sound_timer(FIXED16_16 frequency_step, u32 channel)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-
-  FIXED16_16 fifo_fractional = ds->fifo_fractional;
-  u32 buffer_index = ds->buffer_index;
-  s16 current_sample, next_sample, dest_sample;
-
-  current_sample = ds->fifo[ds->fifo_base] << 4;
-  ds->fifo_base = (ds->fifo_base + 1) % 32;
-  next_sample = ds->fifo[ds->fifo_base] << 4;
-
-  if(sound_on == 1)
-  {
-    if(ds->volume == DIRECT_SOUND_VOLUME_50)
-    {
-      current_sample >>= 1;
-      next_sample >>= 1;
-    }
-
-    switch(ds->status)
-    {
-      case DIRECT_SOUND_INACTIVE:
-        RENDER_SAMPLES(NULL);
-        break;
-
-      case DIRECT_SOUND_RIGHT:
-        RENDER_SAMPLES(RIGHT);
-        break;
-
-      case DIRECT_SOUND_LEFT:
-        RENDER_SAMPLES(LEFT);
-        break;
-
-      case DIRECT_SOUND_LEFTRIGHT:
-        RENDER_SAMPLES(BOTH);
-        break;
-    }
-  }
-  else
-  {
-    RENDER_SAMPLES(NULL);
-  }
-
-  ds->buffer_index = buffer_index;
-  ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
-
-  if(((ds->fifo_top - ds->fifo_base) % 32) <= 16)
-  {
-    if(dma[1].direct_sound_channel == channel)
-      dma_transfer(dma + 1);
-
-    if(dma[2].direct_sound_channel == channel)
-      dma_transfer(dma + 2);
-  }
-}
-
-void sound_reset_fifo(u32 channel)
-{
-  direct_sound_struct *ds = direct_sound_channel;
-
-  memset(ds->fifo, 0, 32);
-}
-
-// Initial pattern data = 4bits (signed)
-// Channel volume = 12bits
-// Envelope volume = 14bits
-// Master volume = 2bits
-
-// Recalculate left and right volume as volume changes.
-// To calculate the current sample, use (sample * volume) >> 16
-
-// Square waves range from -8 (low) to 7 (high)
-
-s8 square_pattern_duty[4][8] =
-{
-  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
-  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 },
-};
-
-s8 wave_samples[64];
-
-u32 noise_table15[1024];
-u32 noise_table7[4];
-
-u32 gbc_sound_master_volume_table[4] = { 1, 2, 4, 0 };
-
-u32 gbc_sound_channel_volume_table[8] =
-{
-  FIXED_DIV(0, 7, 12),
-  FIXED_DIV(1, 7, 12),
-  FIXED_DIV(2, 7, 12),
-  FIXED_DIV(3, 7, 12),
-  FIXED_DIV(4, 7, 12),
-  FIXED_DIV(5, 7, 12),
-  FIXED_DIV(6, 7, 12),
-  FIXED_DIV(7, 7, 12)
-};
-
-u32 gbc_sound_envelope_volume_table[16] =
-{
-  FIXED_DIV(0, 15, 14),
-  FIXED_DIV(1, 15, 14),
-  FIXED_DIV(2, 15, 14),
-  FIXED_DIV(3, 15, 14),
-  FIXED_DIV(4, 15, 14),
-  FIXED_DIV(5, 15, 14),
-  FIXED_DIV(6, 15, 14),
-  FIXED_DIV(7, 15, 14),
-  FIXED_DIV(8, 15, 14),
-  FIXED_DIV(9, 15, 14),
-  FIXED_DIV(10, 15, 14),
-  FIXED_DIV(11, 15, 14),
-  FIXED_DIV(12, 15, 14),
-  FIXED_DIV(13, 15, 14),
-  FIXED_DIV(14, 15, 14),
-  FIXED_DIV(15, 15, 14)
-};
-
-u32 gbc_sound_buffer_index = 0;
-u32 gbc_sound_last_cpu_ticks = 0;
-u32 gbc_sound_partial_ticks = 0;
-
-u32 gbc_sound_master_volume_left;
-u32 gbc_sound_master_volume_right;
-u32 gbc_sound_master_volume;
-
-
 void update_gbc_sound(u32 cpu_ticks)
 {
   FIXED16_16 buffer_ticks = FLOAT_TO_FP16_16(((float)(cpu_ticks -
-   gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / 16777216.0);
+   gbc_sound_last_cpu_ticks) * sound_frequency) / 16777216.0);
   u32 i, i2;
   gbc_sound_struct *gs = gbc_sound_channel;
   FIXED16_16 sample_index, frequency_step;
@@ -504,24 +446,24 @@
     gbc_sound_partial_ticks &= 0xFFFF;
   }
 
-//  SDL_LockMutex(sound_mutex);
+  SDL_LockMutex(sound_mutex);
 
   if(synchronize_flag)
   {
     if(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
      (audio_buffer_size_x2))
     {
-//      while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
-//       (audio_buffer_size_x2))
-//      {
-//        SDL_CondWait(sound_cv, sound_mutex);
-//      }
-//      if(game_config_frameskip_type == auto_frameskip)
-//      {
-//        sceDisplayWaitVblankStart();
-//        real_frame_count = 0;
-//        virtual_frame_count = 0;
-//      }
+      while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
+       (audio_buffer_size_x2))
+      {
+        SDL_CondWait(sound_cv, sound_mutex);
+      }
+      if(game_config_frameskip_type == auto_frameskip)
+      {
+        sceDisplayWaitVblankStart();
+        real_frame_count = 0;
+        virtual_frame_count = 0;
+      }
     }
   }
 
@@ -533,7 +475,7 @@
       sound_status |= 0x01;
       sample_data = gs->sample_data;
       envelope_volume = gs->envelope_volume;
-      GBC_SOUND_RENDER_CHANNEL(samples, 8, envelope, sweep);
+      gbc_sound_render_channel(samples, 8, envelope, sweep);
     }
 
     gs = gbc_sound_channel + 1;
@@ -542,21 +484,13 @@
       sound_status |= 0x02;
       sample_data = gs->sample_data;
       envelope_volume = gs->envelope_volume;
-      GBC_SOUND_RENDER_CHANNEL(samples, 8, envelope, nosweep);
+      gbc_sound_render_channel(samples, 8, envelope, nosweep);
     }
 
     gs = gbc_sound_channel + 2;
     if(gbc_sound_wave_update)
     {
-      if(gs->wave_bank == 1)
-      {
-        GBC_SOUND_LOAD_WAVE_RAM(1);
-      }
-      else
-      {
-        GBC_SOUND_LOAD_WAVE_RAM(0);
-      }
-
+      gbc_sound_load_wave_ram(gs->wave_bank);
       gbc_sound_wave_update = 0;
     }
 
@@ -569,11 +503,11 @@
         if(gs->wave_bank == 1)
           sample_data += 32;
 
-        GBC_SOUND_RENDER_CHANNEL(samples, 32, noenvelope, nosweep);
+        gbc_sound_render_channel(samples, 32, noenvelope, nosweep);
       }
       else
       {
-        GBC_SOUND_RENDER_CHANNEL(samples, 64, noenvelope, nosweep);
+        gbc_sound_render_channel(samples, 64, noenvelope, nosweep);
       }
     }
 
@@ -585,45 +519,72 @@
 
       if(gs->noise_type == 1)
       {
-        GBC_SOUND_RENDER_CHANNEL(noise, half, envelope, nosweep);
+        gbc_sound_render_channel(noise, half, envelope, nosweep);
       }
       else
       {
-        GBC_SOUND_RENDER_CHANNEL(noise, full, envelope, nosweep);
+        gbc_sound_render_channel(noise, full, envelope, nosweep);
       }
     }
   }
 
   ADDRESS16(io_registers, 0x84) = sound_status;
 
+  SDL_CondSignal(sound_cv);
+
+  SDL_UnlockMutex(sound_mutex);
+
   gbc_sound_last_cpu_ticks = cpu_ticks;
   gbc_sound_buffer_index =
    (gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
 }
 
+#define sound_copy_normal()                                                   \
+  current_sample = source[i]                                                  \
+
+#define sound_copy(source_offset, length, render_type)                        \
+  _length = (length) / 2;                                                     \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  for(i = 0; i < _length; i++)                                                \
+  {                                                                           \
+    sound_copy_##render_type();                                               \
+    if(current_sample > 2047)                                                 \
+      current_sample = 2047;                                                  \
+    if(current_sample < -2048)                                                \
+      current_sample = -2048;                                                 \
+                                                                              \
+    stream_base[i] = current_sample << 4;                                     \
+    source[i] = 0;                                                            \
+  }                                                                           \
+
+#define sound_copy_null(source_offset, length)                                \
+  _length = (length) >> 2;                                                    \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  {                                                                           \
+    u32 *ptr1 = (u32 *) stream_base;                                          \
+    u32 *ptr2 = (u32 *) source;                                               \
+    while (_length--) *ptr1++ = *ptr2++ = 0;                                  \
+  }                                                                           \
+
 
-static int sound_update_thread(SceSize args, void *argp)
-  {
-    return 0;
-  }
 /*--------------------------------------------------------
   サウンド コールバック
 --------------------------------------------------------*/
-void sound_callback(/*void *userdata, char *stream, int length*/)
+void sound_callback(void *userdata, Uint8 *stream, int length)
 {
-/*  u32 sample_length = length / 2;
+  u32 sample_length = length / 2;
   u32 _length;
   u32 i;
   s16 *stream_base = (s16 *)stream;
   s16 *source;
   s32 current_sample;
 
-//  SDL_LockMutex(sound_mutex);
+  SDL_LockMutex(sound_mutex);
 
   while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) <
    length)
   {
-//    SDL_CondWait(sound_cv, sound_mutex);
+    SDL_CondWait(sound_cv, sound_mutex);
   }
 
   if(global_enable_audio)
@@ -631,14 +592,14 @@
     if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
     {
       u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
-      SOUND_COPY(sound_buffer_base, partial_length, normal);
+      sound_copy(sound_buffer_base, partial_length, normal);
 //      source = (s16 *)sound_buffer;
-      SOUND_COPY(0, length - partial_length, normal);
+      sound_copy(0, length - partial_length, normal);
       sound_buffer_base = (length - partial_length) / 2;
     }
     else
     {
-      SOUND_COPY(sound_buffer_base, length, normal);
+      sound_copy(sound_buffer_base, length, normal);
       sound_buffer_base += sample_length;
     }
   }
@@ -647,22 +608,21 @@
     if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
     {
       u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
-      SOUND_COPY_NULL(sound_buffer_base, partial_length);
+      sound_copy_null(sound_buffer_base, partial_length);
 //      source = (s16 *)sound_buffer;
-      SOUND_COPY_NULL(0, length - partial_length);
+      sound_copy_null(0, length - partial_length);
       sound_buffer_base = (length - partial_length) / 2;
     }
     else
     {
-      SOUND_COPY_NULL(sound_buffer_base, length);
+      sound_copy_null(sound_buffer_base, length);
       sound_buffer_base += sample_length;
     }
   }
 
-//  SDL_CondSignal(sound_cv);
+  SDL_CondSignal(sound_cv);
 
-//  SDL_UnlockMutex(sound_mutex);
-*/
+  SDL_UnlockMutex(sound_mutex);
 }
 
 // Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
@@ -741,42 +701,43 @@
 {
 //  gbc_sound_buffer_index =
 //   (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
-//  SDL_PauseAudio(1);
-//  SDL_CondSignal(sound_cv);
+  SDL_PauseAudio(1);
+  SDL_CondSignal(sound_cv);
 }
 
 void init_sound()
 {
   audio_buffer_size = (audio_buffer_size_number * 1024) + 2048;
-  audio_buffer_size_x2 = audio_buffer_size * 2;
 
-  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
+  SDL_AudioSpec desired_spec =
+  {
+    sound_frequency,
+    AUDIO_S16,
+    2,
+    0,
+    audio_buffer_size / 4,
+    0,
+    0,
+    sound_callback,
+    NULL
+  };
+
+  SDL_OpenAudio(&desired_spec, &sound_settings);
+  sound_mutex = SDL_CreateMutex();
+  sound_cv = SDL_CreateCond();
+
+  sound_frequency = sound_settings.freq;
+  audio_buffer_size = sound_settings.size;
+  audio_buffer_size_x2 = audio_buffer_size * 3;
+
+  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / sound_frequency);
 
   init_noise_table(noise_table15, 32767, 14);
   init_noise_table(noise_table7, 127, 6);
 
-  // 変数等の初期化
   reset_sound();
 
-  // オーディオチャンネルの設定
-  sound_handle = sceAudioChReserve(PSP_AUDIO_NEXT_CHANNEL, audio_buffer_size / 4, PSP_AUDIO_FORMAT_STEREO);
-  if (sound_handle < 0)
-  {
-    quit();
-  }
-
-  sound_thread = sceKernelCreateThread("Sound thread", sound_callback/*sound_update_thread*/, 0x08, 0x1000, 0, NULL);
-  if (sound_thread < 0)
-  {
-    sceAudioChRelease(sound_handle);
-    sound_handle = -1;
-    quit();
-  }
-
-
-  //スレッドの開始
-  sceKernelStartThread(sound_thread, 0, 0);
-
+  SDL_PauseAudio(0);
 }
 
 #define sound_savestate_body(type)                                          \
diff -ru 30_orig/sound.h 30_new/sound.h
--- 30_orig/sound.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/sound.h	2007-08-06 23:46:42.000000000 +0900
@@ -103,18 +103,17 @@
 extern u32 gbc_sound_master_volume_right;
 extern u32 gbc_sound_master_volume;
 
+extern u32 sound_frequency;
 extern u32 sound_on;
 
 extern u32 global_enable_audio;
 extern u32 enable_low_pass_filter;
 extern u32 audio_buffer_size_number;
 
-//extern SDL_mutex *sound_mutex;
-//extern SDL_cond *sound_cv;
+extern SDL_mutex *sound_mutex;
+extern SDL_cond *sound_cv;
 
-void sound_timer_queue8(u32 channel, u8 value);
-void sound_timer_queue16(u32 channel, u16 value);
-void sound_timer_queue32(u32 channel, u32 value);
+void sound_timer_queue32(u8 channel);
 void sound_timer(FIXED16_16 frequency_step, u32 channel);
 void sound_reset_fifo(u32 channel);
 void update_gbc_sound(u32 cpu_ticks);
@@ -122,7 +121,7 @@
 void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file);
 void sound_read_savestate(FILE_TAG_TYPE savestate_file);
 
-#define SOUND_FREQUENCY 44100
+// #define SOUND_FREQUENCY 44100
 
 #define gbc_sound_tone_control_low(channel, address)                          \
 {                                                                             \
@@ -137,7 +136,6 @@
   gbc_sound_channel[channel].envelope_initial_ticks = envelope_ticks;         \
   gbc_sound_channel[channel].envelope_ticks = envelope_ticks;                 \
   gbc_sound_channel[channel].envelope_status = (envelope_ticks != 0);         \
-  gbc_sound_channel[channel].envelope_volume = initial_volume;                \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, address) = value;                                   \
 }                                                                             \
@@ -147,7 +145,7 @@
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[channel].rate = rate;                                     \
   gbc_sound_channel[channel].frequency_step =                                 \
-   FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / SOUND_FREQUENCY);    \
+   FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / sound_frequency);    \
   gbc_sound_channel[channel].length_status = (value >> 14) & 0x01;            \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -157,6 +155,8 @@
      gbc_sound_channel[channel].envelope_initial_ticks;                       \
     gbc_sound_channel[channel].envelope_volume =                              \
      gbc_sound_channel[channel].envelope_initial_volume;                      \
+    gbc_sound_channel[channel].sweep_ticks =                                  \
+     gbc_sound_channel[channel].sweep_initial_ticks;                          \
   }                                                                           \
                                                                               \
   gbc_sound_update = 1;                                                       \
@@ -192,10 +192,12 @@
   ADDRESS16(io_registers, 0x70) = value;                                      \
 }                                                                             \
 
-extern u32 gbc_sound_wave_volume[4];
+// extern u32 gbc_sound_wave_volume[4];
 
 #define gbc_sound_tone_control_low_wave()                                     \
 {                                                                             \
+  u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };                    \
+                                                                              \
   gbc_sound_channel[2].length_ticks = 256 - (value & 0xFF);                   \
   if((value >> 15) & 0x01)                                                    \
   {                                                                           \
@@ -215,7 +217,7 @@
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[2].rate = rate;                                           \
   gbc_sound_channel[2].frequency_step =                                       \
-   FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / SOUND_FREQUENCY);           \
+   FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / sound_frequency);           \
   gbc_sound_channel[2].length_status = (value >> 14) & 0x01;                  \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -234,13 +236,13 @@
   {                                                                           \
     gbc_sound_channel[3].frequency_step =                                     \
      FLOAT_TO_FP16_16(1048576.0 / (1 << (frequency_shift + 1)) /              \
-     SOUND_FREQUENCY);                                                        \
+     sound_frequency);                                                        \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     gbc_sound_channel[3].frequency_step =                                     \
      FLOAT_TO_FP16_16(524288.0 / (dividing_ratio *                            \
-     (1 << (frequency_shift + 1))) / SOUND_FREQUENCY);                        \
+     (1 << (frequency_shift + 1))) / sound_frequency);                        \
   }                                                                           \
   gbc_sound_channel[3].noise_type = (value >> 3) & 0x01;                      \
   gbc_sound_channel[3].length_status = (value >> 14) & 0x01;                  \
@@ -258,13 +260,14 @@
 }                                                                             \
 
 #define gbc_trigger_sound_channel(channel)                                    \
-  gbc_sound_master_volume_right = value & 0x07;                               \
-  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
-  gbc_sound_channel[channel].status = ((value >> (channel + 8)) & 0x01) |     \
-   ((value >> (channel + 11)) & 0x03)                                         \
+  gbc_sound_channel[channel].status =                                         \
+  ((value >> (channel + 11)) & 0x02) | ((value >> (channel + 8)) & 0x01)      \
 
 #define gbc_trigger_sound()                                                   \
 {                                                                             \
+  gbc_sound_master_volume_right = value & 0x07;                               \
+  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
+                                                                              \
   gbc_trigger_sound_channel(0);                                               \
   gbc_trigger_sound_channel(1);                                               \
   gbc_trigger_sound_channel(2);                                               \
@@ -274,10 +277,11 @@
 
 #define trigger_sound()                                                       \
 {                                                                             \
-  timer[0].direct_sound_channels = (((value >> 10) & 0x01) == 0) |            \
-   ((((value >> 14) & 0x01) == 0) << 1);                                      \
-  timer[1].direct_sound_channels = (((value >> 10) & 0x01) == 1) |            \
-   ((((value >> 14) & 0x01) == 1) << 1);                                      \
+  timer[0].direct_sound_channels =                                            \
+   ((~value >> 13) & 0x02) | ((~value >> 10) & 0x01);                         \
+  timer[1].direct_sound_channels =                                            \
+   ((value >> 13) & 0x02) | ((value >> 10) & 0x01);                           \
+                                                                              \
   direct_sound_channel[0].volume = (value >> 2) & 0x01;                       \
   direct_sound_channel[0].status = (value >> 8) & 0x03;                       \
   direct_sound_channel[1].volume = (value >> 3) & 0x01;                       \
@@ -294,10 +298,7 @@
 #define sound_on()                                                            \
   if(value & 0x80)                                                            \
   {                                                                           \
-    if(sound_on != 1)                                                         \
-    {                                                                         \
-      sound_on = 1;                                                           \
-    }                                                                         \
+    sound_on = 1;                                                             \
   }                                                                           \
   else                                                                        \
   {                                                                           \
@@ -313,7 +314,7 @@
 
 #define sound_update_frequency_step(timer_number)                             \
   timer[timer_number].frequency_step =                                        \
-   FLOAT_TO_FP16_16(16777216.0 / (timer_reload * SOUND_FREQUENCY))            \
+   FLOAT_TO_FP16_16(16777216.0 / (timer_reload * sound_frequency))            \
 
 void reset_sound();
 void sound_exit();
diff -ru 30_orig/video.c 30_new/video.c
--- 30_orig/video.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/video.c	2007-08-06 23:46:48.000000000 +0900
@@ -162,21 +162,13 @@
   CONVERT_PALETTE(current_pixel)                                              \
 
 #define tile_lookup_palette(palette, source)                                  \
-  current_pixel = palette[source];                                            \
+  current_pixel = palette[source]                                             \
 
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_expand_base_normal(index)                                        \
-  tile_expand_base_color16(index)                                             \
-
-#else
-
 #define tile_expand_base_normal(index)                                        \
   tile_lookup_palette(palette, current_pixel);                                \
   dest_ptr[index] = current_pixel                                             \
 
-#endif
 
 #define tile_expand_transparent_normal(index)                                 \
   tile_expand_base_normal(index)                                              \
@@ -621,20 +613,10 @@
 // Draws eight background pixels for the normal renderer, just a bunch of
 // zeros.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define tile_4bpp_draw_eight_base_zero_normal()                               \
-  current_pixel = 0;                                                          \
-  tile_4bpp_draw_eight_base_zero(current_pixel)                               \
-
-#else
-
 #define tile_4bpp_draw_eight_base_zero_normal()                               \
   current_pixel = palette[0];                                                 \
   tile_4bpp_draw_eight_base_zero(current_pixel)                               \
 
-#endif
-
 
 // Draws eight 4bpp pixels.
 
@@ -698,7 +680,7 @@
 #define get_tile_4bpp()                                                       \
   current_tile = *map_ptr;                                                    \
   current_palette = (current_tile >> 12) << 4;                                \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32);                       \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32)                        \
 
 
 // Helper macro for drawing clipped 4bpp tiles.
@@ -955,6 +937,7 @@
   }                                                                           \
 }                                                                             \
 
+
 // If rendering a scanline that is not a target A then there's no point in
 // keeping what's underneath it because it can't blend with it.
 
@@ -967,19 +950,9 @@
   }                                                                           \
 
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_extra_variables_base_normal(bg_type)                  \
-  const u32 pixel_combine = 0                                                 \
-
-#else
-
 #define render_scanline_extra_variables_base_normal(bg_type)                  \
   u16 *palette = palette_ram_converted                                        \
 
-#endif
-
-
 #define render_scanline_extra_variables_base_alpha(bg_type)                   \
   u32 bg_combine = color_combine_mask(5);                                     \
   u32 pixel_combine = color_combine_mask(layer) | (bg_combine << 16);         \
@@ -1450,30 +1423,13 @@
   else                                                                        \
     src_ptr = (u16 *)vram                                                     \
 
-
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_vram_setup_mode4()                                    \
-  const u32 pixel_combine = 0;                                                \
-  u8 *src_ptr;                                                                \
-  if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
-  else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-
-#else
-
 #define render_scanline_vram_setup_mode4()                                    \
   u16 *palette = palette_ram_converted;                                       \
   u8 *src_ptr;                                                                \
   if(io_registers[REG_DISPCNT] & 0x10)                                        \
-    src_ptr = (u8 *)(vram + 0xA000);                                                  \
+    src_ptr = vram + 0xA000;                                                  \
   else                                                                        \
-    src_ptr = (u8 *)vram                                                            \
-
-#endif
-
+    src_ptr = vram                                                            \
 
 
 // Build bitmap scanline rendering functions.
@@ -1738,7 +1694,7 @@
 
 #define obj_render_scale_pixel_8bpp(combine_op, alpha_op)                     \
   current_pixel = tile_ptr[tile_map_offset + (tile_x & 0x07)];                \
-  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op);                          \
+  tile_8bpp_draw_##combine_op(0, none, 0, alpha_op)                           \
 
 #define obj_render_scale(combine_op, color_depth, alpha_op, map_space)        \
 {                                                                             \
@@ -1923,19 +1879,9 @@
 
 // Build obj rendering functions
 
-#ifdef RENDER_COLOR16_NORMAL
-
-#define render_scanline_obj_extra_variables_normal(bg_type)                   \
-  const u32 pixel_combine = (1 << 8)                                          \
-
-#else
-
 #define render_scanline_obj_extra_variables_normal(bg_type)                   \
   u16 *palette = palette_ram_converted + 256                                  \
 
-#endif
-
-
 #define render_scanline_obj_extra_variables_color()                           \
   u32 dest;                                                                   \
   u32 pixel_combine = color_combine_mask(4) | (1 << 8)                        \
@@ -2173,7 +2119,6 @@
     obj_attribute_0 = oam_ptr[0];
     obj_attribute_2 = oam_ptr[2];
     obj_size = obj_attribute_0 & 0xC000;
-    obj_priority = (obj_attribute_2 >> 10) & 0x03;
     obj_mode = (obj_attribute_0 >> 10) & 0x03;
 
     if(((obj_attribute_0 & 0x0300) != 0x0200) && (obj_size != 0xC000) &&
@@ -2186,6 +2131,7 @@
 
       obj_attribute_1 = oam_ptr[1];
       obj_size = ((obj_size >> 12) & 0x0C) | (obj_attribute_1 >> 14);
+      obj_priority = (obj_attribute_2 >> 10) & 0x03;
       obj_height = obj_height_table[obj_size];
       obj_width = obj_width_table[obj_size];
 
@@ -2331,10 +2277,10 @@
   }                                                                           \
 
 #define brighten_pixel()                                                      \
-  pixel_top = upper + ((pixel_top * blend) >> 4);                             \
+  pixel_top = upper + ((pixel_top * blend) >> 4)                              \
 
 #define darken_pixel()                                                        \
-  pixel_top = (pixel_top * blend) >> 4;                                       \
+  pixel_top = (pixel_top * blend) >> 4                                        \
 
 #define effect_condition_alpha                                                \
   ((pixel_pair & 0x04000200) == 0x04000200)                                   \
@@ -2422,32 +2368,8 @@
 
 // Blend top two pixels of scanline with each other.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-void expand_normal(u16 *screen_ptr, u32 start, u32 end)
-{
-  u32 i, pixel_source;
-  screen_ptr += start;
-
-  return;
-
-  end -= start;
-
-  for(i = 0; i < end; i++)
-  {
-    pixel_source = *screen_ptr;
-    *screen_ptr = palette_ram_converted[pixel_source];
-
-    screen_ptr++;
-  }
-}
-
-#else
-
 #define expand_normal(screen_ptr, start, end)
 
-#endif
-
 void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
@@ -3399,16 +3321,16 @@
   gecb.finish_arg = NULL;
   gecbid = sceGeSetCallback(&gecb);
 
-  screen_vertex[0] = 0 + 0.5;
-  screen_vertex[1] = 0 + 0.5;
-  screen_vertex[2] = 0 + 0.5;
-  screen_vertex[3] = 0 + 0.5;
-  screen_vertex[4] = 0;
+  screen_vertex[0] = 0.0 + 0.5;
+  screen_vertex[1] = 0.0 + 0.5;
+  screen_vertex[2] = 0.0 + 0.5;
+  screen_vertex[3] = 0.0 + 0.5;
+  screen_vertex[4] = 0.0;
   screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
   screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
   screen_vertex[7] = PSP_SCREEN_WIDTH - 0.5;
   screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
-  screen_vertex[9] = 0;
+  screen_vertex[9] = 0.0;
 
   // Set framebuffer to PSP VRAM
   GE_CMD(FBP, ((u32)psp_gu_vram_base & 0x00FFFFFF));
@@ -3471,24 +3393,36 @@
   switch(scale)
   {
     case unscaled:
-      screen_vertex[2] = 120 + 0.5;
-      screen_vertex[3] = 56 + 0.5;
-      screen_vertex[7] = GBA_SCREEN_WIDTH + 120 - 0.5;
-      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56 - 0.5;
+      screen_vertex[0] = 0.0;
+      screen_vertex[1] = 0.0;
+      screen_vertex[2] = 120.0;
+      screen_vertex[3] = 56.0;
+      screen_vertex[5] = (float)GBA_SCREEN_WIDTH;
+      screen_vertex[6] = (float)GBA_SCREEN_HEIGHT;
+      screen_vertex[7] = GBA_SCREEN_WIDTH + 120.0;
+      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56.0;
       break;
 
     case scaled_aspect:
-      screen_vertex[2] = 36 + 0.5;
-      screen_vertex[3] = 0 + 0.5;
-      screen_vertex[7] = 408 + 36 - 0.5;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 36.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = 408.0 + 36.0;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
 
     case fullscreen:
-      screen_vertex[2] = 0;
-      screen_vertex[3] = 0;
-      screen_vertex[7] = PSP_SCREEN_WIDTH;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 0.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = (float)PSP_SCREEN_WIDTH;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
   }
 
diff -ru 30_orig/zip.c 30_new/zip.c
--- 30_orig/zip.c	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/zip.c	2007-08-06 23:45:44.000000000 +0900
@@ -44,7 +44,7 @@
   s16 ExtraFieldLength;
 }  __attribute__((packed));
 
-u32 load_file_zip(char *filename)
+s32 load_file_zip(char *filename)
 {
   struct SZIPFileHeader data;
   char tmp[1024];
@@ -123,6 +123,7 @@
 
           stream.zalloc = (alloc_func)0;
           stream.zfree = (free_func)0;
+          stream.opaque = (voidpf)0;
 
           err = inflateInit2(&stream, -MAX_WBITS);
 
diff -ru 30_orig/zip.h 30_new/zip.h
--- 30_orig/zip.h	2007-08-06 01:50:58.000000000 +0900
+++ 30_new/zip.h	2007-08-06 23:45:26.000000000 +0900
@@ -21,7 +21,7 @@
 #ifndef ZIP_H
 #define ZIP_H
 
-u32 load_file_zip(char *filename);
+s32 load_file_zip(char *filename);
 
 #endif
 
