Only in gpsp-kai-test/: .cproject
Only in gpsp-kai-test/: .metadata
Only in gpsp-kai-test/: .project
Only in gpsp-kai-test/: .settings
Only in gpsp-kai-test/: .svn
Only in gpsp-kai-test/: comment.txt
diff -ru 30_orig/common.h gpsp-kai-test/common.h
--- 30_orig/common.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/common.h	2007-08-12 00:47:22.956760800 +0900
@@ -49,14 +49,17 @@
 #include <pspnet_adhocctl.h>
 #include <pspnet_adhocmatching.h>
 #include <pspwlan.h>
+#include <psputility_osk.h>
 
 typedef s32 FILE_TAG_TYPE;
 typedef u32 FIXED16_16;
 
-#define MAX_PATH 512
-#define MAX_FILE 64
+#define MAX_PATH 1024
+#define MAX_FILE 256
 #define FILE_ID SceUID
 
+#define SYS_CLOCK (16777216.0)
+
 #define ROR(dest, value, shift)                                             \
   dest = ((value) >> (shift)) | ((value) << (32 - (shift)))                 \
 
@@ -157,7 +160,6 @@
 #define DBGOUT(...) fprintf(dbg_file, __VA_ARGS__)
 FILE *dbg_file;
 
-//#include "SDL.h"
 #include "cpu.h"
 #include "memory.h"
 #include "video.h"
diff -ru 30_orig/cpu.c gpsp-kai-test/cpu.c
--- 30_orig/cpu.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/cpu.c	2007-08-09 16:32:35.474000000 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -459,7 +460,7 @@
   n_flag = reg[REG_CPSR] >> 31;                                               \
   z_flag = (reg[REG_CPSR] >> 30) & 0x01;                                      \
   c_flag = (reg[REG_CPSR] >> 29) & 0x01;                                      \
-  v_flag = (reg[REG_CPSR] >> 28) & 0x01;                                      \
+  v_flag = (reg[REG_CPSR] >> 28) & 0x01                                       \
 
 #define collapse_flags()                                                      \
   reg[REG_CPSR] = (n_flag << 31) | (z_flag << 30) | (c_flag << 29) |          \
@@ -467,8 +468,7 @@
 
 #define memory_region(r_dest, l_dest, address)                                \
   r_dest = memory_regions[(address) >> 24];                                   \
-  l_dest = memory_limits[(address) >> 24];                                    \
-
+  l_dest = memory_limits[(address) >> 24]                                     \
 
 #define pc_region()                                                           \
   memory_region(pc_region, pc_limit, pc)                                      \
@@ -638,7 +638,7 @@
 
 #define arm_multiply_flags_yes(_dest)                                         \
   calculate_z_flag(_dest);                                                    \
-  calculate_n_flag(_dest);                                                    \
+  calculate_n_flag(_dest)                                                     \
 
 #define arm_multiply_flags_no(_dest)                                          \
 
@@ -659,7 +659,7 @@
 }                                                                             \
 
 #define arm_multiply_long_addop(type)                                         \
-  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]));                  \
+  + ((type##64)((((type##64)reg[rdhi]) << 32) | reg[rdlo]))                   \
 
 #define arm_multiply_long(add_op, flags, type)                                \
 {                                                                             \
@@ -1332,7 +1332,7 @@
   address += offset + 4                                                       \
 
 #define thumb_block_address_postadjust_push_lr()                              \
-  store_memory_u32(address + offset, reg[REG_LR]);                            \
+  store_memory_u32(address + offset, reg[REG_LR])                             \
 
 #define thumb_block_memory_wb_load(base_reg)                                  \
   if(!((reg_list >> base_reg) & 0x01))                                        \
@@ -1390,13 +1390,13 @@
 
 u32 cpu_modes[32] =
 {
-  MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_USER, MODE_FIQ, MODE_IRQ, MODE_SUPERVISOR, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_ABORT, MODE_INVALID, MODE_INVALID,
-  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED, MODE_INVALID, MODE_INVALID,
-  MODE_USER
+  MODE_INVALID, MODE_INVALID, MODE_INVALID  , MODE_INVALID  , MODE_INVALID,
+  MODE_INVALID, MODE_INVALID, MODE_INVALID  , MODE_INVALID  , MODE_INVALID,
+  MODE_INVALID, MODE_INVALID, MODE_INVALID  , MODE_INVALID  , MODE_INVALID,
+  MODE_INVALID, MODE_USER   , MODE_FIQ      , MODE_IRQ      , MODE_SUPERVISOR,
+  MODE_INVALID, MODE_INVALID, MODE_INVALID  , MODE_ABORT    , MODE_INVALID,
+  MODE_INVALID, MODE_INVALID, MODE_UNDEFINED,MODE_INVALID , MODE_INVALID,
+  MODE_INVALID, MODE_USER
 };
 
 u32 cpu_modes_cpsr[7] = { 0x10, 0x11, 0x12, 0x13, 0x17, 0x1B, 0x1F };
@@ -1888,7 +1888,7 @@
       else                                                                    \
       {                                                                       \
         /* RSC rd, rn, reg_op */                                              \
-        arm_data_proc(reg_sh - reg[rn] + c_flag - 1, reg);                    \
+        arm_data_proc(reg_sh - (reg[rn] + (c_flag ^ 1)), reg);                \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -1921,7 +1921,7 @@
       else                                                                    \
       {                                                                       \
         /* RSCS rd, rn, reg_op */                                             \
-        arm_data_proc_sub_flags((reg_sh + c_flag - 1), reg[rn], reg);         \
+        arm_data_proc_sub_flags(reg_sh, reg[rn] + (c_flag ^ 1), reg);         \
       }                                                                       \
       break;                                                                  \
                                                                               \
@@ -2351,7 +2351,7 @@
                                                                               \
     case 0x2C:                                                                \
       /* SBC rd, rn, imm */                                                   \
-      arm_data_proc(reg[rn] - imm + c_flag - 1, imm);                         \
+      arm_data_proc(reg[rn] - (imm + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2D:                                                                \
@@ -2361,12 +2361,12 @@
                                                                               \
     case 0x2E:                                                                \
       /* RSC rd, rn, imm */                                                   \
-      arm_data_proc(imm - reg[rn] + c_flag - 1, imm);                         \
+      arm_data_proc(imm - (reg[rn] + (c_flag ^ 1)), imm);                     \
       break;                                                                  \
                                                                               \
     case 0x2F:                                                                \
       /* RSCS rd, rn, imm */                                                  \
-      arm_data_proc_sub_flags((imm + c_flag - 1), reg[rn], imm);              \
+      arm_data_proc_sub_flags(imm, reg[rn] + (c_flag ^ 1), imm);              \
       break;                                                                  \
                                                                               \
     case 0x30 ... 0x31:                                                       \
@@ -2919,22 +2919,7 @@
       arm_block_memory(load, up, up, yes);                                    \
       break;                                                                  \
                                                                               \
-    case 0xA0:                                                                \
-    case 0xA1:                                                                \
-    case 0xA2:                                                                \
-    case 0xA3:                                                                \
-    case 0xA4:                                                                \
-    case 0xA5:                                                                \
-    case 0xA6:                                                                \
-    case 0xA7:                                                                \
-    case 0xA8:                                                                \
-    case 0xA9:                                                                \
-    case 0xAA:                                                                \
-    case 0xAB:                                                                \
-    case 0xAC:                                                                \
-    case 0xAD:                                                                \
-    case 0xAE:                                                                \
-    case 0xAF:                                                                \
+    case 0xA0 ... 0xAF:                                                       \
     {                                                                         \
       /* B offset */                                                          \
       arm_decode_branch();                                                    \
@@ -2963,13 +2948,13 @@
       switch(swi_comment >> 16)                                               \
       {                                                                       \
         /* Jump to BIOS SWI handler */                                        \
-        case 0x00 ... 0x2b:                                                   \
+        case 0x00 ... 0x2A:                                                   \
           reg_mode[MODE_SUPERVISOR][6] = pc + 4;                              \
           collapse_flags();                                                   \
           spsr[MODE_SUPERVISOR] = reg[REG_CPSR];                              \
           reg[REG_PC] = 0x00000008;                                           \
           arm_update_pc();                                                    \
-          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x3F) | 0x13;                     \
+          reg[REG_CPSR] = (reg[REG_CPSR] & ~0x1F) | 0x13;                     \
           set_cpu_mode(MODE_SUPERVISOR);                                      \
           break;                                                              \
       }                                                                       \
@@ -3596,7 +3581,7 @@
       thumb_add_noflags(imm, 7, reg[REG_SP], (imm * 4));                      \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
diff -ru 30_orig/cpu_threaded.c gpsp-kai-test/cpu_threaded.c
--- 30_orig/cpu_threaded.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/cpu_threaded.c	2007-08-09 16:57:58.917000000 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -49,7 +50,9 @@
 u32 allow_smc_ram_u8 = 1;
 u32 allow_smc_ram_u16 = 1;
 u32 allow_smc_ram_u32 = 1;
-u32 waitstate_cycles_sequential[16][3];
+u8 waitstate_cycles_seq[2][16];
+u8 waitstate_cycles_non_seq[2][16];
+u8 cpu_waitstate_cycles_seq[2][16];
 
 u32 bios_mode;
 
@@ -78,7 +81,7 @@
   u32 rn = (opcode >> 16) & 0x0F;                                             \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_psr_reg()                                                  \
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
@@ -89,7 +92,7 @@
   u32 psr_field = (opcode >> 16) & 0x0F;                                      \
   u32 rd = (opcode >> 12) & 0x0F;                                             \
   u32 imm;                                                                    \
-  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2);                        \
+  ROR(imm, opcode & 0xFF, ((opcode >> 8) & 0x0F) * 2)                         \
 
 #define arm_decode_branchx()                                                  \
   u32 rn = opcode & 0x0F                                                      \
@@ -1639,7 +1642,7 @@
     }                                                                         \
   }                                                                           \
                                                                               \
-  pc += 4;                                                                    \
+  pc += 4                                                                     \
 
 #define arm_flag_status()                                                     \
 
@@ -1931,7 +1934,8 @@
                                                                               \
         case 0x01:                                                            \
           /* MUL rd, rs */                                                    \
-          thumb_data_proc(alu_op, muls, reg, rd, rd, rs);                     \
+          /*thumb_data_proc(alu_op, muls, reg, rd, rd, rs);*/                 \
+          thumb_data_proc_muls(alu_op, reg, rd, rd, rs);                      \
           break;                                                              \
                                                                               \
         case 0x02:                                                            \
@@ -2246,7 +2250,7 @@
       thumb_load_sp(7);                                                       \
       break;                                                                  \
                                                                               \
-    case 0xB0 ... 0xB3:                                                       \
+    case 0xB0:                                                                \
       if((opcode >> 7) & 0x01)                                                \
       {                                                                       \
         /* ADD sp, -imm */                                                    \
@@ -2579,7 +2583,16 @@
                                                                               \
     /* TST, NEG, CMP, CMN */                                                  \
     case 0x42:                                                                \
-      thumb_flag_modifies_all();                                              \
+      if((opcode >> 6) & 0x03)                                                \
+      {                                                                       \
+        /* NEG, CMP, CMN */                                                   \
+        thumb_flag_modifies_all();                                            \
+      }                                                                       \
+      else                                                                    \
+      {                                                                       \
+        /* TST rd, rs */                                                      \
+        thumb_flag_modifies_zn();                                             \
+      }                                                                       \
       break;                                                                  \
                                                                               \
     /* ORR, MUL, BIC, MVN */                                                  \
@@ -2937,7 +2950,7 @@
 #define arm_instruction_width 4
 
 #define arm_base_cycles()                                                     \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][2]                     \
+  cycle_count += cpu_waitstate_cycles_seq[1][pc >> 24]                        \
 
 // For now this just sets a variable that says flags should always be
 // computed.
@@ -2952,7 +2965,7 @@
 #define thumb_exit_point                                                      \
   (((opcode >= 0xD000) && (opcode < 0xDF00)) ||                               \
    (((opcode & 0xFF00) == 0xDF00) &&                                          \
-    (!swi_hle_handle[opcode & 0xFF][bios_mode])) ||                                      \
+    (!swi_hle_handle[opcode & 0xFF][bios_mode])) ||                           \
    ((opcode >= 0xE000) && (opcode < 0xE800)) ||                               \
    ((opcode & 0xFF00) == 0x4700) ||                                           \
    ((opcode & 0xFF00) == 0xBD00) ||                                           \
@@ -3012,7 +3025,7 @@
 #define thumb_instruction_width 2
 
 #define thumb_base_cycles()                                                   \
-  cycle_count += waitstate_cycles_sequential[pc >> 24][1]                     \
+  cycle_count += cpu_waitstate_cycles_seq[0][pc >> 24]                        \
 
 // Here's how this works: each instruction has three different sets of flag
 // attributes, each consisiting of a 4bit mask describing how that instruction
@@ -3150,7 +3163,7 @@
     block_data[block_data_position].update_cycles = 0;                        \
     block_data_position++;                                                    \
     if((block_data_position == MAX_BLOCK_SIZE) ||                             \
-     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFFF0))             \
+     (block_end_pc == 0x3007FF0) || (block_end_pc == 0x203FFF0))              \
     {                                                                         \
       break;                                                                  \
     }                                                                         \
Only in gpsp-kai-test/: game_config.txt
diff -ru 30_orig/gui.c gpsp-kai-test/gui.c
--- 30_orig/gui.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/gui.c	2007-08-12 12:08:04.014760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public Licens e as
@@ -251,6 +252,7 @@
 static char font16[MAX_PATH];
 static u32 menu_cheat_page = 0;
 static u32 gamepad_config_line_to_button[] = { 8, 6, 7, 9, 1, 2, 3, 0, 4, 5, 11, 10 };
+static u32 clock_speed_number;
 
 /******************************************************************************
  * ローカル関数の宣言
@@ -761,6 +763,8 @@
       if(game_config_clock_speed < 33)
         game_config_clock_speed = 33;
 
+      clock_speed_number = (game_config_clock_speed / 33) - 1;
+
       if(game_config_frameskip_value < 0)
         game_config_frameskip_value = 0;
 
@@ -780,9 +784,10 @@
 
   // 読み込めなかった場合の初期値の設定
   game_config_frameskip_type = auto_frameskip;
-  game_config_frameskip_value = 4;
+  game_config_frameskip_value = 9;
   game_config_random_skip = 0;
   game_config_clock_speed = 333;
+  clock_speed_number = 9;
 
   for(i = 0; i < MAX_CHEATS; i++)
   {
@@ -798,7 +803,7 @@
 --------------------------------------------------------*/
 s32 load_config_file()
 {
-  char config_path[512];
+  char config_path[MAX_PATH];
   FILE_ID config_file;
 
   sprintf(config_path, "%s/%s", main_path, GPSP_CONFIG_FILENAME);
@@ -823,9 +828,7 @@
       audio_buffer_size_number = file_options[3] % 11;
       update_backup_flag = file_options[4] % 2;
       global_enable_analog = file_options[5] % 2;
-      analog_sensitivity_level = file_options[6] % 8;
-
-      scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+      analog_sensitivity_level = file_options[6] % 10;
 
       // Sanity check: Make sure there's a MENU or FRAMESKIP
       // key, if not assign to triangle
@@ -857,7 +860,6 @@
 
 u32 menu(u16 *original_screen)
 {
-  u32 clock_speed_number = (game_config_clock_speed / 33) - 1;
   char print_buffer[81];
 //  u32 _current_option = 0;
   gui_action_type gui_action;
@@ -942,7 +944,7 @@
   void menu_load()
   {
     char *file_ext[] = { ".gba", ".bin", ".zip", NULL };
-    char load_filename[512];
+    char load_filename[MAX_FILE];
     save_game_config_file();
 
 //    if(!update_backup_flag)
@@ -978,7 +980,8 @@
 
   void menu_save_ss()
   {
-    save_ss_bmp(original_screen);
+    if(!first_load)
+      save_ss_bmp(original_screen);
   }
 
   void menu_change_state()
@@ -1170,7 +1173,7 @@
 
     STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_5], yes_no_options, &global_enable_audio, 2, msg[MSG_G_S_MENU_HELP_5], 9),
 
-    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 10, msg[MSG_G_S_MENU_HELP_6], 11),
+    STRING_SELECTION_OPTION(NULL, msg[MSG_G_S_MENU_6], audio_buffer_options, &audio_buffer_size_number, 11, msg[MSG_G_S_MENU_HELP_6], 11),
 
     ACTION_OPTION(menu_save_ss, NULL, msg[MSG_G_S_MENU_7], msg[MSG_G_S_MENU_HELP_7], 12),
 
@@ -1328,10 +1331,14 @@
   video_resolution_large();
 
 //  SDL_LockMutex(sound_mutex);
-//  SDL_PauseAudio(1);
+    pause_sound(1);
 //  sceKernelSleepThread();
 //  SDL_UnlockMutex(sound_mutex);
 
+  clock_speed_number = (game_config_clock_speed / 33) - 1;
+  // MENU時は222MHz
+  set_cpu_clock(222);
+
   if(gamepak_filename[0] == 0)
   {
     first_load = 1;
@@ -1480,11 +1487,12 @@
   set_gba_resolution(screen_scale);
   video_resolution_small();
 
-  game_config_clock_speed = (clock_speed_number + 1) * 33;
-
-  scePowerSetClockFrequency(game_config_clock_speed, game_config_clock_speed, game_config_clock_speed / 2);
+  game_config_clock_speed = (clock_speed_number + 1) * 333 / 10;
+  set_cpu_clock(game_config_clock_speed);
 
-//  SDL_PauseAudio(0);
+  pause_sound(0);
+  real_frame_count = 0;
+  virtual_frame_count = 0;
   return return_value;
 }
 
@@ -1495,7 +1503,7 @@
   char current_line[256];
   char current_str[256];
   FILE *msg_file;
-  char msg_path[512];
+  char msg_path[MAX_PATH];
 
   sprintf(msg_path, "%s/%s", main_path, file_name);
 
@@ -1595,7 +1603,7 @@
   char current_line[256];
   char current_str[256];
   FILE *msg_file;
-  char msg_path[512];
+  char msg_path[MAX_PATH];
 
   sprintf(msg_path, "%s/%s", main_path, file_name);
 
@@ -1644,7 +1652,7 @@
   char current_line[256];
   char current_str[256];
   FILE *msg_file;
-  char msg_path[512];
+  char msg_path[MAX_PATH];
 
   sprintf(msg_path, "%s/%s", main_path, file_name);
 
@@ -1910,15 +1918,13 @@
 
 static void get_timestamp_string(char *buffer, u16 msg_id, u16 year, u16 mon, u16 day, u16 wday, u16 hour, u16 min, u16 sec, u32 msec)
 {
-  int id;
   char *weekday_strings[] =
   {
     msg[MSG_WDAY_0], msg[MSG_WDAY_1], msg[MSG_WDAY_2], msg[MSG_WDAY_3],
     msg[MSG_WDAY_4], msg[MSG_WDAY_5], msg[MSG_WDAY_6], ""
   };
 
-  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&id);
-  switch(id)
+  switch(date_format)
   {
     case PSP_SYSTEMPARAM_DATE_FORMAT_YYYYMMDD:
       sprintf(buffer, msg[msg_id    ], year, mon, day, weekday_strings[wday], hour, min, sec, msec / 1000);
diff -ru 30_orig/gui.h gpsp-kai-test/gui.h
--- 30_orig/gui.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/gui.h	2007-08-12 01:04:54.162760800 +0900
@@ -29,11 +29,11 @@
  * グローバル変数の宣言
  ******************************************************************************/
 extern u32 SAVESTATE_SLOT;
-extern char DEFAULT_ROM_DIR[512];
-extern char DEFAULT_SAVE_DIR[512];
-extern char DEFAULT_CFG_DIR[512];
-extern char DEFAULT_SS_DIR[512];
-extern char DEFAULT_CHEAT_DIR[512];
+extern char DEFAULT_ROM_DIR[MAX_PATH];
+extern char DEFAULT_SAVE_DIR[MAX_PATH];
+extern char DEFAULT_CFG_DIR[MAX_PATH];
+extern char DEFAULT_SS_DIR[MAX_PATH];
+extern char DEFAULT_CHEAT_DIR[MAX_PATH];
 
 /******************************************************************************
  * グローバル関数の宣言
diff -ru 30_orig/input.c gpsp-kai-test/input.c
--- 30_orig/input.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/input.c	2007-08-11 16:30:28.611760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -104,19 +105,23 @@
     quit();
 
   sceCtrlPeekBufferPositive(&ctrl_data, 1);
-  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
-  if(ctrl_data.Lx < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_LEFT;
+  if(!(ctrl_data.Buttons & PSP_CTRL_HOLD))
+  {
+    if(ctrl_data.Lx < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_LEFT;
 
-  if(ctrl_data.Lx > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_RIGHT;
+    if(ctrl_data.Lx > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_RIGHT;
 
-  if(ctrl_data.Ly < analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_UP;
+    if(ctrl_data.Ly < analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_UP;
 
-  if(ctrl_data.Ly > inv_analog_sensitivity)
-    ctrl_data.Buttons = PSP_CTRL_DOWN;
+    if(ctrl_data.Ly > inv_analog_sensitivity)
+      ctrl_data.Buttons = PSP_CTRL_DOWN;
+  }
+
+  ctrl_data.Buttons &= PSP_ALL_BUTTON_MASK;
 
   new_buttons = (last_buttons ^ ctrl_data.Buttons) & ctrl_data.Buttons;
   last_buttons = ctrl_data.Buttons;
@@ -151,6 +156,9 @@
   if(new_buttons & PSP_CTRL_LTRIGGER)
     new_button = CURSOR_LTRIGGER;
 
+  if(new_buttons & PSP_CTRL_SELECT)
+    new_button = KEY_SELECT;
+
   if(new_button != CURSOR_NONE)
   {
     get_ticks_us(&button_repeat_timestamp);
@@ -260,7 +268,7 @@
 
   buttons = ctrl_data.Buttons;
 
-  if(global_enable_analog)
+  if((global_enable_analog) && !(ctrl_data.Buttons & PSP_CTRL_HOLD))
   {
     if(ctrl_data.Lx < analog_sensitivity)
       buttons |= PSP_CTRL_ANALOG_LEFT;
@@ -385,4 +393,3 @@
 
 void input_write_mem_savestate(FILE_TAG_TYPE savestate_file)                   \
 input_savestate_body(WRITE_MEM);
-
diff -ru 30_orig/input.h gpsp-kai-test/input.h
--- 30_orig/input.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/input.h	2007-08-11 16:30:21.379760800 +0900
@@ -73,7 +73,8 @@
   CURSOR_EXIT,
   CURSOR_NONE,
   CURSOR_RTRIGGER,
-  CURSOR_LTRIGGER
+  CURSOR_LTRIGGER,
+  KEY_SELECT
 } gui_action_type;
 
 void init_input();
diff -ru 30_orig/main.c gpsp-kai-test/main.c
--- 30_orig/main.c	2007-08-06 13:57:48.000000000 +0900
+++ gpsp-kai-test/main.c	2007-08-12 11:43:46.790760800 +0900
@@ -2,6 +2,8 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 NJ
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -24,7 +26,7 @@
 #include "common.h"
 
 PSP_MODULE_INFO("gpSP", PSP_MODULE_KERNEL, VERSION_MAJOR, VERSION_MINOR);
-PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_VFPU);
+PSP_MAIN_THREAD_ATTR(0);
 
 /******************************************************************************
  * 変数の定義
@@ -32,7 +34,7 @@
 
 TIMER_TYPE timer[4];                              // タイマー
 u32 game_config_frameskip_type = auto_frameskip;  // フレームスキップの種類
-u32 game_config_frameskip_value = 4;              // フレームスキップ数
+u32 game_config_frameskip_value = 9;              // フレームスキップ数
 u32 game_config_random_skip = 0;                  // ランダムスキップのon/off
 u32 game_config_clock_speed = 333;                // クロック数
 
@@ -40,7 +42,7 @@
 u64 frame_count_initial_timestamp = 0;
 u64 last_frame_interval_timestamp;
 u32 psp_fps_debug = 0;
-u32 skip_next_frame = 0;
+u32 skip_next_frame_flag = 0;
 u32 frameskip_counter = 0;
 
 u32 cpu_ticks = 0;
@@ -87,6 +89,7 @@
     };
 
 int lang_num;
+int date_format;
 
 u32 prescale_table[] = { 0, 6, 8, 10 };
 
@@ -96,35 +99,47 @@
  * マクロ等の定義
  ******************************************************************************/
 
+// エミュレーション サイクルの決定
 #define CHECK_COUNT(count_var)                                                \
   if((count_var) < execute_cycles)                                            \
     execute_cycles = count_var;                                               \
 
-#define check_timer(timer_number)                                             \
+#define CHECK_TIMER(timer_number)                                             \
   if(timer[timer_number].status == TIMER_PRESCALE)                            \
     CHECK_COUNT(timer[timer_number].count);                                   \
 
+// タイマーのアップデート
+// 実機では0~0xFFFFだが、gpSP内部では (0xFFFF~0)<<prescale(0,6,8,10)の値をとる
 #define update_timer(timer_number)                                            \
   if(timer[timer_number].status != TIMER_INACTIVE)                            \
   {                                                                           \
+    /* タイマーがアクティブだった場合 */                                      \
     if(timer[timer_number].status != TIMER_CASCADE)                           \
     {                                                                         \
+      /* タイマーがプリスケールモードだった場合 */                            \
+      /* タイマー変更 */                                                      \
       timer[timer_number].count -= execute_cycles;                            \
+      /* レジスタに書込 */                                                    \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale);  \
     }                                                                         \
                                                                               \
     if(timer[timer_number].count <= 0)                                        \
     {                                                                         \
+      /* タイマーがオーバーフローした場合 */                                  \
+      /* IRQのトリガをON */                                                   \
       if(timer[timer_number].irq == TIMER_TRIGGER_IRQ)                        \
         irq_raised |= IRQ_TIMER##timer_number;                                \
                                                                               \
       if((timer_number != 3) &&                                               \
        (timer[timer_number + 1].status == TIMER_CASCADE))                     \
       {                                                                       \
+        /* タイマー0～2 かつ 次のタイマーがカスケードモードの場合 */          \
+        /* カウンタを変更 */                                                  \
         timer[timer_number + 1].count--;                                      \
+        /* レジスタに書込 */                                                  \
         io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
-        0xFFFF   - (timer[timer_number + 1].count);                          \
+          0xFFFF - (timer[timer_number + 1].count);                           \
       }                                                                       \
                                                                               \
       if(timer_number < 2)                                                    \
@@ -136,10 +151,11 @@
           sound_timer(timer[timer_number].frequency_step, 1);                 \
       }                                                                       \
                                                                               \
+      /* タイマーのリロード */                                                \
       timer[timer_number].count +=                                            \
-       (timer[timer_number].reload << timer[timer_number].prescale);          \
+        (timer[timer_number].reload << timer[timer_number].prescale);         \
       io_registers[REG_TM##timer_number##D] =                                 \
-       0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
+        0xFFFF - (timer[timer_number].count >> timer[timer_number].prescale); \
     }                                                                         \
   }                                                                           \
 
@@ -148,26 +164,31 @@
 void init_main();
 int main(int argc, char *argv[]);
 void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str);
-void trigger_ext_event();
 u32 check_power();
 int exit_callback(int arg1, int arg2, void *common);
 int power_callback(int unknown, int powerInfo, void *common);
 int CallbackThread(SceSize args, void *argp);
 int SetupCallbacks();
-int user_main(int argc, char *argv[]);
+int user_main(SceSize args, char *argp);
+void psp_exception_handler(PspDebugRegBlock *regs);
+
+void set_cpu_clock(u32 clock)
+{
+  scePowerSetClockFrequency(clock, clock, clock / 2);
+}
 
 void init_main()
 {
   u32 i;
 
-  skip_next_frame = 0;
+  skip_next_frame_flag = 0;
 
   for(i = 0; i < 4; i++)
   {
     dma[i].start_type = DMA_INACTIVE;
     dma[i].direct_sound_channel = DMA_NO_DIRECT_SOUND;
     timer[i].status = TIMER_INACTIVE;
-    timer[i].reload = 0x10000;
+    timer[i].reload = 0xFFFF;
     timer[i].stop_cpu_ticks = 0;
   }
 
@@ -200,7 +221,7 @@
   {
     sceCtrlPeekBufferPositive(&paddata, 1);
     home_button = paddata.Buttons & PSP_CTRL_HOME;
-    sceKernelDelayThread(200);
+    sceKernelDelayThread(500);
   }
 
   sceKernelExitThread(0);
@@ -210,22 +231,26 @@
 int exit_callback(int arg1, int arg2, void *common)
 {
   quit_flag = 1;
+  sceKernelDelayThread(500);
   return 0;
 }
 
 int power_callback(int unknown, int powerInfo, void *common)
 {
-  if (powerInfo & PSP_POWER_CB_SUSPENDING) power_flag = 1;
+  if (powerInfo & PSP_POWER_CB_SUSPENDING)
+    power_flag = 1;
+  else
+    power_flag = 0;
   return 0;
 }
 
 int CallbackThread(SceSize args, void *argp)
 {
-  int cbid, power_callback_id;
+  int exit_callback_id, power_callback_id;
 
   // 終了周りのコールバック 
-  cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
-  sceKernelRegisterExitCallback(cbid);
+  exit_callback_id = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
+  sceKernelRegisterExitCallback(exit_callback_id);
 
   // 電源周りのコールバック 
   power_callback_id = sceKernelCreateCallback("Power Callback", power_callback, NULL); 
@@ -238,15 +263,15 @@
 
 int SetupCallbacks()
 {
-  int thid = 0;
+  int callback_thread_id = 0;
 
-  thid = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);
-  if (thid >= 0)
+  callback_thread_id = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);
+  if (callback_thread_id >= 0)
   {
-    sceKernelStartThread(thid, 0, 0);
+    sceKernelStartThread(callback_thread_id, 0, 0);
   }
 
-  return thid;
+  return callback_thread_id;
 }
 
 void quit()
@@ -259,25 +284,51 @@
 
   fclose(dbg_file);
 
-  scePowerSetClockFrequency(222, 222, 111);
+  set_cpu_clock(222);
   sceKernelExitThread(0);
 }
 
+void psp_exception_handler(PspDebugRegBlock *regs)
+{
+  pspDebugScreenInit();
+
+  pspDebugScreenSetBackColor(0x00FF0000);
+  pspDebugScreenSetTextColor(0xFFFFFFFF);
+  pspDebugScreenClear();
+
+  pspDebugScreenPrintf("I regret to inform you your psp has just crashed\n\n");
+  pspDebugScreenPrintf("Exception Details:\n");
+  pspDebugDumpException(regs);
+  pspDebugScreenPrintf("\nThe offending routine may be identified with:\n\n"
+    "\tpsp-addr2line -e target.elf -f -C 0x%x 0x%x 0x%x\n",
+    regs->epc, regs->badvaddr, regs->r[31]);
+}
+
+//  XBMから呼び出されるmain
+//    HOMEボタン用のスレッドと本来のmainであるuser_mainのスレッドを作成し、user_mainを呼び出す
 int main(int argc, char *argv[])
 {
   SceUID main_thread;
   SceUID home_thread;
 
+  // カレントパスの取得
   getcwd(main_path, 512);
 
-//  pspSdkLoadAdhocModules();
+  // デバッグ用スクリーンの初期化
+  pspDebugScreenInit();
+
+  pspDebugInstallErrorHandler(psp_exception_handler);
+
+  // adhoc用モジュールのロード
+  if (pspSdkLoadAdhocModules() != 0)
+    error_msg("not load inet modules\n");
 
   home_thread = sceKernelCreateThread("Home Button Thread", home_button_thread, 0x11, 0x200, 0, NULL);
-  main_thread = sceKernelCreateThread("User Mode Thread", user_main, 0x11, 256 * 1024, PSP_THREAD_ATTR_USER, NULL);
+  main_thread = sceKernelCreateThread("User Mode Thread", user_main, 0x11, 512 * 1024, PSP_THREAD_ATTR_USER, NULL);
 
   sceKernelStartThread(home_thread, 0, 0);
-
   sceKernelStartThread(main_thread, 0, 0);
+
   sceKernelWaitThreadEnd(main_thread, NULL);
 
   home_active = 0;
@@ -287,7 +338,7 @@
   return 0;
 }
 
-int user_main(int argc, char *argv[])
+int user_main(SceSize argc, char *argv)
 {
 //  u32 i;
 //  u32 vcount = 0;
@@ -307,9 +358,10 @@
   dbg_file = fopen(DBG_FILE_NAME, "awb");
 
   // Copy the directory path of the executable into main_path
-//  getcwd(main_path, 512);
   chdir(main_path);
+
   sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_LANGUAGE, &lang_num);
+  sceUtilityGetSystemParamInt(PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT,&date_format);
 
   if (load_dircfg("settings/dir.cfg") != 0)
   {
@@ -336,31 +388,9 @@
     error_msg("font init Error!!");
     quit();
   }
-/*
-  // adhoc用モジュールのロード
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_COMMON) != 0)
-  {
-    error_msg("not load modules common\n");
-  }
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_INET) != 0)
-  {
-    error_msg("not load modules inet\n");
-  }
-  if(sceUtilityLoadNetModule(PSP_NET_MODULE_ADHOC) != 0)
-  {
-    error_msg("not load modules adhoc\n");
-  }
 
-  if(pspSdkInetInit() != 0)
-  {
-    error_msg("not init inet\n");
-  }
+  // adhoc接続のテスト
 
-  if (adhocInit("test") != 0)
-  {
-    error_msg("not use wlan!! \n");
-  }
-*/
   init_gamepak_buffer();
 
   load_config_file();
@@ -377,7 +407,7 @@
 
   video_resolution_large();
 
-  u32 bios_ret = load_bios("./gba_bios.bin");
+  u32 bios_ret = load_bios("gba_bios.bin");
 
   if(bios_ret == -1) // 読込めない場合
   {
@@ -406,12 +436,15 @@
 
     init_cpu();
     init_memory();
+    reset_sound();
   }
   else
   {
     if(load_file(file_ext, load_filename, DEFAULT_ROM_DIR) == -1)
     {
-      menu(copy_screen());
+      u16 *screen_copy = copy_screen();
+      menu(screen_copy);
+      free(screen_copy);
     }
     else
     {
@@ -432,135 +465,17 @@
   }
 
   last_frame = 0;
+  set_cpu_clock(game_config_clock_speed);
 
-  // We'll never actually return from here.
-
-//  get_ticks_us(&frame_count_initial_timestamp);
+  pause_sound(0);
+  real_frame_count = 0;
+  virtual_frame_count = 0;
+  
   execute_arm_translate(execute_cycles);
 //  execute_arm(execute_cycles);
   return 0;
 }
 
-void print_memory_stats(u32 *counter, u32 *region_stats, u8 *stats_str)
-{
-  u32 other_region_counter = region_stats[0x1] + region_stats[0xE] + region_stats[0xF];
-  u32 rom_region_counter = region_stats[0x8] + region_stats[0x9] + region_stats[0xA] +
-   region_stats[0xB] + region_stats[0xC] + region_stats[0xD];
-  u32 _counter = *counter;
-
-  printf("memory access stats: %s (out of %d)\n", stats_str, (int)_counter);
-  printf("bios: %f%%\tiwram: %f%%\tewram: %f%%\tvram: %f\n",
-   region_stats[0x0] * 100.0 / _counter, region_stats[0x3] * 100.0 / _counter,
-   region_stats[0x2] * 100.0 / _counter, region_stats[0x6] * 100.0 / _counter);
-
-  printf("oam: %f%%\tpalette: %f%%\trom: %f%%\tother: %f%%\n",
-   region_stats[0x7] * 100.0 / _counter, region_stats[0x5] * 100.0 / _counter,
-   rom_region_counter * 100.0 / _counter, other_region_counter * 100.0 / _counter);
-
-  *counter = 0;
-  memset(region_stats, 0, sizeof(u32) * 16);
-}
-
-u32 event_cycles = 0;
-const u32 event_cycles_trigger = 60 * 5;
-u32 no_alpha = 0;
-
-void trigger_ext_event()
-{
-  static u32 event_number = 0;
-  static u64 benchmark_ticks[16];
-  u64 new_ticks;
-  char current_savestate_filename[512];
-
-  return;
-
-  if(event_number)
-  {
-    get_ticks_us(&new_ticks);
-    benchmark_ticks[event_number - 1] =
-     new_ticks - benchmark_ticks[event_number - 1];
-  }
-
-  game_config_frameskip_type = no_frameskip;
-  no_alpha = 0;
-  synchronize_flag = 0;
-
-  get_savestate_filename_noshot(SAVESTATE_SLOT, current_savestate_filename);
-  load_state(current_savestate_filename);
-
-  switch(event_number)
-  {
-    case 0:
-      // Full benchmark, run normally
-      break;
-
-    case 1:
-      // No alpha blending
-      no_alpha = 1;
-      break;
-
-    case 2:
-      // No video benchmark
-      // Set frameskip really high + manual
-      game_config_frameskip_type = manual_frameskip;
-      game_config_frameskip_value = 1000000;
-      break;
-
-    case 3:
-      // No CPU benchmark
-      // Put CPU in halt mode, put it in IRQ mode with interrupts off
-      reg[CPU_HALT_STATE] = CPU_HALT;
-      reg[REG_CPSR] = 0xD2;
-      break;
-
-    case 4:
-      // No CPU or video benchmark
-      reg[CPU_HALT_STATE] = CPU_HALT;
-      reg[REG_CPSR] = 0xD2;
-      game_config_frameskip_type = manual_frameskip;
-      game_config_frameskip_value = 1000000;
-      break;
-
-    case 5:
-    {
-      // Done
-      char *print_strings[] =
-      {
-        "Full test   ",
-        "No blending ",
-        "No video    ",
-        "No CPU      ",
-        "No CPU/video",
-        "CPU speed   ",
-        "Video speed ",
-        "Alpha cost  "
-      };
-      u32 i;
-
-      benchmark_ticks[6] = benchmark_ticks[0] - benchmark_ticks[2];
-      benchmark_ticks[5] = benchmark_ticks[0] - benchmark_ticks[4] -
-       benchmark_ticks[6];
-      benchmark_ticks[7] = benchmark_ticks[0] - benchmark_ticks[1];
-
-      printf("Benchmark results (%d frames): \n", (int)event_cycles_trigger);
-      for(i = 0; i < 8; i++)
-      {
-        printf("   %s: %d ms (%f ms per frame)\n",
-         print_strings[i], (int)benchmark_ticks[i] / 1000,
-         (float)(benchmark_ticks[i] / (1000.0 * event_cycles_trigger)));
-        if(i == 4)
-          printf("\n");
-      }
-      quit();
-    }
-  }
-
-  event_cycles = 0;
-
-  get_ticks_us(benchmark_ticks + event_number);
-  event_number++;
-}
-
 u32 check_power()
   {
     if (power_flag == 0) return 0;
@@ -568,7 +483,6 @@
     u16 *screen_copy = copy_screen();
     u32 ret_val = menu(screen_copy);
     free(screen_copy);
-    power_flag = 0;
     FILE_OPEN(gamepak_file_large, gamepak_filename_raw, READ);
     return ret_val;
   }
@@ -635,7 +549,8 @@
 //          u32 i;
 
           dispstat |= 0x01;
-          if(dispstat & 0x8) {
+          if(dispstat & 0x8)
+          {
             irq_raised |= IRQ_VBLANK;
           }
 
@@ -662,7 +577,7 @@
         if(vcount == 228) {
           // Transition from vblank to next screen
           dispstat &= ~0x01;
-//          frame_ticks++;
+          frame_ticks++;
 
           if (update_input())
             continue;
@@ -689,7 +604,8 @@
         if(vcount == (dispstat >> 8)) {
           // vcount trigger
           dispstat |= 0x04;
-          if(dispstat & 0x20) {
+          if(dispstat & 0x20)
+          {
             irq_raised |= IRQ_VCOUNT;
           }
         }
@@ -708,10 +624,10 @@
       
     execute_cycles = video_count;
 
-    check_timer(0);
-    check_timer(1);
-    check_timer(2);
-    check_timer(3);
+    CHECK_TIMER(0);
+    CHECK_TIMER(1);
+    CHECK_TIMER(2);
+    CHECK_TIMER(3);
 
   } while(reg[CPU_HALT_STATE] != CPU_ACTIVE);
 
@@ -721,8 +637,9 @@
 u64 last_screen_timestamp = 0;
 u32 frame_speed = 15000;
 
-u32 real_frame_count = 0;
+volatile u32 real_frame_count = 0;
 u32 virtual_frame_count = 0;
+volatile u32 vblank_count = 0;
 u32 num_skipped_frames = 0;
 u32 interval_skipped_frames;
 u32 frames;
@@ -733,129 +650,144 @@
 void vblank_interrupt_handler(u32 sub, u32 *parg)
 {
   real_frame_count++;
+  vblank_count++;
 }
 
+// TODO:最適化
 void synchronize()
 {
 //  char char_buffer[64];
-  u64 new_ticks;
-  u64 time_delta;
-//  s32 used_frameskip = game_config_frameskip_value;
   static u32 fps = 60;
-  static u32 frames_drawn = 60;
+  static u32 frames_drawn = 0;
+  static u32 frames_drawn_count = 0;
 
+  // FPS等の表示
   if(psp_fps_debug)
   {
     char print_buffer[256];
 //    int i;
-    sprintf(print_buffer, "%d (%d)", (int)fps, (int)frames_drawn);
+    sprintf(print_buffer, "%02d (%02d) %02d", (int)fps, (int)frames_drawn, (int)left_buffer);
     print_string(print_buffer, 0xFFFF, 0x000, 0, 0);
   }
 
-//  if(!synchronize_flag)
-//  {
-//    print_string("--FF--", 0xFFFF, 0x000, 0, 0);
-//    used_frameskip = 4;
-//    virtual_frame_count = real_frame_count - 1;
-//  }
-
-  get_ticks_us(&new_ticks);
-  time_delta = new_ticks - last_screen_timestamp;
-  last_screen_timestamp = new_ticks;
-  ticks_needed_total += time_delta;
-
-  skip_next_frame = 0;
-  virtual_frame_count++;
-
-//  real_frame_count = ((new_ticks -
-//    frame_count_initial_timestamp) * 3) / 50000;
-
-  if(real_frame_count >= virtual_frame_count)
-  {
-    if((real_frame_count > virtual_frame_count) &&
-     (game_config_frameskip_type == auto_frameskip) &&
-     (num_skipped_frames < game_config_frameskip_value))
+  // フレームスキップ フラグの初期化
+  skip_next_frame_flag = 0;
+  // 内部フレーム値の増加
+  frames++;
+
+  // オートフレームスキップ時
+  if(game_config_frameskip_type == auto_frameskip)
+  {
+    virtual_frame_count++;
+
+    // 内部フレーム数に遅れが出ている場合
+    if(real_frame_count > virtual_frame_count)
     {
-      skip_next_frame = 1;
-      num_skipped_frames++;
+      if(num_skipped_frames < game_config_frameskip_value)  // スキップしたフレームが設定より小さい
+      {
+        // 次のフレームはスキップ
+        skip_next_frame_flag = 1;
+        // スキップしたフレーム数を増加
+        num_skipped_frames++;
+      }
+      else
+      {
+        // 設定の上限に達した場合
+//        real_frame_count = virtual_frame_count;
+        // スキップしたフレーム数は0に初期化
+        num_skipped_frames = 0;
+        frames_drawn_count++;
+      }
     }
-    else
+
+    // 内部フレーム数が同じ場合
+    if(real_frame_count == virtual_frame_count)
     {
-      virtual_frame_count = real_frame_count;
+      // スキップしたフレーム数は0に初期化
       num_skipped_frames = 0;
+      frames_drawn_count++;
     }
-    // Here so that the home button return will eventually work.
-    // If it's not running fullspeed anyway this won't really hurt
-    // it much more.
 
-///    delay_us(1);
-  }
-  else
-  {
-    if((synchronize_flag) /*&&
-     ((time_delta < frame_speed) && synchronize_flag)*/)
+      // 内部フレーム数が実機を上回る場合
+    if(real_frame_count < virtual_frame_count)
     {
-//      delay_us(frame_speed - time_delta);
+      num_skipped_frames = 0;
+      frames_drawn_count++;
+    }
+
+    // 内部フレーム数が実機を上回る場合
+    if((real_frame_count < virtual_frame_count) && (synchronize_flag) && (skip_next_frame_flag == 0))
+    {
+      // VBANK待ち
+      synchronize_sound();
       sceDisplayWaitVblankStart();
       real_frame_count = 0;
       virtual_frame_count = 0;
     }
   }
 
-  frames++;
-
-  if(frames == frame_interval)
-  {
-    u32 new_fps;
-    u32 new_frames_drawn;
-
-    time_delta = new_ticks - last_frame_interval_timestamp;
-    new_fps = 60000000 / time_delta;
-    new_frames_drawn = frame_interval - interval_skipped_frames;
-
-    // Left open for rolling averages
-    fps = new_fps;
-    frames_drawn = new_frames_drawn;
-
-    last_frame_interval_timestamp = new_ticks;
-    interval_skipped_frames = 0;
-    ticks_needed_total = 0;
-    frames = 0;
-  }
-
+  // マニュアルフレームスキップ時
   if(game_config_frameskip_type == manual_frameskip)
   {
-    frameskip_counter = (frameskip_counter + 1) %
-     (game_config_frameskip_value + 1);
+    virtual_frame_count++;
+    // フレームスキップ数増加
+    num_skipped_frames = (num_skipped_frames + 1) % (game_config_frameskip_value + 1);
     if(game_config_random_skip)
     {
-      if(frameskip_counter != (rand() % (game_config_frameskip_value + 1)))
-        skip_next_frame = 1;
+      if(num_skipped_frames != (rand() % (game_config_frameskip_value + 1)))
+        skip_next_frame_flag = 1;
+      else
+        frames_drawn_count++;
     }
     else
     {
-      if(frameskip_counter)
-        skip_next_frame = 1;
+      // フレームスキップ数=0の時だけ画面更新
+      if(num_skipped_frames != 0)
+        skip_next_frame_flag = 1;
+      else
+        frames_drawn_count++;
     }
+
+    // 内部フレーム数が実機を上回る場合
+    if((real_frame_count < virtual_frame_count) && (synchronize_flag) && (skip_next_frame_flag == 0))
+    {
+      // VBANK待ち
+      synchronize_sound();
+      sceDisplayWaitVblankStart();
+    }
+    real_frame_count = 0;
+    virtual_frame_count = 0;
+  }
+
+  // フレームスキップなし時
+  if(game_config_frameskip_type == no_frameskip)
+  {
+    frames_drawn_count++;
+    virtual_frame_count++;
+    if((real_frame_count < virtual_frame_count) && (synchronize_flag))
+    {
+      // 内部フレーム数が実機を上回る場合
+      // VBANK待ち
+      synchronize_sound();
+      sceDisplayWaitVblankStart();
+    }
+    real_frame_count = 0;
+    virtual_frame_count = 0;
   }
 
-  interval_skipped_frames += skip_next_frame;
+  // FPSのカウント
+  // 1/60秒のVBLANK割込みがあるので、タイマは使用しないようにした
+  if(frames == 60)
+  {
+    frames = 0;
+    fps = 3600 / vblank_count;
+    vblank_count = 0;
+    frames_drawn = frames_drawn_count;
+    frames_drawn_count = 0;
+  }
 
   if(!synchronize_flag)
     print_string("--FF--", 0xFFFF, 0x000, 0, 0);
-/*
-  sprintf(char_buffer, "%08d %08d %d %d %d\n",
-   real_frame_count, virtual_frame_count, num_skipped_frames,
-   real_frame_count - virtual_frame_count, skip_next_frame);
-  print_string(char_buffer, 0xFFFF, 0x0000, 0, 10);
-*/
-
-/*
-    sprintf(char_buffer, "%02d %02d %06d %07d", frameskip, (u32)ms_needed,
-     ram_translation_ptr - ram_translation_cache, rom_translation_ptr -
-     rom_translation_cache);
-    print_string(char_buffer, 0xFFFF, 0x0000, 0, 0);
-*/
 }
 
 void reset_gba()
@@ -882,9 +814,7 @@
 {
   u64 ticks;
   sceRtcGetCurrentTick(&ticks);
-
-//  *tick_return = (ticks * 1000000) / sceRtcGetTickResolution();
-    *tick_return = ticks;
+  *tick_return = ticks;
 }
 
 void change_ext(char *src, char *buffer, char *extension)
@@ -921,7 +851,7 @@
     while(gui_action == CURSOR_NONE)
     {
       gui_action = get_gui_input();
-      delay_us(15000);
+      delay_us(15000); /* 0.0015s */
     }
 }
 
diff -ru 30_orig/main.h gpsp-kai-test/main.h
--- 30_orig/main.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/main.h	2007-08-12 04:46:31.782760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -69,7 +70,7 @@
 extern u32 game_config_random_skip;
 extern u32 global_cycles_per_instruction;
 extern u32 synchronize_flag;
-extern u32 skip_next_frame;
+extern u32 skip_next_frame_flag;
 extern TIMER_TYPE timer[4];
 extern u32 prescale_table[];
 extern u32 cycle_memory_access;
@@ -82,17 +83,19 @@
 extern u32 cycle_dma32_words;
 extern u32 flush_ram_count;
 extern u64 base_timestamp;
-extern char main_path[512];
+extern char main_path[MAX_PATH];
 extern u32 update_backup_flag;
 extern u32 game_config_clock_speed;
 extern u32 hold_state;
 extern u32 quit_flag;
-extern u32 real_frame_count;
+extern volatile u32 real_frame_count;
 extern u32 virtual_frame_count;
 extern u32 max_frameskip;
 extern u32 num_skipped_frames;
 extern u64 frame_count_initial_timestamp;
+extern int date_format;
 
+void set_cpu_clock(u32 clock);
 u32 update_gba();
 void reset_gba();
 void synchronize();
@@ -108,44 +111,73 @@
 void change_ext(char *src, char *buffer, char *extension);
 u32 file_length(char *filename, s32 dummy);
 
-#define count_timer(timer_number)                                             \
-  timer[timer_number].reload = 0x10000 - value;                               \
+// TODO:タイマーカウンタ周りの処理は再検討
+
+// タイマーリロード時のカウンタの設定(この時点ではタイマーにセットされない)
+// タイマースタート時にカウンタに設定される
+// ただし、32bitアクセス時には即座にタイマーにセットされる
+// 実機では0~0xFFFFだが、gpSP内部では (0xFFFF~0)<<prescale(0,6,8,10)の値をとる
+// 各カウンターにリロードする際にprescale分シフトされる
+// TODO:32bitアクセスと8/16bitアクセスで処理を分ける必要がある
+// 8/16ビットアクセス時には呼び出す必要がない？
+#define COUNT_TIMER(timer_number)                                             \
+  timer[timer_number].reload = 0xFFFF - value;                                \
   if(timer_number < 2)                                                        \
   {                                                                           \
     u32 timer_reload =                                                        \
      timer[timer_number].reload << timer[timer_number].prescale;              \
-    sound_update_frequency_step(timer_number);                                \
+    SOUND_UPDATE_FREQUENCY_STEP(timer_number);                                \
   }                                                                           \
 
-#define adjust_sound_buffer(timer_number, channel)                            \
+// タイマーの値の調整？
+// TODO:サウンドのズレはこのあたりの処理が問題?
+#define ADJUST_SOUND_BUFFER(timer_number, channel)                            \
   if(timer[timer_number].direct_sound_channels & (0x01 << channel))           \
   {                                                                           \
     direct_sound_channel[channel].buffer_index =                              \
-     (direct_sound_channel[channel].buffer_index + buffer_adjust) %           \
-     BUFFER_SIZE;                                                             \
+     (direct_sound_channel[channel].buffer_index + buffer_adjust) % BUFFER_SIZE; \
+                                                                              \
   }                                                                           \
 
-#define trigger_timer(timer_number)                                           \
+// タイマーのアクセスとカウント開始処理
+#define TRIGGER_TIMER(timer_number)                                           \
   if(value & 0x80)                                                            \
   {                                                                           \
+    /* スタートビットが”1”だった場合 */                                       \
     if(timer[timer_number].status == TIMER_INACTIVE)                          \
     {                                                                         \
-      u32 prescale = prescale_table[value & 0x03];                            \
+      /* タイマーが停止していた場合 */                                        \
+      /* 各種設定をして、タイマー作動 */                                      \
+                                                                              \
+      /* リロード値を読み込む */                                              \
       u32 timer_reload = timer[timer_number].reload;                          \
                                                                               \
-      if((value >> 2) & 0x01)                                                 \
+      /* カスケードモードか判別(タイマー0以外)*/                              \
+      if(((value >> 2) & 0x01)&&(timer_number != 0))                          \
+      {                                                                       \
+        /* カスケードモード */                                                \
         timer[timer_number].status = TIMER_CASCADE;                           \
+        u32 prescale = 0;                                                     \
+        /* プリスケールの設定 */                                              \
+        timer[timer_number].prescale = 0;                                     \
+      }                                                                       \
       else                                                                    \
+      {                                                                       \
+        /* プリスケールモード */                                              \
         timer[timer_number].status = TIMER_PRESCALE;                          \
+        u32 prescale = prescale_table[value & 0x03];                          \
+        timer_reload <<= prescale;                                            \
+        /* プリスケールの設定 */                                              \
+        timer[timer_number].prescale = prescale;                              \
+      }                                                                       \
                                                                               \
-      timer[timer_number].prescale = prescale;                                \
+      /* IRQの設定 */                                                         \
       timer[timer_number].irq = (value >> 6) & 0x01;                          \
                                                                               \
-      ADDRESS16(io_registers, 0x100 + (timer_number * 4)) =                   \
-       0x10000 - timer_reload;                                                \
-                                                                              \
-      timer_reload <<= prescale;                                              \
+      /* カウンタを設定 */                                                    \
       timer[timer_number].count = timer_reload;                               \
+      ADDRESS16(io_registers, 0x100 + (timer_number * 4)) =                   \
+       0xFFFF - timer_reload;                                                 \
                                                                               \
       if(timer_reload < execute_cycles)                                       \
         execute_cycles = timer_reload;                                        \
@@ -154,11 +186,11 @@
       {                                                                       \
         u32 buffer_adjust =                                                   \
          (u32)(((float)(cpu_ticks - timer[timer_number].stop_cpu_ticks) *     \
-         SOUND_FREQUENCY) / 16777216.0) * 2;                                  \
+         SOUND_FREQUENCY) / SYS_CLOCK) * 2;                                   \
                                                                               \
-        sound_update_frequency_step(timer_number);                            \
-        adjust_sound_buffer(timer_number, 0);                                 \
-        adjust_sound_buffer(timer_number, 1);                                 \
+        SOUND_UPDATE_FREQUENCY_STEP(timer_number);                            \
+        ADJUST_SOUND_BUFFER(timer_number, 0);                                 \
+        ADJUST_SOUND_BUFFER(timer_number, 1);                                 \
       }                                                                       \
     }                                                                         \
   }                                                                           \
@@ -174,4 +206,3 @@
 
 #endif
 
-
diff -ru 30_orig/memory.c gpsp-kai-test/memory.c
--- 30_orig/memory.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/memory.c	2007-08-12 01:00:46.194760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -68,38 +69,33 @@
 
 // This table is configured for sequential access on system defaults
 
-u32 waitstate_cycles_sequential[16][3] =
+u8 waitstate_cycles_seq[2][16] =
 {
-  { 1, 1, 1 }, // BIOS
-  { 1, 1, 1 }, // Invalid
-  { 3, 3, 6 }, // EWRAM (default settings)
-  { 1, 1, 1 }, // IWRAM
-  { 1, 1, 1 }, // IO Registers
-  { 1, 1, 2 }, // Palette RAM
-  { 1, 1, 2 }, // VRAM
-  { 1, 1, 2 }, // OAM
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 3, 3, 6 }, // Gamepak (wait 0)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 5, 5, 9 }, // Gamepak (wait 1)
-  { 9, 9, 17 }, // Gamepak (wait 2)
-  { 9, 9, 17 }, // Gamepak (wait 2)
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
+};
+
+u8 waitstate_cycles_non_seq[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 7, 7, 9, 9,13,13, 1, 1 }  /* 32bit */
 };
 
 // Different settings for gamepak ws0-2 sequential (2nd) access
 
-u32 gamepak_waitstate_sequential[2][3][3] =
+u8 gamepak_waitstate_seq[2][2][3] =
 {
-  {
-    { 3, 3, 6 },
-    { 5, 5, 9 },
-    { 9, 9, 17 }
-  },
-  {
-    { 2, 2, 3 },
-    { 2, 2, 3 },
-    { 2, 2, 3 }
-  }
+  {{ 3, 5, 9 }, { 5, 9,17 }},
+  {{ 2, 2, 2 }, { 3, 3, 3 }}
+};
+
+u8 cpu_waitstate_cycles_seq[2][16] =
+{
+ /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+  { 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 5, 5, 9, 9, 5, 1 }, /* 8,16bit */
+  { 1, 1, 6, 1, 1, 2, 2, 1, 5, 5, 9, 9,17,17, 1, 1 }  /* 32bit */
 };
 
 u16 palette_ram[512];
@@ -138,8 +134,8 @@
 char gamepak_title[13];
 char gamepak_code[5];
 char gamepak_maker[3];
-char gamepak_filename[512];
-char gamepak_filename_raw[512];
+char gamepak_filename[MAX_FILE];
+char gamepak_filename_raw[MAX_PATH];
 
 // Enough to map the gamepak RAM space.
 gamepak_swap_entry_type *gamepak_memory_map;
@@ -465,9 +461,16 @@
     case 0x00:                                                                \
       /* BIOS */                                                              \
       if(reg[REG_PC] >= 0x4000)                                               \
-        value = ADDRESS##type(&bios_read_protect, address & 0x03);            \
+      {                                                                       \
+        if(address < 0x4000)                                                  \
+          value = ADDRESS##type(&bios_read_protect, address & 0x03);          \
+        else                                                                  \
+          read_open##type();                                                  \
+      }                                                                       \
       else                                                                    \
+      {                                                                       \
         value = ADDRESS##type(bios_rom, address & 0x3FFF);                    \
+      }                                                                       \
       break;                                                                  \
                                                                               \
     case 0x02:                                                                \
@@ -482,7 +485,10 @@
                                                                               \
     case 0x04:                                                                \
       /* I/O registers */                                                     \
-      value = ADDRESS##type(io_registers, address & 0xFFF);                   \
+      if(address < 0x04000400)                                                  /* IOは0x803まで存在 */ \
+        value = ADDRESS##type(io_registers, address & 0x3FF);                   /* 0x800は0x800ごとにループしている:TODO */ \
+      else                                                                    \
+        read_open##type();                                                    \
       break;                                                                  \
                                                                               \
     case 0x05:                                                                \
@@ -492,11 +498,10 @@
                                                                               \
     case 0x06:                                                                \
       /* VRAM */                                                              \
-      address &= 0x1FFFF;                                                     \
-      if(address >= 0x18000)                                                  \
-        address -= 0x8000;                                                    \
-                                                                              \
-      value = ADDRESS##type(vram, address);                                   \
+      if(address & 0x10000)                                                   \
+        value = ADDRESS##type(vram, address & 0x17FFF);                       \
+      else                                                                    \
+        value = ADDRESS##type(vram, address & 0x1FFFF);                       \
       break;                                                                  \
                                                                               \
     case 0x07:                                                                \
@@ -611,6 +616,65 @@
     ADDRESS16(io_registers, (dma_number * 12) + 0xBA) = value;                \
   }                                                                           \
 
+// configure game pak access timings
+#define waitstate_control()                                                   \
+{                                                                             \
+  u8 i;                                                                       \
+  u8 waitstate_table[4] = { 5, 4, 3, 9 };                                     \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x0e] = waitstate_cycles_seq[0][0x0e]           \
+   = waitstate_table[value & 0x03];                                           \
+                                                                              \
+  for(i = 0; i < 2; i++)                                                      \
+  {                                                                           \
+    waitstate_cycles_seq[i][0x08] = waitstate_cycles_seq[i][0x09]             \
+     = gamepak_waitstate_seq[(value >> 4) & 0x01][i][0];                      \
+    waitstate_cycles_seq[i][0x0A] = waitstate_cycles_seq[i][0x0B]             \
+     = gamepak_waitstate_seq[(value >> 7) & 0x01][i][1];                      \
+    waitstate_cycles_seq[i][0x0C] = waitstate_cycles_seq[i][0x0D]             \
+     = gamepak_waitstate_seq[(value >> 10) & 0x01][i][2];                     \
+  }                                                                           \
+                                                                              \
+  waitstate_cycles_non_seq[0][0x08] = waitstate_cycles_non_seq[0][0x09]       \
+   = waitstate_table[(value >> 2) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0A] = waitstate_cycles_non_seq[0][0x0B]       \
+   = waitstate_table[(value >> 5) & 0x03];                                    \
+  waitstate_cycles_non_seq[0][0x0C] = waitstate_cycles_non_seq[0][0x0D]       \
+   = waitstate_table[(value >> 8) & 0x03];                                    \
+                                                                              \
+  /* 32bit access ( split into two 16bit accsess ) */                         \
+  waitstate_cycles_non_seq[1][0x08] = waitstate_cycles_non_seq[1][0x09]       \
+   = (waitstate_cycles_non_seq[0][0x08] + waitstate_cycles_seq[0][0x08] - 1); \
+  waitstate_cycles_non_seq[1][0x0A] = waitstate_cycles_non_seq[1][0x0B]       \
+   = (waitstate_cycles_non_seq[0][0x0A] + waitstate_cycles_seq[0][0x0A] - 1); \
+  waitstate_cycles_non_seq[1][0x0C] = waitstate_cycles_non_seq[1][0x0D]       \
+  =  (waitstate_cycles_non_seq[0][0x0C] + waitstate_cycles_seq[0][0x0C] - 1); \
+                                                                              \
+  /* gamepak prefetch */                                                      \
+  if(value & 0x4000)                                                          \
+  {                                                                           \
+    for(i = 0x08; i <= 0x0D; i++)                                             \
+    {                                                                         \
+      cpu_waitstate_cycles_seq[0][i] = 1;                                     \
+      cpu_waitstate_cycles_seq[1][i] = 2;                                     \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    for(i = 0; i < 2; i++)                                                    \
+    {                                                                         \
+      cpu_waitstate_cycles_seq[i][0x08] = cpu_waitstate_cycles_seq[i][0x09]   \
+       = waitstate_cycles_seq[i][0x08];                                       \
+      cpu_waitstate_cycles_seq[i][0x0A] = cpu_waitstate_cycles_seq[i][0x0B]   \
+       = waitstate_cycles_seq[i][0x0A];                                       \
+      cpu_waitstate_cycles_seq[i][0x0C] = cpu_waitstate_cycles_seq[i][0x0D]   \
+       = waitstate_cycles_seq[i][0x0C];                                       \
+    }                                                                         \
+  }                                                                           \
+                                                                              \
+  ADDRESS16(io_registers, 0x204) =                                            \
+   (ADDRESS16(io_registers, 0x204) & 0x8000) | (value & 0x7FFF);              \
+}                                                                             \
 
 #define access_register8_high(address)                                        \
   value = (value << 8) | (ADDRESS8(io_registers, address))                    \
@@ -769,138 +833,138 @@
     // Sound 1 control sweep
     case 0x60:
       access_register8_low(0x60);
-      gbc_sound_tone_control_sweep();
+      GBC_SOUND_TONE_CONTROL_SWEEP();
       break;
 
     case 0x61:
-      access_register8_low(0x60);
-      gbc_sound_tone_control_sweep();
+      access_register8_high(0x60);
+      GBC_SOUND_TONE_CONTROL_SWEEP();
       break;
 
     // Sound 1 control duty/length/envelope
     case 0x62:
       access_register8_low(0x62);
-      gbc_sound_tone_control_low(0, 0x62);
+      GBC_SOUND_TONE_CONTROL_LOW(0, 0x62);
       break;
 
     case 0x63:
       access_register8_high(0x62);
-      gbc_sound_tone_control_low(0, 0x62);
+      GBC_SOUND_TONE_CONTROL_LOW(0, 0x62);
       break;
 
     // Sound 1 control frequency
     case 0x64:
       access_register8_low(0x64);
-      gbc_sound_tone_control_high(0, 0x64);
+      GBC_SOUND_TONE_CONTROL_HIGH(0, 0x64);
       break;
 
     case 0x65:
       access_register8_high(0x64);
-      gbc_sound_tone_control_high(0, 0x64);
+      GBC_SOUND_TONE_CONTROL_HIGH(0, 0x64);
       break;
 
     // Sound 2 control duty/length/envelope
     case 0x68:
       access_register8_low(0x68);
-      gbc_sound_tone_control_low(1, 0x68);
+      GBC_SOUND_TONE_CONTROL_LOW(1, 0x68);
       break;
 
     case 0x69:
       access_register8_high(0x68);
-      gbc_sound_tone_control_low(1, 0x68);
+      GBC_SOUND_TONE_CONTROL_LOW(1, 0x68);
       break;
 
     // Sound 2 control frequency
     case 0x6C:
       access_register8_low(0x6C);
-      gbc_sound_tone_control_high(1, 0x6C);
+      GBC_SOUND_TONE_CONTROL_HIGH(1, 0x6C);
       break;
 
     case 0x6D:
       access_register8_high(0x6C);
-      gbc_sound_tone_control_high(1, 0x6C);
+      GBC_SOUND_TONE_CONTROL_HIGH(1, 0x6C);
       break;
 
     // Sound 3 control wave
     case 0x70:
       access_register8_low(0x70);
-      gbc_sound_wave_control();
+      GBC_SOUND_WAVE_CONTROL();
       break;
 
     case 0x71:
       access_register8_high(0x70);
-      gbc_sound_wave_control();
+      GBC_SOUND_WAVE_CONTROL();
       break;
 
     // Sound 3 control length/volume
     case 0x72:
       access_register8_low(0x72);
-      gbc_sound_tone_control_low_wave();
+      GBC_SOUND_TONE_CONTROL_LOW_WAVE();
       break;
 
     case 0x73:
       access_register8_high(0x72);
-      gbc_sound_tone_control_low_wave();
+      GBC_SOUND_TONE_CONTROL_LOW_WAVE();
       break;
 
     // Sound 3 control frequency
     case 0x74:
       access_register8_low(0x74);
-      gbc_sound_tone_control_high_wave();
+      GBC_SOUND_TONE_CONTROL_HIGH_WAVE();
       break;
 
     case 0x75:
       access_register8_high(0x74);
-      gbc_sound_tone_control_high_wave();
+      GBC_SOUND_TONE_CONTROL_HIGH_WAVE();
       break;
 
     // Sound 4 control length/envelope
     case 0x78:
       access_register8_low(0x78);
-      gbc_sound_tone_control_low(3, 0x78);
+      GBC_SOUND_TONE_CONTROL_LOW(3, 0x78);
       break;
 
     case 0x79:
       access_register8_high(0x78);
-      gbc_sound_tone_control_low(3, 0x78);
+      GBC_SOUND_TONE_CONTROL_LOW(3, 0x78);
       break;
 
     // Sound 4 control frequency
     case 0x7C:
       access_register8_low(0x7C);
-      gbc_sound_noise_control();
+      GBC_SOUND_NOISE_CONTROL();
       break;
 
     case 0x7D:
       access_register8_high(0x7C);
-      gbc_sound_noise_control();
+      GBC_SOUND_NOISE_CONTROL();
       break;
 
     // Sound control L
     case 0x80:
       access_register8_low(0x80);
-      gbc_trigger_sound();
+      GBC_TRIGGER_SOUND();
       break;
 
     case 0x81:
       access_register8_high(0x80);
-      gbc_trigger_sound();
+      GBC_TRIGGER_SOUND();
       break;
 
     // Sound control H
     case 0x82:
       access_register8_low(0x82);
-      trigger_sound();
+      TRIGGER_SOUND();
       break;
 
     case 0x83:
       access_register8_high(0x82);
-      trigger_sound();
+      TRIGGER_SOUND();
       break;
 
     // Sound control X
     case 0x84:
-      sound_on();
+      SOUND_ON();
       break;
 
     // Sound wave RAM
@@ -910,96 +974,123 @@
       break;
 
     // Sound FIFO A
-    case 0xA0:
-      sound_timer_queue8(0, value);
+    case 0xA0 ... 0xA3:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
-    case 0xA4:
-      sound_timer_queue8(1, value);
+    case 0xA4 ... 0xA7:
+      ADDRESS8(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control (trigger byte)
     case 0xBB:
-      access_register8_low(0xBA);
+      access_register8_high(0xBA);
       trigger_dma(0);
       break;
 
     case 0xC7:
-      access_register8_low(0xC6);
+      access_register8_high(0xC6);
       trigger_dma(1);
       break;
 
     case 0xD3:
-      access_register8_low(0xD2);
+      access_register8_high(0xD2);
       trigger_dma(2);
       break;
 
     case 0xDF:
-      access_register8_low(0xDE);
+      access_register8_high(0xDE);
       trigger_dma(3);
       break;
 
     // Timer counts
     case 0x100:
       access_register8_low(0x100);
-      count_timer(0);
+      COUNT_TIMER(0);
       break;
 
     case 0x101:
       access_register8_high(0x100);
-      count_timer(0);
+      COUNT_TIMER(0);
       break;
 
     case 0x104:
       access_register8_low(0x104);
-      count_timer(1);
+      COUNT_TIMER(1);
       break;
 
     case 0x105:
       access_register8_high(0x104);
-      count_timer(1);
+      COUNT_TIMER(1);
       break;
 
     case 0x108:
       access_register8_low(0x108);
-      count_timer(2);
+      COUNT_TIMER(2);
       break;
 
     case 0x109:
       access_register8_high(0x108);
-      count_timer(2);
+      COUNT_TIMER(2);
       break;
 
     case 0x10C:
       access_register8_low(0x10C);
-      count_timer(3);
+      COUNT_TIMER(3);
       break;
 
     case 0x10D:
       access_register8_high(0x10C);
-      count_timer(3);
+      COUNT_TIMER(3);
       break;
 
     // Timer control (trigger byte)
-    case 0x103:
+    case 0x102:
       access_register8_low(0x102);
-      trigger_timer(0);
+      TRIGGER_TIMER(0);
       break;
 
-    case 0x107:
+    case 0x103:
+      access_register8_high(0x102);
+      TRIGGER_TIMER(0);
+      break;
+
+    case 0x106:
       access_register8_low(0x106);
-      trigger_timer(1);
+      TRIGGER_TIMER(1);
       break;
 
-    case 0x10B:
+    case 0x107:
+      access_register8_high(0x106);
+      TRIGGER_TIMER(1);
+      break;
+
+    case 0x10A:
       access_register8_low(0x10A);
-      trigger_timer(2);
+      TRIGGER_TIMER(2);
       break;
 
-    case 0x10F:
+    case 0x10B:
+      access_register8_high(0x10A);
+      TRIGGER_TIMER(2);
+      break;
+
+    case 0x10E:
       access_register8_low(0x10E);
-      trigger_timer(3);
+      TRIGGER_TIMER(3);
+
+    case 0x10F:
+      access_register8_high(0x10E);
+      TRIGGER_TIMER(3);
+      break;
+
+    // P1
+    case 0x130:
+    case 0x131:
+      /* Read only */
       break;
 
     // RCNT
@@ -1016,13 +1107,23 @@
       ADDRESS8(io_registers, 0x203) &= ~value;
       break;
 
+    // WAITCNT
+    case 0x204:
+      access_register8_low(0x204);
+      waitstate_control();
+      break;
+
+    case 0x205:
+      access_register8_high(0x204);
+      waitstate_control();
+      break;
+
     // Halt
     case 0x301:
-      if((value & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x80)
         reg[CPU_HALT_STATE] = CPU_STOP;
-
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
       return CPU_ALERT_HALT;
       break;
 
@@ -1113,67 +1214,67 @@
 
     // Sound 1 control sweep
     case 0x60:
-      gbc_sound_tone_control_sweep();
+      GBC_SOUND_TONE_CONTROL_SWEEP();
       break;
 
     // Sound 1 control duty/length/envelope
     case 0x62:
-      gbc_sound_tone_control_low(0, 0x62);
+      GBC_SOUND_TONE_CONTROL_LOW(0, 0x62);
       break;
 
     // Sound 1 control frequency
     case 0x64:
-      gbc_sound_tone_control_high(0, 0x64);
+      GBC_SOUND_TONE_CONTROL_HIGH(0, 0x64);
       break;
 
     // Sound 2 control duty/length/envelope
     case 0x68:
-      gbc_sound_tone_control_low(1, 0x68);
+      GBC_SOUND_TONE_CONTROL_LOW(1, 0x68);
       break;
 
     // Sound 2 control frequency
     case 0x6C:
-      gbc_sound_tone_control_high(1, 0x6C);
+      GBC_SOUND_TONE_CONTROL_HIGH(1, 0x6C);
       break;
 
     // Sound 3 control wave
     case 0x70:
-      gbc_sound_wave_control();
+      GBC_SOUND_WAVE_CONTROL();
       break;
 
     // Sound 3 control length/volume
     case 0x72:
-      gbc_sound_tone_control_low_wave();
+      GBC_SOUND_TONE_CONTROL_LOW_WAVE();
       break;
 
     // Sound 3 control frequency
     case 0x74:
-      gbc_sound_tone_control_high_wave();
+      GBC_SOUND_TONE_CONTROL_HIGH_WAVE();
       break;
 
     // Sound 4 control length/envelope
     case 0x78:
-      gbc_sound_tone_control_low(3, 0x78);
+      GBC_SOUND_TONE_CONTROL_LOW(3, 0x78);
       break;
 
     // Sound 4 control frequency
     case 0x7C:
-      gbc_sound_noise_control();
+      GBC_SOUND_NOISE_CONTROL();
       break;
 
     // Sound control L
     case 0x80:
-      gbc_trigger_sound();
+      GBC_TRIGGER_SOUND();
       break;
 
     // Sound control H
     case 0x82:
-      trigger_sound();
+      TRIGGER_SOUND();
       break;
 
     // Sound control X
     case 0x84:
-      sound_on();
+      SOUND_ON();
       break;
 
     // Sound wave RAM
@@ -1184,12 +1285,16 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue16(0, value);
+    case 0xA2:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue16(1, value);
+    case 0xA6:
+      ADDRESS16(io_registers, address) = value;
+      sound_timer_queue32(1);
       break;
 
     // DMA control
@@ -1211,36 +1316,40 @@
 
     // Timer counts
     case 0x100:
-      count_timer(0);
+//      ADDRESS16(io_registers, address) = value;
+      COUNT_TIMER(0);
       break;
 
     case 0x104:
-      count_timer(1);
+//      ADDRESS16(io_registers, address) = value;
+      COUNT_TIMER(1);
       break;
 
     case 0x108:
-      count_timer(2);
+//      ADDRESS16(io_registers, address) = value;
+      COUNT_TIMER(2);
       break;
 
     case 0x10C:
-      count_timer(3);
+//      ADDRESS16(io_registers, address) = value;
+      COUNT_TIMER(3);
       break;
 
     // Timer control
     case 0x102:
-      trigger_timer(0);
+      TRIGGER_TIMER(0);
       break;
 
     case 0x106:
-      trigger_timer(1);
+      TRIGGER_TIMER(1);
       break;
 
     case 0x10A:
-      trigger_timer(2);
+      TRIGGER_TIMER(2);
       break;
 
     case 0x10E:
-      trigger_timer(3);
+      TRIGGER_TIMER(3);
       break;
 
     // P1
@@ -1259,14 +1368,15 @@
 
     // WAITCNT
     case 0x204:
+      waitstate_control();
       break;
 
     // Halt
     case 0x300:
-      if(((value >> 8) & 0x01) == 0)
-        reg[CPU_HALT_STATE] = CPU_HALT;
-      else
+      if(value & 0x8000)
         reg[CPU_HALT_STATE] = CPU_STOP;
+      else
+        reg[CPU_HALT_STATE] = CPU_HALT;
 
       return CPU_ALERT_HALT;
 
@@ -1309,12 +1419,14 @@
 
     // Sound FIFO A
     case 0xA0:
-      sound_timer_queue32(0, value);
+      ADDRESS32(io_registers, 0xA0) = value;
+      sound_timer_queue32(0);
       break;
 
     // Sound FIFO B
     case 0xA4:
-      sound_timer_queue32(1, value);
+      ADDRESS32(io_registers, 0xA4) = value;
+      sound_timer_queue32(1);
       break;
 
     default:
@@ -1336,6 +1448,13 @@
 }
 
 #define write_palette8(address, value)                                        \
+{                                                                             \
+  u32 palette_address = address & ~0x01;                                      \
+  u16 double_value = ((value << 8) | value);                                  \
+  ADDRESS16(palette_ram, palette_address) = double_value;                     \
+  CONVERT_PALETTE(double_value);                                              \
+  ADDRESS16(palette_ram_converted, palette_address) = double_value;           \
+}                                                                             \
 
 #define write_palette16(address, value)                                       \
 {                                                                             \
@@ -1493,14 +1612,33 @@
 #define write_backup32()                                                      \
 
 #define write_vram8()                                                         \
-  address &= ~0x01;                                                           \
-  ADDRESS16(vram, address) = ((value << 8) | value)                           \
+  if(address & 0x10000)                                                       \
+    ADDRESS16(vram, address & 0x17FFe) = ((value << 8) | value);              \
+  else                                                                        \
+    ADDRESS16(vram, address & 0x1FFFe) = ((value << 8) | value)               \
 
 #define write_vram16()                                                        \
-  ADDRESS16(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+    ADDRESS16(vram, address & 0x17FFF) = value;                               \
+  else                                                                        \
+    ADDRESS16(vram, address & 0x1FFFF) = value                                \
 
 #define write_vram32()                                                        \
-  ADDRESS32(vram, address) = value                                            \
+  if(address & 0x10000)                                                       \
+    ADDRESS32(vram, address & 0x17FFF) = value;                               \
+  else                                                                        \
+    ADDRESS32(vram, address & 0x1FFFF) = value                                \
+
+#define write_oam_ram8()                                                      \
+/*  Write 8bit data is ignore */                                              \
+
+#define write_oam_ram16()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS16(oam_ram, address & 0x3FF) = value                                 \
+
+#define write_oam_ram32()                                                     \
+  oam_update = 1;                                                             \
+  ADDRESS32(oam_ram, address & 0x3FF) = value                                 \
 
 // RTC code derived from VBA's (due to lack of any real publically available
 // documentation...)
@@ -1783,7 +1921,9 @@
                                                                               \
     case 0x04:                                                                \
       /* I/O registers */                                                     \
-      return write_io_register##type(address & 0xFFF, value);                 \
+      if(address < 0x04000400)                                                \
+        return write_io_register##type(address & 0x3FF, value);                 /* IOは0x803まで存在 */ \
+      break;                                                                    /* 0x800は0x800ごとにループしている:TODO */ \
                                                                               \
     case 0x05:                                                                \
       /* palette RAM */                                                       \
@@ -1792,17 +1932,12 @@
                                                                               \
     case 0x06:                                                                \
       /* VRAM */                                                              \
-      address &= 0x1FFFF;                                                     \
-      if(address >= 0x18000)                                                  \
-        address -= 0x8000;                                                    \
-                                                                              \
       write_vram##type();                                                     \
       break;                                                                  \
                                                                               \
     case 0x07:                                                                \
       /* OAM RAM */                                                           \
-      oam_update = 1;                                                         \
-      ADDRESS##type(oam_ram, address & 0x3FF) = value;                        \
+      write_oam_ram##type();                                                  \
       break;                                                                  \
                                                                               \
     case 0x08:                                                                \
@@ -1821,6 +1956,10 @@
     case 0x0E:                                                                \
       write_backup##type();                                                   \
       break;                                                                  \
+                                                                              \
+    default:                                                                  \
+      /* unwritable */                                                        \
+      break;                                                                  \
   }                                                                           \
 
 u8 read_memory8(u32 address)
@@ -1903,11 +2042,11 @@
   return CPU_ALERT_NONE;
 }
 
-char backup_filename[512];
+char backup_filename[MAX_FILE];
 
 u32 load_backup(char *name)
 {
-  char backup_path[1024];
+  char backup_path[MAX_PATH];
   FILE_ID backup_file;
 
   if (*DEFAULT_SAVE_DIR != (char)NULL) {
@@ -2091,7 +2230,7 @@
   char current_line[256];
   char current_variable[256];
   char current_value[256];
-  char config_path[512];
+  char config_path[MAX_PATH];
 //  u8 *line_ptr;
 //  u32 fgets_value;
   FILE *config_file;
@@ -2103,6 +2242,8 @@
   bios_rom[0x2C] = 0x00;
   translation_gate_targets = 0;
   flash_device_id = FLASH_DEVICE_MACRONIX_64KB;
+  backup_type = BACKUP_NONE;
+
 
   sprintf(config_path, "%s/%s", main_path, CONFIG_FILENAME);
 
@@ -2115,22 +2256,22 @@
       if(parse_config_line(current_line, current_variable, current_value)
        != -1)
       {
-        if(strcmp(current_variable, "game_name") ||
-         strcmp(current_value, gamepak_title))
+        if(strcasecmp(current_variable, "game_name") ||
+         strcasecmp(current_value, gamepak_title))
           continue;
 
         if(!fgets(current_line, 256, config_file) ||
          (parse_config_line(current_line, current_variable,
            current_value) == -1) ||
-         strcmp(current_variable, "game_code") ||
-         strcmp(current_value, gamepak_code))
+         strcasecmp(current_variable, "game_code") ||
+         strcasecmp(current_value, gamepak_code))
           continue;
 
         if(!fgets(current_line, 256, config_file) ||
          (parse_config_line(current_line, current_variable,
            current_value) == -1) ||
-         strcmp(current_variable, "vender_code") ||
-          strcmp(current_value, gamepak_maker))
+         strcasecmp(current_variable, "vender_code") ||
+          strcasecmp(current_value, gamepak_maker))
           continue;
 
         while(fgets(current_line, 256, config_file))
@@ -2138,13 +2279,13 @@
           if(parse_config_line(current_line, current_variable, current_value)
            != -1)
           {
-            if(!strcmp(current_variable, "game_name"))
+            if(!strcasecmp(current_variable, "game_name"))
             {
               fclose(config_file);
               return 0;
             }
 
-            if(!strcmp(current_variable, "idle_loop_eliminate_target"))
+            if(!strcasecmp(current_variable, "idle_loop_eliminate_target"))
             {
               if(idle_loop_targets < MAX_IDLE_LOOPS)
               {
@@ -2154,7 +2295,7 @@
               }
             }
 
-            if(!strcmp(current_variable, "translation_gate_target"))
+            if(!strcasecmp(current_variable, "translation_gate_target"))
             {
               if(translation_gate_targets < MAX_TRANSLATION_GATES)
               {
@@ -2164,26 +2305,40 @@
               }
             }
 
-            if(!strcmp(current_variable, "iwram_stack_optimize") &&
-              !strcmp(current_value, "no"))
+            if(!strcasecmp(current_variable, "iwram_stack_optimize") &&
+              !strcasecmp(current_value, "no"))
             {
                 iwram_stack_optimize = 0;
             }
 
-            if(!strcmp(current_variable, "flash_rom_type") &&
-              !strcmp(current_value, "128KB"))
+            if(!strcasecmp(current_variable, "flash_rom_type") &&
+              !strcasecmp(current_value, "128KB"))
             {
               flash_device_id = FLASH_DEVICE_MACRONIX_128KB;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_39") &&
-              !strcmp(current_value, "yes"))
+            // DBZLGCYGOKU2 のプロテクト回避
+            // EEPROM_V124で特殊な物(現在判別不可) で指定すれば動作可
+            if(!strcasecmp(current_variable, "save_type"))
+            {
+              if(!strcasecmp(current_value, "sram"))
+                backup_type = BACKUP_SRAM;
+              else
+              if(!strcasecmp(current_value, "flash"))
+                backup_type = BACKUP_FLASH;
+              else
+              if(!strcasecmp(current_value, "eeprom"))
+                backup_type = BACKUP_EEPROM;
+            }
+
+            if(!strcasecmp(current_variable, "bios_rom_hack_39") &&
+              !strcasecmp(current_value, "yes"))
             {
               bios_rom[0x39] = 0xC0;
             }
 
-            if(!strcmp(current_variable, "bios_rom_hack_2C") &&
-              !strcmp(current_value, "yes"))
+            if(!strcasecmp(current_variable, "bios_rom_hack_2C") &&
+              !strcasecmp(current_value, "yes"))
             {
                bios_rom[0x2C] = 0x02;
             }
@@ -2210,11 +2365,6 @@
   {
     u32 gamepak_size = file_length(name, gamepak_file);
 
-    // First, close the last one if it was open, we won't
-    // be needing it anymore.
-    if(FILE_CHECK_VALID(gamepak_file_large))
-      FILE_CLOSE(gamepak_file_large);
-
     // If it's a big file size keep it don't close it, we'll
     // probably want to load it later
     if(gamepak_size <= gamepak_ram_buffer_size)
@@ -2229,8 +2379,13 @@
       // Read in just enough for the header
       FILE_READ(gamepak_file, gamepak_rom, 0x100);
       gamepak_file_large = gamepak_file;
-      strcpy(gamepak_filename_raw, name);
+//      strcpy(gamepak_filename_raw, name);
 //      FILE_CLOSE(gamepak_file);
+      // ファイルリストでカレントディレクトリを変更された場合
+      // ファイルが読めなくなるので、フルパス指定
+      char temp_path[MAX_PATH];
+      getcwd(temp_path, MAX_PATH);
+      sprintf(gamepak_filename_raw, "%s/%s", temp_path, name);
     }
 
     return gamepak_size;
@@ -2239,23 +2394,34 @@
   return -1;
 }
 
-u32 load_gamepak(char *name)
+s32 load_gamepak(char *name)
 {
   char *dot_position = strrchr(name, '.');
   s32 file_size;
-  char cheats_filename[256];
+  char cheats_filename[MAX_FILE];
+
+  // ファイルが開いていたら閉じる
+  if(FILE_CHECK_VALID(gamepak_file_large))
+    FILE_CLOSE(gamepak_file_large);
+
+  gamepak_file_large = -1;
 
-  if(!strcmp(dot_position, ".zip"))
+  if(!strcasecmp(dot_position, ".zip"))
+  {
+    set_cpu_clock(333); 
     file_size = load_file_zip(name);
+  }
   else
+  {
     file_size = load_gamepak_raw(name);
+  }
 
   if(file_size != -1)
   {
     gamepak_size = (file_size + 0x7FFF) & ~0x7FFF;
 
     strcpy(backup_filename, name);
-    strncpy(gamepak_filename, name, 512);
+    strncpy(gamepak_filename, name, MAX_FILE);
     change_ext(gamepak_filename, backup_filename, ".sav");
 
     load_backup(backup_filename);
@@ -2380,6 +2546,8 @@
   dma_smc_vars_##type()                                                       \
 
 #define dma_vars_vram(type)                                                   \
+  if(type##_ptr & 0x10000)                                                    \
+    type##_ptr &= ~0x08000                                                    \
 
 #define dma_vars_palette_ram(type)                                            \
 
@@ -2528,7 +2696,7 @@
 #define dma_epilogue_ext()                                                    \
 
 #define print_line()                                                          \
-  dma_print(src_op, dest_op, transfer_size, wb);                              \
+  dma_print(src_op, dest_op, transfer_size, wb)                               \
 
 #define dma_transfer_loop_region(src_region_type, dest_region_type, src_op,   \
  dest_op, transfer_size, wb)                                                  \
@@ -2549,7 +2717,7 @@
   break;                                                                      \
 }                                                                             \
 
-#define dma_transfer_loop(src_op, dest_op, transfer_size, wb);                \
+#define dma_transfer_loop(src_op, dest_op, transfer_size, wb)                 \
 {                                                                             \
   u32 src_region = src_ptr >> 24;                                             \
   u32 dest_region = dest_ptr >> 24;                                           \
@@ -2896,14 +3064,16 @@
   {
     src_ptr &= ~0x01;
     dest_ptr &= ~0x01;
-    cycle_dma16_words += length;
+    // TODO:???
+//    cycle_dma16_words += length;
     dma_transfer_expand(16);
   }
   else
   {
     src_ptr &= ~0x03;
     dest_ptr &= ~0x03;
-    cycle_dma32_words += length;
+    // TODO:???
+//    cycle_dma32_words += length;
     dma_transfer_expand(32);
   }
 
@@ -3131,7 +3301,6 @@
   map_ram_region(read, 0x3000000, 0x4000000, 1, iwram);
   map_region(read, 0x4000000, 0x5000000, 1, io_registers);
   map_null(read, 0x5000000, 0x6000000);
-  map_null(read, 0x6000000, 0x7000000);
   map_vram(read);
   map_null(read, 0x7000000, 0x8000000);
   init_memory_gamepak();
@@ -3184,8 +3353,6 @@
   io_registers[REG_BG3PD] = 0x100;
   io_registers[REG_RCNT] = 0x8000;
 
-  backup_type = BACKUP_NONE;
-
   sram_size = SRAM_SIZE_32KB;
   flash_size = FLASH_SIZE_64KB;
 
@@ -3239,7 +3406,7 @@
   FILE_OPEN(savestate_file, savestate_path, READ);
   if(FILE_CHECK_VALID(savestate_file))
   {
-    char current_gamepak_filename[512];
+    char current_gamepak_filename[MAX_FILE];
     u32 i;
     u32 current_color;
 
diff -ru 30_orig/memory.h gpsp-kai-test/memory.h
--- 30_orig/memory.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/memory.h	2007-08-12 00:56:13.721760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -145,8 +146,8 @@
 extern char gamepak_title[13];
 extern char gamepak_code[5];
 extern char gamepak_maker[3];
-extern char gamepak_filename[512];
-extern char gamepak_filename_raw[512];
+extern char gamepak_filename[MAX_FILE];
+extern char gamepak_filename_raw[MAX_PATH];
 
 extern u8 *gamepak_rom;
 extern u32 gamepak_ram_buffer_size;
@@ -172,6 +173,8 @@
 
 extern FILE_TAG_TYPE gamepak_file_large;
 
+extern u32 gbc_sound_wave_update;
+
 // 関数宣言
 
 extern u8 read_memory8(u32 address);
@@ -185,7 +188,7 @@
 extern CPU_ALERT_TYPE dma_transfer(DMA_TRANSFER_TYPE *dma);
 extern u8 *memory_region(u32 address, u32 *memory_limit);
 extern s32 load_bios(char *name);
-extern u32 load_gamepak(char *name);
+extern s32 load_gamepak(char *name);
 extern u8 *load_gamepak_page(u32 physical_index);
 extern u32 load_backup(char *name);
 extern void init_memory();
diff -ru 30_orig/mips_emit.h gpsp-kai-test/mips_emit.h
--- 30_orig/mips_emit.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/mips_emit.h	2007-08-07 12:49:38.000000000 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -821,12 +822,12 @@
 
 #define generate_shift_reg_lsr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_lsr_flags_reg)                    \
 
 #define generate_shift_reg_asr_flags(_rm, _rs)                                \
   generate_load_reg_pc(reg_a0, _rm, 12);                                      \
-  generate_load_reg_pc(reg_a1, _rs, 8)                                        \
+  generate_load_reg_pc(reg_a1, _rs, 8);                                       \
   generate_function_call_swap_delay(execute_asr_flags_reg)                    \
 
 #define generate_shift_reg_ror_flags(_rm, _rs)                                \
@@ -949,7 +950,7 @@
   u32 _address = (u32)(address);                                              \
   u32 _address_hi = (_address + 0x8000) >> 16;                                \
   generate_load_imm(ireg, address);                                           \
-  mips_emit_lui(ireg, _address_hi >> 16)                                      \
+  mips_emit_lui(ireg, _address_hi >> 16);                                     \
   generate_load_memory_##type(ireg, _address - (_address_hi << 16));          \
 }                                                                             \
 
@@ -1410,7 +1411,8 @@
 
 #define generate_op_adcs_reg(_rd, _rn, _rm)                                   \
   mips_emit_addu(reg_temp, _rm, reg_c_cache);                                 \
-  generate_add_flags_prologue(_rn, _rm);                                      \
+/*  generate_add_flags_prologue(_rn, _rm); */                                 \
+  generate_add_flags_prologue(_rn, reg_temp);                                 \
   mips_emit_addu(_rd, _rn, reg_temp);                                         \
   generate_add_flags_epilogue(_rd)                                            \
 
@@ -1537,20 +1539,54 @@
   arm_generate_op_imm(name, load_op)                                          \
 
 
+/* 1S+x+y */
+/* x=1I cycles if Op2 shifted-by-register. y=1S+1N cycles if Rd=R15. */
+#define cycle_arm_data_proc_reg()                                             \
+  cycle_count++;                                                              \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_reg_flags()                                       \
+  cycle_arm_data_proc_reg()                                                   \
+
+#define cycle_arm_data_proc_imm()                                             \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_data_proc_imm_flags()                                       \
+  cycle_arm_data_proc_imm()                                                   \
+
+/* 1S+x */
+#define cycle_arm_data_proc_test_reg()                                        \
+  cycle_count++                                                               \
+
+#define cycle_arm_data_proc_test_reg_flags()                                  \
+  cycle_arm_data_proc_test_reg()                                              \
+
+#define cycle_arm_data_proc_test_imm()                                        \
+
+#define cycle_arm_data_proc_test_imm_flags()                                  \
+
+/* AND, EOR, SUB, RSB, ADD, ADC, SBC, RSC, ORR, BIC  1S+x+y */
 #define arm_data_proc(name, type, flags_op)                                   \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
+/* TST, TEQ, CMP, CMN  1S+x */
 #define arm_data_proc_test(name, type)                                        \
 {                                                                             \
   arm_generate_op_##type(name, yes);                                          \
+  cycle_arm_data_proc_test_##type();                                          \
 }                                                                             \
 
+/* MOV, MVN  1S+x+y */
 #define arm_data_proc_unary(name, type, flags_op)                             \
 {                                                                             \
   arm_generate_op_##type(name, no);                                           \
+  cycle_arm_data_proc_##type();                                               \
   check_store_reg_pc_##flags_op(rd);                                          \
 }                                                                             \
 
@@ -1566,9 +1602,36 @@
   mips_emit_mflo(reg_temp);                                                   \
   mips_emit_addu(arm_to_mips_reg[rd], reg_temp, arm_to_mips_reg[rn])          \
 
+u32 cycle_multiply(_rs)
+{
+  u32 mult_rs = arm_to_mips_reg[_rs];
+  if(((s32)mult_rs) < 0)
+    mult_rs = ~mult_rs;
+
+  if((mult_rs & 0xFFFFFF00) == 0)  /* m=1 for Bit 31-8 */
+    return 1;
+  else
+  if((mult_rs & 0xFFFF0000) == 0)  /* m=2 for Bit 31-16 */
+    return 2;
+  else
+  if((mult_rs & 0xFF000000) == 0)  /* m=3 for Bit 31-24 */
+    return 3;
+  else                             /* m=4 otherwise */
+    return 4;
+}
+
+/* 1S+mI */
+#define cycle_arm_multiply_add_no()                                           \
+  cycle_count += cycle_multiply(rs)                                           \
+
+/* 1S+mI+1I */
+#define cycle_arm_multiply_add_yes()                                          \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
 #define arm_multiply(add_op, flags)                                           \
 {                                                                             \
   arm_decode_multiply();                                                      \
+  cycle_arm_multiply_add_##add_op();                                          \
   mips_emit_multu(arm_to_mips_reg[rm], arm_to_mips_reg[rs]);                  \
   arm_multiply_add_##add_op();                                                \
   arm_multiply_flags_##flags(arm_to_mips_reg[rd]);                            \
@@ -1590,9 +1653,18 @@
 #define arm_multiply_long_add_no(name)                                        \
   generate_multiply_##name()                                                  \
 
+/* 1S+mI+1I */
+#define cycle_arm_multiply_long_add_no()                                      \
+  cycle_count += 1 + cycle_multiply(rs)                                       \
+
+/* 1S+mI+2I */
+#define cycle_arm_multiply_long_add_yes()                                     \
+  cycle_count += 2 + cycle_multiply(rs)                                       \
+
 #define arm_multiply_long(name, add_op, flags)                                \
 {                                                                             \
   arm_decode_multiply_long();                                                 \
+  cycle_arm_multiply_long_add_##add_op();                                     \
   arm_multiply_long_add_##add_op(name);                                       \
   mips_emit_mflo(arm_to_mips_reg[rdlo]);                                      \
   mips_emit_mfhi(arm_to_mips_reg[rdhi]);                                      \
@@ -1642,15 +1714,50 @@
   arm_psr_##transfer_type(op_type, psr_reg);                                  \
 }                                                                             \
 
+/* LDR: 1S+1N+1I. LDR PC: 2S+2N+1I. STR: 2N. */
+#define cycle_arm_access_memory_load_u32()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_u16()                                    \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24];               \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2                                                          \
+
+#define cycle_arm_access_memory_load_s16()                                    \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_u8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_load_s8()                                     \
+  cycle_arm_access_memory_load_u16()                                          \
+
+#define cycle_arm_access_memory_store_u32()                                   \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_u16()                                   \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_arm_access_memory_store_s16()                                   \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_u8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
+#define cycle_arm_access_memory_store_s8()                                    \
+  cycle_arm_access_memory_store_u16()                                         \
+
 #define arm_access_memory_load(mem_type)                                      \
-  cycle_count += 2;                                                           \
+  cycle_arm_access_memory_load_##mem_type();                                  \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 8));                                         \
   generate_store_reg(reg_rv, rd);                                             \
   check_store_reg_pc_no_flags(rd)                                             \
 
 #define arm_access_memory_store(mem_type)                                     \
-  cycle_count++;                                                              \
+  cycle_arm_access_memory_store_##mem_type();                                 \
   generate_load_pc(reg_a2, (pc + 4));                                         \
   generate_load_reg_pc(reg_a1, rd, 12);                                       \
   generate_function_call_swap_delay(execute_store_##mem_type)                 \
@@ -1737,11 +1844,22 @@
 #define sprint_yes(access_type, pre_op, post_op, wb)                          \
   printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
 
+/* LDM, nS+1N+1I. LDM PC, (n+1)S+2N+1I. STM (n-1)S+2N. */
 #define arm_block_memory_load()                                               \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define arm_block_memory_store()                                              \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_load_reg_pc(reg_a1, i, 8);                                         \
   generate_function_call_swap_delay(execute_aligned_store32)                  \
 
@@ -1754,10 +1872,13 @@
   generate_load_reg(reg_a1, i)                                                \
 
 #define arm_block_memory_adjust_pc_store()                                    \
+  cycle_count++;                                                              \
 
 #define arm_block_memory_adjust_pc_load()                                     \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_mov(reg_a0, reg_rv);                                             \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
@@ -1775,8 +1896,10 @@
 #define arm_block_memory_sp_adjust_pc_store()                                 \
 
 #define arm_block_memory_sp_adjust_pc_load()                                  \
+  cycle_count++;                                                              \
   if(reg_list & 0x8000)                                                       \
   {                                                                           \
+    cycle_count += 2;                                                         \
     generate_indirect_branch_arm();                                           \
   }                                                                           \
 
@@ -1847,7 +1970,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -1866,149 +1988,6 @@
   }                                                                           \
 }                                                                             \
 
-#define arm_block_writeback_no()
-
-#define arm_block_writeback_yes()                                             \
-  mips_emit_addu(arm_to_mips_reg[rn], reg_a2, reg_zero)                       \
-
-#define arm_block_address_preadjust_up_full(wb)                               \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   ((word_bit_count(reg_list)) * 4));                                         \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_up(wb)                                    \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn], 4);                            \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down_full(wb)                             \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -((word_bit_count(reg_list)) * 4));                                        \
-  arm_block_writeback_##wb()                                                  \
-
-#define arm_block_address_preadjust_down(wb)                                  \
-  mips_emit_addiu(reg_a2, arm_to_mips_reg[rn],                                \
-   -(((word_bit_count(reg_list)) * 4) - 4));                                  \
-  arm_block_writeback_##wb()
-
-#define arm_block_address_preadjust_no(wb)                                    \
-  mips_emit_addu(reg_a2, arm_to_mips_reg[rn], reg_zero)                       \
-
-#define arm_block_address_postadjust_no()                                     \
-
-#define arm_block_address_postadjust_up()                                     \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   ((word_bit_count(reg_list)) * 4))                                          \
-
-#define arm_block_address_postadjust_down()                                   \
-  mips_emit_addiu(arm_to_mips_reg[rn], reg_a2,                                \
-   -((word_bit_count(reg_list)) * 4))                                         \
-
-#define sprint_no(access_type, pre_op, post_op, wb)                           \
-
-#define sprint_yes(access_type, pre_op, post_op, wb)                          \
-  printf("sbit on %s %s %s %s\n", #access_type, #pre_op, #post_op, #wb)       \
-
-#define arm_block_memory_load()                                               \
-  generate_function_call_swap_delay(execute_aligned_load32);                  \
-  generate_store_reg(reg_rv, i)                                               \
-
-#define arm_block_memory_store()                                              \
-  generate_load_reg_pc(reg_a1, i, 8);                                         \
-  generate_function_call_swap_delay(execute_aligned_store32)                  \
-
-#define arm_block_memory_final_load()                                         \
-  arm_block_memory_load()                                                     \
-
-#define arm_block_memory_final_store()                                        \
-  generate_load_pc(reg_a2, (pc + 4));                                         \
-  mips_emit_jal(mips_absolute_offset(execute_store_u32));                     \
-  generate_load_reg(reg_a1, i)                                                \
-
-#define arm_block_memory_adjust_pc_store()                                    \
-
-#define arm_block_memory_adjust_pc_load()                                     \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_mov(reg_a0, reg_rv);                                             \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define arm_block_memory_sp_load()                                            \
-  mips_emit_lw(arm_to_mips_reg[i], reg_a1, offset);                           \
-
-#define arm_block_memory_sp_store()                                           \
-{                                                                             \
-  u32 store_reg = i;                                                          \
-  check_load_reg_pc(arm_reg_a0, store_reg, 8);                                \
-  mips_emit_sw(arm_to_mips_reg[store_reg], reg_a1, offset);                   \
-}                                                                             \
-
-#define arm_block_memory_sp_adjust_pc_store()                                 \
-
-#define arm_block_memory_sp_adjust_pc_load()                                  \
-  if(reg_list & 0x8000)                                                       \
-  {                                                                           \
-    generate_indirect_branch_arm();                                           \
-  }                                                                           \
-
-#define old_arm_block_memory(access_type, pre_op, post_op, wb, s_bit)         \
-{                                                                             \
-  arm_decode_block_trans();                                                   \
-  u32 i;                                                                      \
-  u32 offset = 0;                                                             \
-  u32 base_reg = arm_to_mips_reg[rn];                                         \
-                                                                              \
-  arm_block_address_preadjust_##pre_op(wb);                                   \
-  arm_block_address_postadjust_##post_op();                                   \
-                                                                              \
-  sprint_##s_bit(access_type, pre_op, post_op, wb);                           \
-                                                                              \
-  if((rn == REG_SP) && iwram_stack_optimize)                                  \
-  {                                                                           \
-    mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
-    generate_load_imm(reg_a0, ((u32)(iwram + 0x8000)));                       \
-    mips_emit_addu(reg_a1, reg_a1, reg_a0);                                   \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        arm_block_memory_sp_##access_type();                                  \
-        offset += 4;                                                          \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_sp_adjust_pc_##access_type();                            \
-  }                                                                           \
-  else                                                                        \
-  {                                                                           \
-    mips_emit_ins(reg_a2, reg_zero, 0, 2);                                    \
-                                                                              \
-    for(i = 0; i < 16; i++)                                                   \
-    {                                                                         \
-      if((reg_list >> i) & 0x01)                                              \
-      {                                                                       \
-        cycle_count++;                                                        \
-        mips_emit_addiu(reg_a0, reg_a2, offset);                              \
-        if(reg_list & ~((2 << i) - 1))                                        \
-        {                                                                     \
-          arm_block_memory_##access_type();                                   \
-          offset += 4;                                                        \
-        }                                                                     \
-        else                                                                  \
-        {                                                                     \
-          arm_block_memory_final_##access_type();                             \
-          break;                                                              \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    arm_block_memory_adjust_pc_##access_type();                               \
-  }                                                                           \
-}
-
-
 
 // This isn't really a correct implementation, may have to fix later.
 
@@ -2047,6 +2026,13 @@
   thumb_generate_op_##rn_type(name, _rd, _rs, _rn);                           \
 }                                                                             \
 
+#define thumb_data_proc_muls(type, rn_type, _rd, _rs, _rn)                    \
+{                                                                             \
+  thumb_decode_##type();                                                      \
+  cycle_count += cycle_multiply(_rs); /* 1S+mI */                             \
+  thumb_generate_op_##rn_type(muls, _rd, _rs, _rn);                           \
+}                                                                             \
+
 #define thumb_data_proc_test(type, name, rn_type, _rs, _rn)                   \
 {                                                                             \
   thumb_decode_##type();                                                      \
@@ -2068,6 +2054,8 @@
 #define thumb_data_proc_hi(name)                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   u32 dest_rd = rd;                                                           \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   check_load_reg_pc(arm_reg_a1, rd, 4);                                       \
@@ -2102,6 +2090,8 @@
 #define thumb_data_proc_mov_hi()                                              \
 {                                                                             \
   thumb_decode_hireg_op();                                                    \
+  if(rd == reg_pc)                                                            \
+    cycle_count += 2;                                                         \
   check_load_reg_pc(arm_reg_a0, rs, 4);                                       \
   mips_emit_addu(arm_to_mips_reg[rd], arm_to_mips_reg[rs], reg_zero);         \
   check_store_reg_pc_thumb(rd);                                               \
@@ -2157,8 +2147,15 @@
   mips_emit_addu(arm_to_mips_reg[original_rd], reg_a0, reg_zero);             \
 }                                                                             \
 
+#define cycle_thumb_shift_shift()                                             \
+
+/* ALU operations LSL,LSR,ASR,ROR  1S+1I */
+#define cycle_thumb_shift_alu_op()                                            \
+  cycle_count++                                                               \
+
 #define thumb_shift(decode_type, op_type, value_type)                         \
 {                                                                             \
+  cycle_thumb_shift_##decode_type();                                          \
   thumb_decode_##decode_type();                                               \
   thumb_generate_shift_##value_type(op_type);                                 \
   generate_op_logic_flags(arm_to_mips_reg[rd]);                               \
@@ -2166,14 +2163,45 @@
 
 // Operation types: imm, mem_reg, mem_imm
 
+/* LDR 1S+1N+1I, STR 2N */
+#define cycle_thumb_access_memory_load_u32()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[1][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_u16()                                  \
+  cycle_count += 1 + waitstate_cycles_non_seq[0][reg_a0 >> 24]                \
+
+#define cycle_thumb_access_memory_load_s16()                                  \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_u8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_load_s8()                                   \
+  cycle_thumb_access_memory_load_u16()                                        \
+
+#define cycle_thumb_access_memory_store_u32()                                 \
+  cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_u16()                                 \
+  cycle_count += waitstate_cycles_non_seq[0][reg_a0 >> 24]                    \
+
+#define cycle_thumb_access_memory_store_s16()                                 \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_u8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
+#define cycle_thumb_access_memory_store_s8()                                  \
+  cycle_thumb_access_memory_store_u16()                                       \
+
 #define thumb_access_memory_load(mem_type, reg_rd)                            \
-  cycle_count += 2;                                                           \
+  cycle_thumb_access_memory_load_##mem_type();                                \
   mips_emit_jal(mips_absolute_offset(execute_load_##mem_type));               \
   generate_load_pc(reg_a1, (pc + 4));                                         \
   generate_store_reg(reg_rv, reg_rd)                                          \
 
 #define thumb_access_memory_store(mem_type, reg_rd)                           \
-  cycle_count++;                                                              \
+  cycle_thumb_access_memory_store_##mem_type();                               \
   generate_load_pc(reg_a2, (pc + 2));                                         \
   mips_emit_jal(mips_absolute_offset(execute_store_##mem_type));              \
   generate_load_reg(reg_a1, reg_rd)                                           \
@@ -2236,10 +2264,20 @@
 #define thumb_block_address_postadjust_push_lr(base_reg)                      \
 
 #define thumb_block_memory_load()                                             \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   generate_function_call_swap_delay(execute_aligned_load32);                  \
   generate_store_reg(reg_rv, i)                                               \
 
 #define thumb_block_memory_store()                                            \
+  if(offset)                                                                  \
+    cycle_count += waitstate_cycles_seq[1][reg_a0 >> 24];                     \
+  else                                                                        \
+    cycle_count += waitstate_cycles_non_seq[1][reg_a0 >> 24];                 \
+                                                                              \
   mips_emit_jal(mips_absolute_offset(execute_aligned_store32));               \
   generate_load_reg(reg_a1, i)                                                \
 
@@ -2300,8 +2338,17 @@
   generate_indirect_branch_cycle_update(thumb)                                \
 
 #define thumb_block_memory_sp_extra_push_lr()                                 \
+  cycle_count--;                                                              \
   mips_emit_sw(reg_r14, reg_a1, (bit_count[reg_list] * 4))                    \
 
+#define cycle_thumb_block_memory_load()                                       \
+  cycle_count++;                                                              \
+  if(reg_list & 0x8000)                                                       \
+    cycle_count += 2                                                          \
+
+#define cycle_thumb_block_memory_store()                                      \
+  cycle_count++                                                               \
+
 #define thumb_block_memory(access_type, pre_op, post_op, base_reg)            \
 {                                                                             \
   thumb_decode_rlist();                                                       \
@@ -2311,6 +2358,8 @@
   thumb_block_address_preadjust_##pre_op(base_reg);                           \
   thumb_block_address_postadjust_##post_op(base_reg);                         \
                                                                               \
+  cycle_thumb_block_memory_##access_type();                                   \
+                                                                              \
   if((base_reg == REG_SP) && iwram_stack_optimize)                            \
   {                                                                           \
     mips_emit_andi(reg_a1, reg_a2, 0x7FFC);                                   \
@@ -2337,7 +2386,6 @@
     {                                                                         \
       if((reg_list >> i) & 0x01)                                              \
       {                                                                       \
-        cycle_count++;                                                        \
         mips_emit_addiu(reg_a0, reg_a2, offset);                              \
         if(reg_list & ~((2 << i) - 1))                                        \
         {                                                                     \
@@ -2354,10 +2402,11 @@
                                                                               \
     thumb_block_memory_extra_##post_op();                                     \
   }                                                                           \
-}
+}                                                                             \
 
 #define thumb_conditional_branch(condition)                                   \
 {                                                                             \
+  cycle_count +=2;                                                            \
   condition_check_type condition_check;                                       \
   generate_condition_##condition();                                           \
   generate_branch_no_cycle_update(                                            \
@@ -2368,35 +2417,42 @@
 }                                                                             \
 
 #define arm_conditional_block_header()                                        \
-  generate_condition();                                                       \
+  generate_condition()                                                        \
 
 #define arm_b()                                                               \
+  cycle_count += 2;                                                           \
   generate_branch()                                                           \
 
 #define arm_bl()                                                              \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, (pc + 4));                                        \
   generate_branch()                                                           \
 
 #define arm_bx()                                                              \
+  cycle_count += 2;                                                           \
   arm_decode_branchx();                                                       \
   generate_load_reg(reg_a0, rn);                                              \
   /*generate_load_pc(reg_a2, pc);*/                                           \
   generate_indirect_branch_dual()                                             \
 
 #define arm_swi()                                                             \
-  if (((opcode >> 16) &0xFF) >= 0x2B) break;                                  \
+  if(((opcode >> 16) & 0xFF) > 0x2A)                                          \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler((opcode >> 16) & 0xFF);                            \
   generate_load_pc(reg_a0, (pc + 4));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
-  generate_branch();                                                          \
+  generate_branch()                                                           \
 
 #define thumb_b()                                                             \
+  cycle_count += 2;                                                           \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
   block_exit_position++                                                       \
 
 #define thumb_bl()                                                            \
+  cycle_count += 2;                                                           \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
@@ -2408,12 +2464,13 @@
   thumb_decode_branch();                                                      \
   generate_alu_imm(addiu, addu, reg_a0, reg_r14, (offset * 2));               \
   generate_load_pc(reg_r14, ((pc + 2) | 0x01));                               \
-  generate_indirect_branch_cycle_update(dual);                                \
+  generate_indirect_branch_cycle_update(thumb);                               \
   break;                                                                      \
 }                                                                             \
 
 #define thumb_bx()                                                            \
 {                                                                             \
+  cycle_count += 2;                                                           \
   thumb_decode_hireg_op();                                                    \
   generate_load_reg_pc(reg_a0, rs, 4);                                        \
   /*generate_load_pc(reg_a2, pc);*/                                           \
@@ -2421,14 +2478,16 @@
 }                                                                             \
 
 #define thumb_swi()                                                           \
-  if ((opcode & 0xFF) >= 0x2B) break;                                         \
+  if((opcode & 0xFF) > 0x2A)                                                  \
+    break;                                                                    \
+  cycle_count += 2;                                                           \
   generate_swi_hle_handler(opcode & 0xFF);                                    \
   generate_load_pc(reg_a0, (pc + 2));                                         \
   generate_function_call_swap_delay(execute_swi);                             \
   generate_branch_cycle_update(                                               \
    block_exits[block_exit_position].branch_source,                            \
    block_exits[block_exit_position].branch_target);                           \
-  block_exit_position++;                                                      \
+  block_exit_position++                                                       \
 
 u8 swi_hle_handle[256][2] =
 { /* use bios , emu bios */
diff -ru 30_orig/mips_stub.S gpsp-kai-test/mips_stub.S
--- 30_orig/mips_stub.S	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/mips_stub.S	2007-08-09 13:46:09.000000000 +0900
@@ -2,6 +2,7 @@
 #
 # Copyright (C) 2006 Exophase <exophase@gmail.com>
 # Copyright (C) 2007 takka <takka@tfact.net>
+# Copyright (C) 2007 _____ <_____>
 #
 # This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License as
@@ -132,10 +133,10 @@
 .endm
 
 .macro collapse_flags
-  lw $2, REG_CPSR($16)            # $2 = [$16 + REG_CPSR]		# load CPSR
-  andi $2, $2, 0xFF               # $2 = $2 and 0xFF			# isolate lower 8bits
-  collapse_flag 20, 31            # # store flags
-  collapse_flag 21, 30            #
+  lw $2, REG_CPSR($16)            # load CPSR
+  andi $2, $2, 0xFF               # isolate lower 8bits
+  collapse_flag 20, 31            # store flags
+  collapse_flag 21, 30
   collapse_flag 22, 29
   collapse_flag 23, 28
   sw $2, REG_CPSR($16)            # store CPSR
@@ -277,20 +278,16 @@
   lui $2, %hi(\ftable)
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
-  srl $2, $2, 2                   # remove lower two bits
 
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -311,24 +308,18 @@
 1:
   ins $1, $4, 6, \alignment       # place alignment bits into offset
   lui $2, %hi(\ftable)
-
   addu $2, $2, $1
   lw $2, %lo(\ftable)($2)         # new function handler is in $2
 
-  srl $2, $2, 2                   # remove lower two bits
-
   lui $1, %hi(3 << 26)            # $1 = 3 (JAL opcode)
+  srl $2, $2, 2                   # remove lower two bits
   ins $1, $2, 0, 26               # insert offset into jal
 
   addiu $ra, $ra, -8              # rewind return address to function call
   sw $1, ($ra)                    # modify to call new handler
 
-##  cache 0x1a, ($ra)               # writeback dcache line
-##  cache 0x8, ($ra)                # invalidate icache line
-##  cache 0x1a, ($ra)               # do it again for good luck :P
-##  cache 0x8, ($ra)
-  cache 0x1a, ($ra)               # hit writeback dcache line
-  cache 0x08, ($ra)               # hit invalidate icache line
+  cache 0x1a, ($ra)               # writeback dcache line
+  cache 0x08, ($ra)               # invalidate icache line
 
   jr $ra                          # return
   nop                             # wary of putting cache here
@@ -449,53 +440,51 @@
 
 
 .macro translate_region_vram_core
-  addiu $2, $2, -3                # see if it's 3
   ext $4, $4, 0, 17               # generate 17bit offset
-  bne $2, $0, 1f                  # if $2 != $0 then j 1:
-  lui $1, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $2, $0, 1f                 # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 1:
+  lui $1, %hi(vram)               # start loading vram address
   addu $2, $1, $4                 # $2 = (hi)vram + address
 .endm
 
 .macro translate_region_vram patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align16 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_load_align32 align_bits, alignment, patch_handler
   region_check_align 6, \align_bits, \alignment, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align16 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 1                # mask out lower bit of address
   translate_region_vram_core
 .endm
 
 .macro translate_region_vram_store_align32 patch_handler
   region_check 6, \patch_handler
-  ext $2, $4, 15, 2               # $2 = bits 15 and 16 of address (delay)
+  ext $2, $4, 16, 1               # $2 = bit 16 of address (delay)
   ins $4, $0, 0, 2                # mask out lower two bits of address
   translate_region_vram_core
 .endm
@@ -506,7 +495,7 @@
   srl $2, $4, 15                  # $2 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $2 = memory_map_read[address >> 15]
-  lw $2, -32768($2)               # 
+  lw $2, -32768($2)
   bne $2, $0, 1f                  # if it's non-NULL continue
   andi $1, $4, \mask              # $1 = low 15bits of address (delay slot)
 
@@ -517,8 +506,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -565,8 +554,8 @@
 
   jal load_gamepak_page           # get page in $2
   sw $1, REG_SAVE($16)            # save offset (delay)
-  lw $1, REG_SAVE($16)            # restore offset (delay)
 
+  lw $1, REG_SAVE($16)            # restore offset
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE2($16)          # restore return address
@@ -579,20 +568,18 @@
 
 .macro eeprom_load_a patch_handler
   region_check 0xD, \patch_handler
-
   sw $ra, REG_SAVE($16)           # save the return address (delay)
-  sw $6, REG_SAVE2($16)           # save a2
 
   save_registers                  # save the registers
 
   jal read_eeprom                 # get eeprom value in $2
-  nop
+  sw $6, REG_SAVE2($16)           # save a2 (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -634,7 +621,7 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
@@ -650,13 +637,13 @@
   save_registers                  # save the registers
 
   jal read_backup                 # get backup value in $2
-  ext $4, $4, 0, 16               # address &= 0xFFFF
+  ext $4, $4, 0, 16               # address &= 0xFFFF (delay)
 
   restore_registers               # restore the other registers
 
   lw $ra, REG_SAVE($16)           # restore return address
   jr $ra                          # return
-  lw $6, REG_SAVE2($16)           # restore a2
+  lw $6, REG_SAVE2($16)           # restore a2 (delay)
 .endm
 
 
@@ -696,7 +683,7 @@
   andi $4, $4, 0x01               # in Thumb mode, isolate one more bit
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory8                # get instruction at PC
@@ -724,7 +711,7 @@
   addu $4, $0, $0                 # zero out address bit
 
 1:
-  sw $ra, REG_SAVE($16)           # save the return address (delay)
+  sw $ra, REG_SAVE($16)           # save the return address
   save_registers                  # save the registers
 
   jal read_memory16               # get instruction at PC
@@ -757,14 +744,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:                                # join point
   restore_registers               # restore the other registers
@@ -775,7 +762,6 @@
 
 .macro open_load32_a patch_handler
   region_check_open \patch_handler
-
   lw $2, REG_CPSR($16)            # $2 = CPSR (delay)
   andi $2, $2, 0x20               # test T bit
 
@@ -786,14 +772,14 @@
   sw $ra, REG_SAVE($16)           # save the return address (delay)
 
   jal read_memory16               # get instruction at PC
-  addu $4, $5, $0                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
   j 2f
   ins $2, $2, 16, 16              # result = (result << 16) | result (delay)
 
 1:
   jal read_memory32               # get instruction at PC
-  addu $4, $5, $4                 # a0 = PC
+  addu $4, $5, $0                 # a0 = PC (delay)
 
 2:
   restore_registers               # restore the other registers
@@ -820,7 +806,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -837,7 +823,7 @@
   save_registers                  # save the registers
 
   jal \function                   # store value out
-  andi $4, $4, \mask              # mask address
+  andi $4, $4, \mask              # mask address (delay)
 
   restore_registers               # restore the other registers
 
@@ -961,9 +947,9 @@
 
 execute_load_bios_u8:
   region_check 0, patch_load_u8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -994,9 +980,18 @@
   load_u8 (iwram + 0x8000)
 
 execute_load_io_u8:
-  translate_region 4, patch_load_u8, io_registers, 0xFFF
+  region_check 4, patch_load_u8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u8 io_registers
 
+1:
+  open_load8_core
+  nop
+
 execute_load_palette_u8:
   translate_region 5, patch_load_u8, palette_ram, 0x3FF
   load_u8 palette_ram
@@ -1067,9 +1062,9 @@
 
 execute_load_bios_s8:
   region_check 0, patch_load_s8
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1097,9 +1092,18 @@
   load_s8 (iwram + 0x8000)
 
 execute_load_io_s8:
-  translate_region 4, patch_load_s8, io_registers, 0xFFF
+  region_check 4, patch_load_s8
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s8 io_registers
 
+1:
+  open_load8_core
+  seb $2, $2
+
 execute_load_palette_s8:
   translate_region 5, patch_load_s8, palette_ram, 0x3FF
   load_s8 palette_ram
@@ -1170,9 +1174,9 @@
 
 execute_load_bios_u16:
   region_check_align 0, 1, 0, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1199,9 +1203,18 @@
   load_u16 (iwram + 0x8000)
 
 execute_load_io_u16:
-  translate_region_align 4, 1, 0, patch_load_u16, io_registers, 0xFFF
+  region_check 4, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16 io_registers
 
+1:
+  open_load16_core
+  nop
+
 execute_load_palette_u16:
   translate_region_align 5, 1, 0, patch_load_u16, palette_ram, 0x3FF
   load_u16 palette_ram
@@ -1250,9 +1263,9 @@
 
 execute_load_bios_u16u:
   region_check_align 0, 1, 1, patch_load_u16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1280,9 +1293,18 @@
   load_u16_unaligned (iwram + 0x8000)
 
 execute_load_io_u16u:
-  translate_region_align 4, 1, 1, patch_load_u16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_u16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u16_unaligned io_registers
 
+1:
+  open_load16_core
+  ror $2, $2, 8
+
 execute_load_palette_u16u:
   translate_region_align 5, 1, 1, patch_load_u16, palette_ram, 0x3FE
   load_u16_unaligned palette_ram
@@ -1341,6 +1363,7 @@
   .long execute_load_gamepakA_u16 # 0x0A gamepak
   .long execute_load_gamepakB_u16 # 0x0B gamepak
   .long execute_load_gamepakC_u16 # 0x0C gamepak
+
   .long execute_load_eeprom_u16   # 0x0D gamepak/eeprom
   .long execute_load_backup_u16   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u16     # 0x0F open
@@ -1405,9 +1428,9 @@
 
 execute_load_bios_s16:
   region_check_align 0, 1, 0, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1435,9 +1458,18 @@
   load_s16 (iwram + 0x8000)
 
 execute_load_io_s16:
-  translate_region_align 4, 1, 0, patch_load_s16, io_registers, 0xFFF
+  region_check_align 4, 1, 0, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16 io_registers
 
+1:
+  open_load16_core
+  seh $2, $2
+
 execute_load_palette_s16:
   translate_region_align 5, 1, 0, patch_load_s16, palette_ram, 0x3FF
   load_s16 palette_ram
@@ -1486,9 +1518,9 @@
 
 execute_load_bios_s16u:
   region_check_align 0, 1, 1, patch_load_s16
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1515,9 +1547,18 @@
   load_s16_unaligned (iwram + 0x8000)
 
 execute_load_io_s16u:
-  translate_region_align 4, 1, 1, patch_load_s16, io_registers, 0x3FE
+  region_check_align 4, 1, 1, patch_load_s16
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FE              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_s16_unaligned io_registers
 
+1:
+  open_load16_core
+  seb $2, $2
+
 execute_load_palette_s16u:
   translate_region_align 5, 1, 1, patch_load_s16, palette_ram, 0x3FE
   load_s16_unaligned palette_ram
@@ -1605,9 +1646,9 @@
 
 execute_load_bios_u32:
   region_check_align 0, 2, 0, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1634,9 +1675,18 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32:
-  translate_region_align 4, 2, 0, patch_load_u32, io_registers, 0xFFF
+  region_check_align 4, 2, 0, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_core
+  nop
+
 execute_load_palette_u32:
   translate_region_align 5, 2, 0, patch_load_u32, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -1685,9 +1735,9 @@
 
 execute_load_bios_u32u1:
   region_check_align 0, 2, 1, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1712,9 +1762,18 @@
   load_u32_unaligned (iwram + 0x8000), 1
 
 execute_load_io_u32u1:
-  translate_region_align 4, 2, 1, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 1, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 1
 
+1:
+  open_load32_core
+  ror $2, $2, 8
+
 execute_load_palette_u32u1:
   translate_region_align 5, 2, 1, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 1
@@ -1763,9 +1822,9 @@
 
 execute_load_bios_u32u2:
   region_check_align 0, 2, 2, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1790,9 +1849,18 @@
   load_u32_unaligned (iwram + 0x8000), 2
 
 execute_load_io_u32u2:
-  translate_region_align 4, 2, 2, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 2, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 2
 
+1:
+  open_load32_core
+  ror $2, $2, 16
+
 execute_load_palette_u32u2:
   translate_region_align 5, 2, 2, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 2
@@ -1840,9 +1908,9 @@
 
 execute_load_bios_u32u3:
   region_check_align 0, 2, 3, patch_load_u32
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -1867,9 +1935,18 @@
   load_u32_unaligned (iwram + 0x8000), 3
 
 execute_load_io_u32u3:
-  translate_region_align 4, 2, 3, patch_load_u32, io_registers, 0x3FC
+  region_check_align 4, 2, 3, patch_load_u32
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FC              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32_unaligned io_registers, 3
 
+1:
+  open_load32_core
+  ror $2, $2, 24
+
 execute_load_palette_u32u3:
   translate_region_align 5, 2, 3, patch_load_u32, palette_ram, 0x3FC
   load_u32_unaligned palette_ram, 3
@@ -1928,6 +2005,7 @@
   .long execute_load_gamepakA_u32 # 0x0A gamepak
   .long execute_load_gamepakB_u32 # 0x0B gamepak
   .long execute_load_gamepakC_u32 # 0x0C gamepak
+
   .long execute_load_eeprom_u32   # 0x0D gamepak/eeprom
   .long execute_load_backup_u32   # 0x0E Flash ROM/SRAM
   .long execute_load_open_u32     # 0x0F open
@@ -1992,9 +2070,9 @@
 
 execute_load_bios_u32a:
   region_check 0, patch_load_u32a
-  srl $2, $4, 14                  # check if address is in BIOS region
+  srl $2, $4, 14                  # check if address is in BIOS region (delay)
   bne $2, $0, 2f                  # if not, perform open read
-  srl $1, $5, 14                  # check if PC is in BIOS region
+  srl $1, $5, 14                  # check if PC is in BIOS region (delay)
   bne $1, $0, 1f                  # if not, perform BIOS protected read
   lui $2, %hi(bios_rom)           # generate upper address (delay)
 
@@ -2020,9 +2098,17 @@
   load_u32 (iwram + 0x8000)
 
 execute_load_io_u32a:
-  translate_region 4, patch_load_u32a, io_registers, 0xFFF
+  region_check 4, patch_load_u32a
+  ext $2, $4, 10, 14              # $2 = (address << 8) >> 18 (delay)
+  bne $2, $0, 1f                  # if not, perform open read
+  lui $2, %hi(io_registers)       # generate upper address (delay)
+  andi $4, $4, 0x3FF              # generate offset
+  addu $2, $2, $4                 # add ptr upper and offset
   load_u32 io_registers
 
+1:
+  open_load32_a
+
 execute_load_palette_u32a:
   translate_region 5, patch_load_u32a, palette_ram, 0x3FF
   load_u32 palette_ram
@@ -2108,12 +2194,14 @@
   region_check 4, patch_store_u8
   andi $5, $5, 0xFF               # make value 8bit
   andi $4, $4, 0x3FF              # wrap around address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register8          # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2124,6 +2212,7 @@
   andi $4, $4, 0x3FE              # align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2137,10 +2226,7 @@
   store_u8_double vram
 
 execute_store_oam_u8:
-  translate_region 7, patch_store_u8, oam_ram, 0x3FE
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  store_u8_double oam_ram
+  ignore_region 7, patch_store_u8 # Write 8bit data is ignore
 
 execute_store_ignore8_u8:
   ignore_region 8, patch_store_u8
@@ -2209,12 +2295,14 @@
   region_check 4, patch_store_u16
   andi $5, $5, 0xFFFF             # make value 16bit
   andi $4, $4, 0x3FE              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register16         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2224,6 +2312,7 @@
   andi $4, $4, 0x3FE              # wrap/align palette address
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2312,12 +2401,14 @@
   region_check 4, patch_store_u32
   nop
   andi $4, $4, 0x3FC              # wrap around/align address
+
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
 
   save_registers
   jal write_io_register32         # write the value out
   sw $6, REG_PC($16)              # save the PC (delay slot)
+
   j write_io_epilogue             # handle any state changes
   nop
 
@@ -2421,21 +2512,18 @@
 
 execute_store_io_u32a:
   region_check 4, patch_store_u32a
-  nop
+  sw $ra, REG_SAVE2($16)          # save ra (delay)
   sw $6, REG_SAVE($16)            # save a2
-  sw $ra, REG_SAVE2($16)          # save ra
-
-  andi $4, $4, 0x3FC              # wrap around/align address
 
   save_registers
   jal write_io_register32         # write the value out
-  nop
+  andi $4, $4, 0x3FC              # wrap around/align address (delay)
 
   restore_registers
 
   lw $ra, REG_SAVE2($16)          # restore ra
   jr $ra
-  lw $6, REG_SAVE($16)            # restore a2
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 execute_store_palette_u32a:
   region_check 5, patch_store_u32a
@@ -2495,22 +2583,22 @@
   ignore_high patch_store_u32a
 
 store_u32a_ftable:
-  .long execute_store_ignore0_u32a# 0x00 BIOS
-  .long execute_store_ignore1_u32a# 0x01 open address
-  .long execute_store_ewram_u32a  # 0x02 EWRAM
-  .long execute_store_iwram_u32a  # 0x03 IWRAM
-  .long execute_store_io_u32a     # 0x04 I/O registers
-  .long execute_store_palette_u32a# 0x05 Palette RAM
-  .long execute_store_vram_u32a   # 0x06 VRAM
-  .long execute_store_oam_u32a    # 0x07 OAM RAM
-  .long execute_store_ignore8_u32a# 0x08 gamepak
-  .long execute_store_ignore9_u32a# 0x09 gamepak
-  .long execute_store_ignoreA_u32a# 0x0A gamepak
-  .long execute_store_ignoreB_u32a# 0x0B gamepak
-  .long execute_store_ignoreC_u32a# 0x0C gamepak
-  .long execute_store_eeprom_u32a # 0x0D gamepak/eeprom
-  .long execute_store_ignoreE_u32a# 0x0E Flash ROM/SRAM
-  .long execute_store_ignoreF_u32a# 0x0F open address
+  .long execute_store_ignore0_u32a # 0x00 BIOS
+  .long execute_store_ignore1_u32a # 0x01 open address
+  .long execute_store_ewram_u32a   # 0x02 EWRAM
+  .long execute_store_iwram_u32a   # 0x03 IWRAM
+  .long execute_store_io_u32a      # 0x04 I/O registers
+  .long execute_store_palette_u32a # 0x05 Palette RAM
+  .long execute_store_vram_u32a    # 0x06 VRAM
+  .long execute_store_oam_u32a     # 0x07 OAM RAM
+  .long execute_store_ignore8_u32a # 0x08 gamepak
+  .long execute_store_ignore9_u32a # 0x09 gamepak
+  .long execute_store_ignoreA_u32a # 0x0A gamepak
+  .long execute_store_ignoreB_u32a # 0x0B gamepak
+  .long execute_store_ignoreC_u32a # 0x0C gamepak
+  .long execute_store_eeprom_u32a  # 0x0D gamepak/eeprom
+  .long execute_store_ignoreE_u32a # 0x0E Flash ROM/SRAM
+  .long execute_store_ignoreF_u32a # 0x0F open address
 
 patch_store_u32a:
   patch_handler store_u32a_ftable, 0x0F
@@ -2521,7 +2609,7 @@
 execute_load_full_u8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_u8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2534,9 +2622,11 @@
 ext_load_u8:
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)                   # store return address
+
   save_registers
   jal read_memory8                # read the value
   nop
+
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # return
@@ -2546,7 +2636,7 @@
 execute_load_full_s8:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_load_s8         # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2573,7 +2663,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_u16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2581,7 +2671,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lhu $2, ($1)                    # read the value
+  lhu $2, ($1)                    # read the value (delay)
 
 ext_load_u16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2599,7 +2689,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 1                # or unaligned (bottom bit)
   bne $1, $0, ext_load_s16        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2607,7 +2697,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lh $2, ($1)                     # read the value
+  lh $2, ($1)                     # read the value (delay)
 
 ext_load_s16:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2626,7 +2716,7 @@
   srl $1, $4, 28                  # check if the address is out of range
   ins $1, $4, 4, 2                # or unaligned (bottom two bits)
   bne $1, $0, ext_load_u32        # if it is, perform an extended read
-  srl $2, $4, 15                  # $1 = page number of address
+  srl $2, $4, 15                  # $1 = page number of address (delay)
   sll $2, $2, 2                   # adjust to word index
   addu $2, $2, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($2)
@@ -2634,7 +2724,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_load_u32:
   addiu $sp, $sp, -4              # make room on the stack for $ra
@@ -2650,7 +2740,7 @@
 #execute_aligned_load32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_load32  # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_read[address >> 15]
   lw $1, -32768($1)
@@ -2658,7 +2748,7 @@
   andi $2, $4, 0x7FFF             # $2 = low 15bits of address (delay slot)
   addu $1, $1, $2                 # add the memory map offset
   jr $ra                          # return
-  lw $2, ($1)                     # read the value
+  lw $2, ($1)                     # read the value (delay)
 
 ext_aligned_load32:
   addiu $sp, $sp, -8              # make room on the stack for $ra
@@ -2689,12 +2779,8 @@
   nop
   collapse_flags                  # make sure flags are good for update_gba
 
-alert_loop:
   jal update_gba                  # process the next event
   nop
-  lw $1, CPU_HALT_STATE($16)      # check if CPU is sleeping
-  bne $1, $0, alert_loop          # see if it hasn't changed
-  nop
 
   addu $17, $2, $0                # $17 = new cycle counter
   lw $4, REG_PC($16)              # $4 = new PC
@@ -2705,13 +2791,13 @@
 irq_alert:
   restore_registers
   j lookup_pc                     # PC has changed, get a new one
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 no_alert:
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 smc_dma:
   addiu $sp, $sp, 4               # fix the stack
@@ -2730,14 +2816,14 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 
 # 8bit ext memory routines
 
 ext_store_io8:
   andi $5, $5, 0xFF               # make value 8bit
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2747,34 +2833,27 @@
   nop
 
 ext_store_palette8:
+  ins $5, $5, 8, 8                # value = (value << 8) | value
   j ext_store_palette16b          # perform 16bit palette write
   andi $4, $4, 0x3FE              # wrap + align (delay)
 
 ext_store_vram8:
   ins $5, $5, 8, 8                # value = (value << 8) | value
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
   ins $4, $0, 0, 1                # align out bottom bit
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # if $4 >= $1 then $1 = 0 else $1 = 1
-  bne $1, $0, ext_store_vram8b    # if $1 != 0 then j ext_store_vram8b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram8b   # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram8b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
 
 ext_store_oam8:
-  lui $1, %hi(oam_update)         # write non-zero to oam_update
-  sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
-  andi $4, $4, 0x3FE              # wrap around address and align to 16bits
-  ins $5, $5, 8, 8                # value = (value << 8) | value
-  lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
-  addu $1, $1, $4                 # $1 = (hi)oam_ram + address
-  jr $ra                          # return
-  sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
+  jr $ra                          # Write 8bit data is ignore
+  nop
 
 ext_store_backup:
   andi $5, $5, 0xFF               # make value 8bit
@@ -2787,25 +2866,25 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u8_jtable:
-  .long ext_store_ignore  # 0x00 BIOS
-  .long ext_store_ignore  # 0x01 invalid
+  .long ext_store_ignore    # 0x00 BIOS
+  .long ext_store_ignore    # 0x01 invalid
   .long ext_store_ignore    # 0x02 EWRAM
   .long ext_store_ignore    # 0x03 IWRAM
   .long ext_store_io8       # 0x04 I/O registers
   .long ext_store_palette8  # 0x05 Palette RAM
   .long ext_store_vram8     # 0x06 VRAM
   .long ext_store_oam8      # 0x07 OAM RAM
-  .long ext_store_ignore  # 0x08 gamepak (no RTC accepted in 8bit)
-  .long ext_store_ignore  # 0x09 gamepak, ignore
-  .long ext_store_ignore  # 0x0A gamepak, ignore
-  .long ext_store_ignore  # 0x0B gamepak, ignore
-  .long ext_store_ignore  # 0x0C gamepak, ignore
-  .long ext_store_eeprom   # 0x0D EEPROM (possibly)
-  .long ext_store_backup   # 0x0E Flash ROM/SRAM
-  .long ext_store_ignore  # 0x0F invalid
+  .long ext_store_ignore    # 0x08 gamepak (no RTC accepted in 8bit)
+  .long ext_store_ignore    # 0x09 gamepak, ignore
+  .long ext_store_ignore    # 0x0A gamepak, ignore
+  .long ext_store_ignore    # 0x0B gamepak, ignore
+  .long ext_store_ignore    # 0x0C gamepak, ignore
+  .long ext_store_eeprom    # 0x0D EEPROM (possibly)
+  .long ext_store_backup    # 0x0E Flash ROM/SRAM
+  .long ext_store_ignore    # 0x0F invalid
 
 
 
@@ -2844,7 +2923,7 @@
 # 16bit ext memory routines
 
 ext_store_io16:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   andi $5, $5, 0xFFFF             # make value 16bit
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
@@ -2861,6 +2940,7 @@
   lui $2, %hi(palette_ram)
   addu $2, $2, $4
   sh $5, %lo(palette_ram)($2)     # palette_ram[address] = value
+
   sll $1, $5, 1                   # make green 6bits
   ins $1, $0, 0, 6                # make bottom bit 0
   ins $1, $5, 0, 5                # insert red channel into $1
@@ -2870,15 +2950,13 @@
   sh $1, %lo(palette_ram_converted)($2)
 
 ext_store_vram16:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram16b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram16b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram16b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sh $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2886,6 +2964,7 @@
 ext_store_oam16:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -2893,7 +2972,7 @@
   sh $5, %lo(oam_ram)($1)         # oam_ram[address] = value (delay)
 
 ext_store_rtc:
-  andi $5, $5, 0xFFFF             # make value 16bit
+  andi $4, $4, 0xFFFF             # wrap address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2902,7 +2981,7 @@
   restore_registers
   lw $ra, ($sp)                   # restore return address
   jr $ra                          # we can return
-  addiu $sp, $sp, 4               # fix the stack
+  addiu $sp, $sp, 4               # fix the stack (delay)
 
 ext_store_u16_jtable:
   .long ext_store_ignore          # 0x00 BIOS, ignore
@@ -2952,15 +3031,10 @@
 
 
 
-
-
-
-
-
 # 32bit ext memory routines
 
 ext_store_io32:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
   save_registers
@@ -2979,15 +3053,13 @@
   addu $ra, $6, $0                # restore return address (delay)
 
 ext_store_vram32:
+  ext $1, $4, 16, 1               # $1 = bit 16 of address
   ext $4, $4, 0, 17               # address = adress & 0x1FFFF
-  lui $1, %hi(0x18000)            # $1 = 0x18000
-  sltu $1, $4, $1                 # see if address < 0x18000
-  bne $1, $0, ext_store_vram32b
-  lui $2, %hi(vram)               # start loading vram address (delay)
-
-  addiu $4, $4, -0x8000           # move address into VRAM region
+  bnel $1, $0, ext_store_vram32b  # if address >= 0x10000
+  ins $4, $0, 15, 1               # mask out bit 15 of address (delay)
 
 ext_store_vram32b:
+  lui $2, %hi(vram)               # start loading vram address
   addu $2, $2, $4                 # $2 = (hi)vram + address
   jr $ra                          # return
   sw $5, %lo(vram)($2)            # vram[address] = value (delay)
@@ -2995,6 +3067,7 @@
 ext_store_oam32:
   lui $1, %hi(oam_update)         # write non-zero to oam_update
   sw $1, %lo(oam_update)($1)      # cheap, but the address is non-zero
+
   andi $4, $4, 0x3FF              # wrap around address
   lui $1, %hi(oam_ram)            # $1 = (hi)oam_ram
   addu $1, $1, $4                 # $1 = (hi)oam_ram + address
@@ -3031,6 +3104,7 @@
   nop
 
 #execute_store_u32:
+execute_store_full_u32:
   srl $1, $4, 28                  # check if the address is out of range
   bne $1, $0, ext_store_u32       # if it is, perform an extended write
   srl $2, $4, 15                  # $1 = page number of address (delay slot)
@@ -3050,20 +3124,22 @@
 # 32bit ext aligned, non a2 destroying routines
 
 ext_store_io32a:
-  andi $4, $4, 0xFFF              # wrap around address
+  andi $4, $4, 0x3FF              # wrap around address
   addiu $sp, $sp, -4              # make room on the stack for $ra
   sw $ra, ($sp)
+
   save_registers
   jal write_io_register32         # write the value out
-  sw $6, REG_SAVE($16)            # save a2
-  lw $6, REG_SAVE($16)            # restore a2
+  sw $6, REG_SAVE($16)            # save a2 (delay)
+
   j write_io_epilogue             # handle any state changes
-  nop
+  lw $6, REG_SAVE($16)            # restore a2 (delay)
 
 ext_store_palette32a:
   sw $ra, REG_SAVE($16)           # save return address
   jal ext_store_palette16b        # write out palette entry
   andi $4, 0x3FF                  # wrap address (delay)
+
   addiu $4, $4, 2                 # go to next location
   srl $5, $5, 16                  # shift to next 16bit value
   j ext_store_palette16b          # write out next palette entry
@@ -3101,7 +3177,7 @@
 #execute_aligned_store32:
   srl $2, $4, 28                  # check if the address is out of range
   bne $2, $0, ext_aligned_store32 # if it is, perform an extended load
-  srl $1, $4, 15                  # $1 = page number of address
+  srl $1, $4, 15                  # $1 = page number of address (delay)
   sll $1, $1, 2                   # adjust to word index
   addu $1, $1, $16                # $1 = memory_map_write[address >> 15]
   lw $1, 256($1)
@@ -3149,31 +3225,36 @@
   lw $1, CPU_MODE($16)            # $1 = cpu_mode
   lui $2, %hi(spsr)
   sll $1, $1, 2                   # adjust to word offset size
-  addu $2, $2, $1
+  addu $1, $2, $1
   jr $ra                          # return
-  lw $2, %lo(spsr)($2)            # $2 = spsr[cpu_mode] (delay slot)
+  lw $2, %lo(spsr)($1)            # $2 = spsr[cpu_mode] (delay slot)
 
 # Switch into SWI, has to collapse flags
 # $4: Current pc
 
 execute_swi:
-  add $sp, $sp, -4                # push $ra
-  sw $ra, ($sp)
   lui $1, %hi(SUPERVISOR_LR)
   sw $4, %lo(SUPERVISOR_LR)($1)   # store next PC in the supervisor's LR
   collapse_flags                  # get cpsr in $2
   lui $5, %hi(SUPERVISOR_SPSR)
   sw $2, %lo(SUPERVISOR_SPSR)($5) # save cpsr in SUPERVISOR_CPSR
+
+  addiu $sp, $sp, -4              # push $ra
+  sw $ra, ($sp)
+
   ins $2, $0, 0, 6                # zero out bottom 6 bits of CPSR
   ori $2, 0x13                    # set mode to supervisor
   sw $2, REG_CPSR($16)            # write back CPSR
+
   save_registers
+  jal bios_region_read_allow
+  nop
   jal set_cpu_mode                # set the CPU mode to supervisor
   li $4, 3                        # 3 is supervisor mode (delay slot)
   restore_registers
   lw $ra, ($sp)                   # pop $ra
   jr $ra                          # return
-  add $sp, $sp, 4                 # fix stack (delay slot)
+  addiu $sp, $sp, 4               # fix stack (delay slot)
 
 # $4: pc to restore to
 # returns in $4
@@ -3183,14 +3264,15 @@
 
   beq $1, $0, no_spsr_restore     # only restore if the cpu isn't usermode
   lui $2, %hi(spsr)               # start loading SPSR (delay)
-
   sll $1, $1, 2                   # adjust to word offset size
   addu $2, $2, $1
   lw $1, %lo(spsr)($2)            # $1 = spsr[cpu_mode]
-  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
-  extract_flags_body              # extract flags from $1
+
   addiu $sp, $sp, -4
   sw $ra, ($sp)
+
+  sw $1, REG_CPSR($16)            # cpsr = spsr[cpu_mode]
+  extract_flags_body              # extract flags from $1
   save_registers
   jal execute_spsr_restore_body   # do the dirty work in this C function
   nop
@@ -3280,7 +3362,7 @@
 
 lsl_shift_done:
   jr $ra                          # return
-  add $4, $0, $0                  # value = 0 no matter what
+  add $4, $0, $0                  # value = 0 no matter what (delay)
 
 
 execute_lsr_flags_reg:
@@ -3341,28 +3423,17 @@
 # $4: cycle counter argument
 
 execute_arm_translate:
-  addu $17, $4, $0                # load cycle counter register
   lui $16, %hi(reg)               # load base register
   addiu $16, %lo(reg)
-  extract_flags                   # load flag variables
-
-  and $1, $1, 0x20                # see if Thumb bit is set in flags
+  addu $17, $4, $0                # load cycle counter register
 
-  bne $1, $0, 1f
+  jal block_lookup_address_arm    # lookup initial jump address
   lw $4, REG_PC($16)              # load PC into $4 (delay)
 
-  jal block_lookup_address_arm    # lookup initial jump address
-  nop
   restore_registers               # load initial register values
   jr $2                           # jump to return
   nop
 
-1:
-  jal block_lookup_address_thumb  # lookup initial jump address
-  nop
-  restore_registers               # load initial register values
-  jr $2                           # jump to return
-  nop
 
 # sceKernelInvalidateIcacheRange gives me problems, trying this instead
 # Invalidates an n byte region starting at the start address
@@ -3377,9 +3448,7 @@
   nop
 
 iir_loop:
-##  cache 8, ($4)                   # invalidate icache line
-##  cache 8, ($4)                   # do it again for good luck :P
-  cache 0x08, ($4)                # hit invalidate icache line
+  cache 0x08, ($4)                # invalidate icache line
   addiu $2, $2, -1                # next loop iteration
   bne $2, $0, iir_loop            # loop
   addiu $4, $4, 64                # go to next cache line (delay slot)
@@ -3403,8 +3472,6 @@
   jr $ra                          # return
   nop
 
-.align 4
-
 memory_map_read:
   .space 0x8000
 
@@ -3413,3 +3480,4 @@
 
 memory_map_write:
   .space 0x8000
+
Only in gpsp-kai-test/psp: .svn
Only in gpsp-kai-test/psp: EBOOT.PBP
diff -ru 30_orig/psp/Makefile gpsp-kai-test/psp/Makefile
--- 30_orig/psp/Makefile	2007-08-06 02:50:38.000000000 +0900
+++ gpsp-kai-test/psp/Makefile	2007-08-11 16:53:16.923760800 +0900
@@ -10,22 +10,22 @@
 
 PSP_EBOOT_ICON  = icon0.png
 
-OBJS            = main.o cpu.o video.o memory.o sound.o input.o \
-                  cpu_threaded.o gui.o zip.o cheats.o mips_stub.o fbm_print.o bios.o adhoc.o
+OBJS            = main.o cpu.o video.o memory.o sound.o input.o
+OBJS           += cpu_threaded.o gui.o zip.o cheats.o mips_stub.o fbm_print.o bios.o adhoc.o
 
 TARGET          = UO_gpSP_kai
 
 VERSION_MAJOR = 3
 VERSION_MINOR = 1
-VERSION_BUILD = 5
+VERSION_BUILD = 8
 VERSION_OPT = test ${VERSION_BUILD}
 
 PSP_EBOOT_TITLE = UnOfficial_gpSP_kai_${VERSION_MAJOR}.${VERSION_MINOR} ${VERSION_OPT}
 
 VPATH           += ..
-CFLAGS          += -O3 -DPSP_BUILD -G0 -Wall -Wredundant-decls -Wmissing-declarations -funsigned-char -ffast-math -fforce-addr -fmerge-all-constants -floop-optimize2 -funsafe-loop-optimizations -ftree-loop-linear
-#CFLAGS          += -Wredundant-decls -Wmissing-declarations
-#CFLAGS          += ${shell ${PREFIX}/bin/sdl-config --cflags}
+CFLAGS          += -O3 -DPSP_BUILD -G0 -funsigned-char
+CFLAGS          += -Wall -Wredundant-decls -Wmissing-declarations
+CFLAGS          += -ffast-math -fforce-addr -fmerge-all-constants -floop-optimize2 -funsafe-loop-optimizations -ftree-loop-linear
 
 CFLAGS          += -DVERSION_MAJOR=${VERSION_MAJOR}
 CFLAGS          += -DVERSION_MINOR=${VERSION_MINOR}
@@ -36,7 +36,6 @@
 
 LIBS            += -lpspgu -lpsprtc -lpspaudio
 LIBS            += -lz -lpsppower -lpspnet -lpspwlan -lpspnet_adhoc -lpspnet_adhocctl -lpspnet_adhocmatching
-#LIBS            += ${shell ${PREFIX}/bin/sdl-config --libs}
 
 include ${PSPSDK}/lib/build.mak
 
Only in gpsp-kai-test/psp: PARAM.SFO
Only in gpsp-kai-test/psp: UO_gpSP_kai.elf
Only in gpsp-kai-test/psp: adhoc.o
Only in gpsp-kai-test/psp: bios.o
Only in gpsp-kai-test/psp: cheats.o
Only in gpsp-kai-test/psp: cpu.o
Only in gpsp-kai-test/psp: cpu_threaded.o
Only in gpsp-kai-test/psp: fbm_print.o
Only in gpsp-kai-test/psp: gui.o
Only in gpsp-kai-test/psp: input.o
Only in gpsp-kai-test/psp: main.o
Only in gpsp-kai-test/psp: memory.o
Only in gpsp-kai-test/psp: mips_stub.o
Only in gpsp-kai-test/psp: sound.o
Only in gpsp-kai-test/psp: video.o
Only in gpsp-kai-test/psp: zip.o
diff -ru 30_orig/readme_kai_jp.txt gpsp-kai-test/readme_kai_jp.txt
--- 30_orig/readme_kai_jp.txt	2007-08-06 02:28:34.000000000 +0900
+++ gpsp-kai-test/readme_kai_jp.txt	2007-08-12 08:08:03.902760800 +0900
@@ -1,14 +1,36 @@
 -- gameplaySP  Gameboy Advance emulator for Playstation Portable --
 
 -- Release log --
--UnOfficial gpSP kai 3.1 test 05 svn rev.**
+-UnOfficial gpSP kai 3.1 test 08 svn rev.***
+	サウンドの遅れの調整
+	フレームスキップ処理の調整
+	サウンドのバグを修正
+
+-UnOfficial gpSP kai 3.1 test 07 svn rev.150
+	タイマー処理の調整
+	サウンドの遅れの調整
+		サウンドバッファの設定は現在機能していません、内部固定です
+		将来はサウンドバッファの設定を削除する予定です
+		現在の設定値は、以前の2倍の精度になっています
+		チャンネルごとのズレは現在調査中です
+
+-UnOfficial gpSP kai 3.1 test 06 svn rev.135
+	ZIPファイル読込み時の不具合を修正
+
+-UnOfficial gpSP kai 3.1 test 05.1 svn rev.129
+	サウンドの遅延を修正
+
+-UnOfficial gpSP kai 3.1 test 05 svn rev.125
 	カーネルモードで動作するように変更
-		カーネルモードにするため、改変SDLを使用
+	サウンド周りを非SDLにした
 	statesaveの日付表示を修正
-		pspsdkのtime()関数が時刻しか返さないため
-	上記に伴い、satesaveファイルのサイズを506947 -> 506951に変更
+	上記に伴い、statesaveファイルのサイズを506947 -> 506951に変更
 		古いファイルも読込み時に自動判別して読み込みます
 		保存時に新しい形式で保存されます
+	デフォルトディレクトリの変更
+	分割EBOOT.PBPの廃止
+		DEVHOOKやFW1.0~1.5を使用している方は各自対応して下さい
+	フォーラムからのソースを元に多数修正 thanks ?????
 
 -UnOfficial gpSP kai 3.1 test 04 svn rev.65
 	プチノイズの低減
Only in gpsp-kai-test/settings: .svn
diff -ru 30_orig/settings/Russia.fnt gpsp-kai-test/settings/Russia.fnt
--- 30_orig/settings/Russia.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/Russia.fnt	2007-08-07 08:03:33.748400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/dir.cfg gpsp-kai-test/settings/dir.cfg
--- 30_orig/settings/dir.cfg	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/dir.cfg	2007-08-09 08:48:47.706000000 +0900
@@ -1,16 +1,16 @@
 # dir config
 
 # default rom dir
-!ms0:/PSP/gba/rom
+!ms0:/PSP/GBA/ROM
 
 # default save dir
-!ms0:/PSP/gba/save
+!ms0:/PSP/GBA/SAVE
 
 # default cfg dir
-!ms0:/PSP/gba/cfg
+!ms0:/PSP/GBA/CFG
 
 # default screen shot dir
 !ms0:/PSP/PHOTO
 
 # default cheat dir
-!ms0:/PSP/gba/cht
+!ms0:/PSP/GBA/CHT
diff -ru 30_orig/settings/dutch.fnt gpsp-kai-test/settings/dutch.fnt
--- 30_orig/settings/dutch.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/dutch.fnt	2007-08-07 08:03:32.138400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/english.fnt gpsp-kai-test/settings/english.fnt
--- 30_orig/settings/english.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/english.fnt	2007-08-07 08:03:29.733400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/french.fnt gpsp-kai-test/settings/french.fnt
--- 30_orig/settings/french.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/french.fnt	2007-08-07 08:03:27.409400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/german.fnt gpsp-kai-test/settings/german.fnt
--- 30_orig/settings/german.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/german.fnt	2007-08-07 08:03:24.674400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/italian.fnt gpsp-kai-test/settings/italian.fnt
--- 30_orig/settings/italian.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/italian.fnt	2007-08-07 08:03:22.614400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/japanese.fnt gpsp-kai-test/settings/japanese.fnt
--- 30_orig/settings/japanese.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/japanese.fnt	2007-08-07 08:03:20.545400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/portuguese.fnt gpsp-kai-test/settings/portuguese.fnt
--- 30_orig/settings/portuguese.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/portuguese.fnt	2007-08-07 08:03:18.768400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/settings/spanish.fnt gpsp-kai-test/settings/spanish.fnt
--- 30_orig/settings/spanish.fnt	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/settings/spanish.fnt	2007-08-07 08:03:16.164400700 +0900
@@ -1,7 +1,7 @@
 # font file
 
 # 1 byte font
-!ms0:/fbm/1/5x10rk.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/5x10rk.fbm
 
 # 2 byte font
-!ms0:/fbm/2/knj10.fbm
+!ms0:/PSP/GAME150/UO_gpSP_kai/FONT/knj10.fbm
diff -ru 30_orig/sound.c gpsp-kai-test/sound.c
--- 30_orig/sound.c	2007-08-06 08:29:46.000000000 +0900
+++ gpsp-kai-test/sound.c	2007-08-12 12:23:03.162760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -31,35 +32,44 @@
 /******************************************************************************
  * マクロ等の定義
  ******************************************************************************/
-
-#define SOUND_TIMER_QUEUE(size, value)                                        \
-  *((s##size *)(ds->fifo + ds->fifo_top)) = value;                            \
-  ds->fifo_top = (ds->fifo_top + 1) % 32;                                     \
+// TODO:パラメータの調整が必要(サウンドバッファの設定は現在無視されている/調整必要)
+#define SAMPLE_COUNT PSP_AUDIO_SAMPLE_ALIGN(128) // サンプル数
+#define SAMPLE_SIZE  (SAMPLE_COUNT * 2)           // 1サンプルあたりのバッファ数
+#define GBC_NOISE_WRAP_FULL 32767
+#define GBC_NOISE_WRAP_HALF 126
 
 #define RENDER_SAMPLE_NULL()                                                  \
 
+// サウンドバッファにLEFT CHANNELのデータを書込む
 #define RENDER_SAMPLE_LEFT()                                                  \
-  sound_buffer[buffer_index] += current_sample +                              \
+  sound_buffer[sound_write_offset] += current_sample +                        \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
 
+// サウンドバッファにRIGHT CHANNELのデータを書込む
 #define RENDER_SAMPLE_RIGHT()                                                 \
-  sound_buffer[buffer_index + 1] += current_sample +                          \
+  sound_buffer[sound_write_offset + 1] += current_sample +                    \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional)           \
 
+// サウンドバッファにLEFT/RIGHT CHANNELのデータを書込む
 #define RENDER_SAMPLE_BOTH()                                                  \
   dest_sample = current_sample +                                              \
    FP16_16_TO_U32((next_sample - current_sample) * fifo_fractional);          \
-  sound_buffer[buffer_index] += dest_sample;                                  \
-  sound_buffer[buffer_index + 1] += dest_sample                               \
+  sound_buffer[sound_write_offset] += dest_sample;                            \
+  sound_buffer[sound_write_offset + 1] += dest_sample                         \
 
 #define RENDER_SAMPLES(type)                                                  \
   while(fifo_fractional <= 0xFFFF)                                            \
   {                                                                           \
     RENDER_SAMPLE_##type();                                                   \
     fifo_fractional += frequency_step;                                        \
-    buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
+    /* indexを進める */                                                       \
+    OFFSET_INC();                                                             \
   }                                                                           \
 
+#define OFFSET_INC()                                                          \
+  /* indexを進める */                                                         \
+  sound_write_offset = (sound_write_offset + 2) % BUFFER_SIZE                 \
+
 #define UPDATE_VOLUME_CHANNEL_ENVELOPE(channel)                               \
   volume_##channel = gbc_sound_envelope_volume_table[envelope_volume] *       \
    gbc_sound_channel_volume_table[gbc_sound_master_volume_##channel] *        \
@@ -71,8 +81,8 @@
    gbc_sound_master_volume_table[gbc_sound_master_volume]                     \
 
 #define UPDATE_VOLUME(type)                                                   \
-  update_volume_channel_##type(left);                                         \
-  update_volume_channel_##type(right)                                         \
+  UPDATE_VOLUME_CHANNEL_##type(left);                                         \
+  UPDATE_VOLUME_CHANNEL_##type(right)                                         \
 
 #define UPDATE_TONE_SWEEP()                                                   \
   if(gs->sweep_status)                                                        \
@@ -88,13 +98,12 @@
       else                                                                    \
         rate = rate + (rate >> gs->sweep_shift);                              \
                                                                               \
-      if(rate > 2048) {                                                       \
-        rate = 0;                                                             \
-        frequency_step = 0;                                                   \
-      } else {                                                                \
-        frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0)  \
-        / SOUND_FREQUENCY);                                                   \
+      if(rate > 2047)                                                         \
+      {                                                                       \
+        rate = 2047;                                                          \
       }                                                                       \
+      frequency_step = FLOAT_TO_FP16_16(((131072.0 / (2048.0 - rate)) * 8.0)  \
+        / SOUND_FREQUENCY);                                                   \
                                                                               \
       gs->frequency_step = frequency_step;                                    \
       gs->rate = rate;                                                        \
@@ -125,7 +134,7 @@
           envelope_volume = gs->envelope_volume - 1;                          \
       }                                                                       \
                                                                               \
-      UPDATE_VOLUME(envelope);                                                \
+      UPDATE_VOLUME(ENVELOPE);                                                \
                                                                               \
       gs->envelope_volume = envelope_volume;                                  \
       gs->envelope_ticks = gs->envelope_initial_ticks;                        \
@@ -154,18 +163,21 @@
       }                                                                       \
     }                                                                         \
                                                                               \
-    update_tone_##envelope_op();                                              \
-    update_tone_##sweep_op();                                                 \
+    UPDATE_TONE_##envelope_op();                                              \
+    UPDATE_TONE_##sweep_op();                                                 \
                                                                               \
     tick_counter &= 0xFFFF;                                                   \
   }                                                                           \
 
-#define GBC_SOUND_RENDER_SAMPLE_RIGHT()                                       \
-  sound_buffer[buffer_index + 1] += (current_sample * volume_right) >> 22     \
-
+// サウンドバッファにLEFT CHANNELのデータを書込む
 #define GBC_SOUND_RENDER_SAMPLE_LEFT()                                        \
-  sound_buffer[buffer_index] += (current_sample * volume_left) >> 22          \
+  sound_buffer[sound_write_offset] += (current_sample * volume_left) >> 22    \
+
+// サウンドバッファにRIGHT CHANNELのデータを書込む
+#define GBC_SOUND_RENDER_SAMPLE_RIGHT()                                       \
+  sound_buffer[sound_write_offset + 1] += (current_sample * volume_right) >> 22 \
 
+// サウンドバッファにLEFT/RIGHT CHANNELのデータを書込む
 #define GBC_SOUND_RENDER_SAMPLE_BOTH()                                        \
   GBC_SOUND_RENDER_SAMPLE_RIGHT();                                            \
   GBC_SOUND_RENDER_SAMPLE_LEFT()                                              \
@@ -175,18 +187,15 @@
   {                                                                           \
     current_sample =                                                          \
      sample_data[FP16_16_TO_U32(sample_index) % sample_length];               \
-    gbc_sound_render_sample_##type();                                         \
+    GBC_SOUND_RENDER_SAMPLE_##type();                                         \
                                                                               \
     sample_index += frequency_step;                                           \
-    buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
+    /* indexを進める */                                                       \
+    OFFSET_INC();                                                             \
                                                                               \
     UPDATE_TONE_COUNTERS(envelope_op, sweep_op);                              \
   }                                                                           \
 
-#define GBC_NOISE_WRAP_FULL 32767
-
-#define GBC_NOISE_WRAP_HALF 126
-
 #define GET_NOISE_SAMPLE_FULL()                                               \
   current_sample =                                                            \
    ((s32)(noise_table15[FP16_16_TO_U32(sample_index) >> 5] <<                 \
@@ -200,20 +209,22 @@
 #define GBC_SOUND_RENDER_NOISE(type, noise_type, envelope_op, sweep_op)       \
   for(i = 0; i < buffer_ticks; i++)                                           \
   {                                                                           \
-    get_noise_sample_##noise_type();                                          \
-    gbc_sound_render_sample_##type();                                         \
+    GET_NOISE_SAMPLE_##noise_type();                                          \
+    GBC_SOUND_RENDER_SAMPLE_##type();                                         \
                                                                               \
     sample_index += frequency_step;                                           \
                                                                               \
-    if(sample_index >= U32_TO_FP16_16(gbc_noise_wrap_##noise_type))           \
-      sample_index -= U32_TO_FP16_16(gbc_noise_wrap_##noise_type);            \
+    if(sample_index >= U32_TO_FP16_16(GBC_NOISE_WRAP_##noise_type))           \
+      sample_index -= U32_TO_FP16_16(GBC_NOISE_WRAP_##noise_type);            \
+                                                                              \
+    /* indexを進める */                                                       \
+    OFFSET_INC();                                                             \
                                                                               \
-    buffer_index = (buffer_index + 2) % BUFFER_SIZE;                          \
     UPDATE_TONE_COUNTERS(envelope_op, sweep_op);                              \
   }                                                                           \
 
 #define GBC_SOUND_RENDER_CHANNEL(type, sample_length, envelope_op, sweep_op)  \
-  buffer_index = gbc_sound_buffer_index;                                      \
+  sound_write_offset = gbc_sound_buffer_index;                                \
   sample_index = gs->sample_index;                                            \
   frequency_step = gs->frequency_step;                                        \
   tick_counter = gs->tick_counter;                                            \
@@ -226,15 +237,15 @@
       break;                                                                  \
                                                                               \
     case GBC_SOUND_LEFT:                                                      \
-      gbc_sound_render_##type(left, sample_length, envelope_op, sweep_op);    \
+      GBC_SOUND_RENDER_##type(LEFT, sample_length, envelope_op, sweep_op);    \
       break;                                                                  \
                                                                               \
     case GBC_SOUND_RIGHT:                                                     \
-      gbc_sound_render_##type(right, sample_length, envelope_op, sweep_op);   \
+      GBC_SOUND_RENDER_##type(RIGHT, sample_length, envelope_op, sweep_op);   \
       break;                                                                  \
                                                                               \
     case GBC_SOUND_LEFTRIGHT:                                                 \
-      gbc_sound_render_##type(both, sample_length, envelope_op, sweep_op);    \
+      GBC_SOUND_RENDER_##type(BOTH, sample_length, envelope_op, sweep_op);    \
       break;                                                                  \
   }                                                                           \
                                                                               \
@@ -258,7 +269,7 @@
   source = (s16 *)(sound_buffer + source_offset);                             \
   for(i = 0; i < _length; i++)                                                \
   {                                                                           \
-    sound_copy_##render_type();                                               \
+    SOUND_COPY_##render_type();                                               \
     if(current_sample > 2047)                                                 \
       current_sample = 2047;                                                  \
     if(current_sample < -2048)                                                \
@@ -277,140 +288,148 @@
     while (_length--) *ptr1++ = *ptr2++ = 0;                                  \
   }                                                                           \
 
+#define sound_savestate_body(type)                                          \
+{                                                                           \
+  FILE_##type##_VARIABLE(savestate_file, sound_on);                         \
+  FILE_##type##_VARIABLE(savestate_file, sound_buffer_base);                \
+  FILE_##type##_VARIABLE(savestate_file, sound_last_cpu_ticks);             \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_buffer_index);           \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_last_cpu_ticks);         \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_partial_ticks);          \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume_left);     \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume_right);    \
+  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume);          \
+  FILE_##type##_ARRAY(savestate_file, wave_samples);                        \
+  FILE_##type##_ARRAY(savestate_file, direct_sound_channel);                \
+  FILE_##type##_ARRAY(savestate_file, gbc_sound_channel);                   \
+}                                                                           \
+
+#define CHECK_BUFFER()                                                      \
+  ((gbc_sound_buffer_index - sound_read_offset) % BUFFER_SIZE)              \
 /******************************************************************************
  * グローバル変数の定義
  ******************************************************************************/
+DIRECT_SOUND_STRUCT direct_sound_channel[2];
+GBC_SOUND_STRUCT gbc_sound_channel[4];
+u32 sound_on = 0;
+u32 global_enable_audio = 1;
+u32 audio_buffer_size_number = 1;
+u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
+u32 left_buffer;
 
 /******************************************************************************
  * ローカル変数の定義
  ******************************************************************************/
+static u32 audio_buffer_size;
+volatile static u32 sound_buffer_base = 0; // サウンド バッファのベースポインタ
+static s16 sound_buffer[BUFFER_SIZE]; // サウンド バッファ 2n = Left / 2n+1 = Right
+volatile static s32 sound_read_offset = 0; // サウンドバッファの読み込みオフセット
+static SceUID sound_thread;
+static u32 sound_last_cpu_ticks = 0;
+static FIXED16_16 gbc_sound_tick_step;
+static u32 audio_thread_exit_flag; // オーディオスレッドの終了フラグ。
+volatile static u32 pause_sound_flag;
 
 /******************************************************************************
  * ローカル関数の宣言
  ******************************************************************************/
+static void init_noise_table(u32 *table, u32 period, u32 bit_length);
+static int sound_update_thread(SceSize args, void *argp);
 
+/******************************************************************************
+ * グローバル関数の定義
+ ******************************************************************************/
+// マジカルバケーションの不具合修正
+void sound_timer_queue32(u8 channel)
+  {
+    DIRECT_SOUND_STRUCT *ds = direct_sound_channel + channel;
+    u8 offset = channel * 4;
+    u8 i;
 
-u32 global_enable_audio = 1;
-
-direct_sound_struct direct_sound_channel[2];
-gbc_sound_struct gbc_sound_channel[4];
-
-//u32 sound_frequency = 44100;
-
-u32 audio_buffer_size_number = 1;
-u32 audio_buffer_size;
-u32 audio_buffer_size_x2;
-u32 sound_on = 0;
-s16 sound_buffer[BUFFER_SIZE];    // サウンド バッファ 2n = Left / 2n+1 = Right
-u32 sound_buffer_base = 0;
-static int sound_handle;          // サウンド スレッドのハンドル
-static SceUID sound_thread;
-
-u32 sound_last_cpu_ticks = 0;
-FIXED16_16 gbc_sound_tick_step;
-
-u32 gbc_sound_wave_update;
-
-u32 gbc_sound_wave_volume[4] = { 0, 16384, 8192, 4096 };
-
-void sound_callback(/*void *userdata, Uint8 *stream, int length*/);
-void init_noise_table(u32 *table, u32 period, u32 bit_length);
-
-// Queue 1, 2, or 4 samples to the top of the DS FIFO, wrap around circularly
-
-
-void sound_timer_queue8(u32 channel, u8 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  SOUND_TIMER_QUEUE(8, value);
-}
-
-void sound_timer_queue16(u32 channel, u16 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-  SOUND_TIMER_QUEUE(8, value & 0xFF);
-  SOUND_TIMER_QUEUE(8, value >> 8);
-}
-
-void sound_timer_queue32(u32 channel, u32 value)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
-
-  SOUND_TIMER_QUEUE(8, value & 0xFF);
-  SOUND_TIMER_QUEUE(8, (value >> 8) & 0xFF);
-  SOUND_TIMER_QUEUE(8, (value >> 16) & 0xFF);
-  SOUND_TIMER_QUEUE(8, value >> 24);
-}
-
-// Unqueue 1 sample from the base of the DS FIFO and place it on the audio
-// buffer for as many samples as necessary. If the DS FIFO is 16 bytes or
-// smaller and if DMA is enabled for the sound channel initiate a DMA transfer
-// to the DS FIFO.
-
+    for (i = 0xA0; i <= 0xA3; i++)
+    {
+      ds->fifo[ds->fifo_top] = ADDRESS8(io_registers, i + offset);
+      ds->fifo_top = (ds->fifo_top + 1) % 32;
+    }
+  }
 
 void sound_timer(FIXED16_16 frequency_step, u32 channel)
-{
-  direct_sound_struct *ds = direct_sound_channel + channel;
+  {
+    DIRECT_SOUND_STRUCT *ds = direct_sound_channel + channel;
 
-  FIXED16_16 fifo_fractional = ds->fifo_fractional;
-  u32 buffer_index = ds->buffer_index;
-  s16 current_sample, next_sample, dest_sample;
+    FIXED16_16 fifo_fractional = ds->fifo_fractional;
+    u32 sound_write_offset = ds->buffer_index;
+    s16 current_sample, next_sample, dest_sample;
 
-  current_sample = ds->fifo[ds->fifo_base] << 4;
-  ds->fifo_base = (ds->fifo_base + 1) % 32;
-  next_sample = ds->fifo[ds->fifo_base] << 4;
+    current_sample = ds->fifo[ds->fifo_base] << 4;
+    ds->fifo_base = (ds->fifo_base + 1) % 32;
+    next_sample = ds->fifo[ds->fifo_base] << 4;
 
-  if(sound_on == 1)
-  {
-    if(ds->volume == DIRECT_SOUND_VOLUME_50)
+    if (sound_on == 1)
     {
-      current_sample >>= 1;
-      next_sample >>= 1;
-    }
+      if (ds->volume == DIRECT_SOUND_VOLUME_50)
+      {
+        current_sample >>= 1;
+        next_sample >>= 1;
+      }
 
-    switch(ds->status)
+      switch (ds->status)
+        {
+          case DIRECT_SOUND_INACTIVE:
+            RENDER_SAMPLES(NULL)
+            ;
+            break;
+
+          case DIRECT_SOUND_RIGHT:
+            RENDER_SAMPLES(RIGHT)
+            ;
+            break;
+
+          case DIRECT_SOUND_LEFT:
+            RENDER_SAMPLES(LEFT)
+            ;
+            break;
+
+          case DIRECT_SOUND_LEFTRIGHT:
+            RENDER_SAMPLES(BOTH)
+            ;
+            break;
+        }
+    }
+    else
     {
-      case DIRECT_SOUND_INACTIVE:
-        RENDER_SAMPLES(NULL);
-        break;
-
-      case DIRECT_SOUND_RIGHT:
-        RENDER_SAMPLES(RIGHT);
-        break;
-
-      case DIRECT_SOUND_LEFT:
-        RENDER_SAMPLES(LEFT);
-        break;
-
-      case DIRECT_SOUND_LEFTRIGHT:
-        RENDER_SAMPLES(BOTH);
-        break;
+      RENDER_SAMPLES(NULL);
     }
-  }
-  else
-  {
-    RENDER_SAMPLES(NULL);
-  }
 
-  ds->buffer_index = buffer_index;
-  ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
+    ds->buffer_index = sound_write_offset;
+    ds->fifo_fractional = FP16_16_FRACTIONAL_PART(fifo_fractional);
 
-  if(((ds->fifo_top - ds->fifo_base) % 32) <= 16)
-  {
-    if(dma[1].direct_sound_channel == channel)
-      dma_transfer(dma + 1);
+    // マジカルバケーションで動作が遅くなるのが改善される
+    u8 fifo_length;
+
+    if (ds->fifo_top > ds->fifo_base)
+      fifo_length = ds->fifo_top - ds->fifo_base;
+    else
+      fifo_length = ds->fifo_top + (32 - ds->fifo_base);
+
+    if (fifo_length <= 16)
 
-    if(dma[2].direct_sound_channel == channel)
-      dma_transfer(dma + 2);
+      if (((ds->fifo_top - ds->fifo_base) % 32) <= 16)
+      {
+        if (dma[1].direct_sound_channel == channel)
+          dma_transfer(dma + 1);
+
+        if (dma[2].direct_sound_channel == channel)
+          dma_transfer(dma + 2);
+      }
   }
-}
 
 void sound_reset_fifo(u32 channel)
-{
-  direct_sound_struct *ds = direct_sound_channel;
+  {
+    DIRECT_SOUND_STRUCT *ds = direct_sound_channel;
 
-  memset(ds->fifo, 0, 32);
-}
+    memset(ds->fifo, 0, 32);
+  }
 
 // Initial pattern data = 4bits (signed)
 // Channel volume = 12bits
@@ -423,11 +442,11 @@
 // Square waves range from -8 (low) to 7 (high)
 
 s8 square_pattern_duty[4][8] =
-{
-  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
-  { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
-  { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 },
+  {
+    { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0xF8, 0xF8, 0xF8 },
+    { 0xF8, 0xF8, 0xF8, 0xF8, 0x07, 0x07, 0xF8, 0xF8 },
+    { 0xF8, 0xF8, 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8 },
+    { 0x07, 0x07, 0x07, 0x07, 0xF8, 0xF8, 0x07, 0x07 }, 
 };
 
 s8 wave_samples[64];
@@ -435,41 +454,16 @@
 u32 noise_table15[1024];
 u32 noise_table7[4];
 
-u32 gbc_sound_master_volume_table[4] = { 1, 2, 4, 0 };
+u32 gbc_sound_master_volume_table[4] =
+  { 1, 2, 4, 0 };
 
 u32 gbc_sound_channel_volume_table[8] =
-{
-  FIXED_DIV(0, 7, 12),
-  FIXED_DIV(1, 7, 12),
-  FIXED_DIV(2, 7, 12),
-  FIXED_DIV(3, 7, 12),
-  FIXED_DIV(4, 7, 12),
-  FIXED_DIV(5, 7, 12),
-  FIXED_DIV(6, 7, 12),
-  FIXED_DIV(7, 7, 12)
-};
+  { FIXED_DIV(0, 7, 12), FIXED_DIV(1, 7, 12), FIXED_DIV(2, 7, 12), FIXED_DIV(3, 7, 12), FIXED_DIV(4, 7, 12), FIXED_DIV(5, 7, 12), FIXED_DIV(6, 7, 12), FIXED_DIV(7, 7, 12) };
 
 u32 gbc_sound_envelope_volume_table[16] =
-{
-  FIXED_DIV(0, 15, 14),
-  FIXED_DIV(1, 15, 14),
-  FIXED_DIV(2, 15, 14),
-  FIXED_DIV(3, 15, 14),
-  FIXED_DIV(4, 15, 14),
-  FIXED_DIV(5, 15, 14),
-  FIXED_DIV(6, 15, 14),
-  FIXED_DIV(7, 15, 14),
-  FIXED_DIV(8, 15, 14),
-  FIXED_DIV(9, 15, 14),
-  FIXED_DIV(10, 15, 14),
-  FIXED_DIV(11, 15, 14),
-  FIXED_DIV(12, 15, 14),
-  FIXED_DIV(13, 15, 14),
-  FIXED_DIV(14, 15, 14),
-  FIXED_DIV(15, 15, 14)
-};
+  { FIXED_DIV(0, 15, 14), FIXED_DIV(1, 15, 14), FIXED_DIV(2, 15, 14), FIXED_DIV(3, 15, 14), FIXED_DIV(4, 15, 14), FIXED_DIV(5, 15, 14), FIXED_DIV(6, 15, 14), FIXED_DIV(7, 15, 14), FIXED_DIV(8, 15, 14), FIXED_DIV(9, 15, 14), FIXED_DIV(10, 15, 14), FIXED_DIV(11, 15, 14), FIXED_DIV(12, 15, 14), FIXED_DIV(13, 15, 14), FIXED_DIV(14, 15, 14), FIXED_DIV(15, 15, 14) };
 
-u32 gbc_sound_buffer_index = 0;
+volatile static u32 gbc_sound_buffer_index = 0;
 u32 gbc_sound_last_cpu_ticks = 0;
 u32 gbc_sound_partial_ticks = 0;
 
@@ -477,327 +471,286 @@
 u32 gbc_sound_master_volume_right;
 u32 gbc_sound_master_volume;
 
-
 void update_gbc_sound(u32 cpu_ticks)
-{
-  FIXED16_16 buffer_ticks = FLOAT_TO_FP16_16(((float)(cpu_ticks -
-   gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / 16777216.0);
-  u32 i, i2;
-  gbc_sound_struct *gs = gbc_sound_channel;
-  FIXED16_16 sample_index, frequency_step;
-  FIXED16_16 tick_counter;
-  u32 buffer_index;
-  s32 volume_left, volume_right;
-  u32 envelope_volume;
-  s32 current_sample;
-  u32 sound_status = ADDRESS16(io_registers, 0x84) & 0xFFF0;
-  s8 *sample_data;
-  s8 *wave_bank;
-  u8 *wave_ram = ((u8 *)io_registers) + 0x90;
-
-  gbc_sound_partial_ticks += FP16_16_FRACTIONAL_PART(buffer_ticks);
-  buffer_ticks = FP16_16_TO_U32(buffer_ticks);
-
-  if(gbc_sound_partial_ticks > 0xFFFF)
-  {
-    buffer_ticks += 1;
-    gbc_sound_partial_ticks &= 0xFFFF;
-  }
-
-//  SDL_LockMutex(sound_mutex);
-
-  if(synchronize_flag)
   {
-    if(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
-     (audio_buffer_size_x2))
-    {
-//      while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
-//       (audio_buffer_size_x2))
-//      {
-//        SDL_CondWait(sound_cv, sound_mutex);
-//      }
-//      if(game_config_frameskip_type == auto_frameskip)
-//      {
-//        sceDisplayWaitVblankStart();
-//        real_frame_count = 0;
-//        virtual_frame_count = 0;
-//      }
-    }
-  }
+    FIXED16_16 buffer_ticks= FLOAT_TO_FP16_16(((float)(cpu_ticks - gbc_sound_last_cpu_ticks) * SOUND_FREQUENCY) / SYS_CLOCK);
+    u32 i, i2;
+    GBC_SOUND_STRUCT *gs = gbc_sound_channel;
+    FIXED16_16 sample_index, frequency_step;
+    FIXED16_16 tick_counter;
+    u32 sound_write_offset;
+    s32 volume_left, volume_right;
+    u32 envelope_volume;
+    s32 current_sample;
+    u32 sound_status= ADDRESS16(io_registers, 0x84) & 0xFFF0;
+    s8 *sample_data;
+    s8 *wave_bank;
+    u8 *wave_ram = ((u8 *)io_registers) + 0x90;
+    u32 temp;
+
+    gbc_sound_partial_ticks += FP16_16_FRACTIONAL_PART(buffer_ticks);
+    buffer_ticks = FP16_16_TO_U32(buffer_ticks);
 
-  if(sound_on == 1)
-  {
-    gs = gbc_sound_channel + 0;
-    if(gs->active_flag)
+    if (gbc_sound_partial_ticks > 0xFFFF)
     {
-      sound_status |= 0x01;
-      sample_data = gs->sample_data;
-      envelope_volume = gs->envelope_volume;
-      GBC_SOUND_RENDER_CHANNEL(samples, 8, envelope, sweep);
+      buffer_ticks += 1;
+      gbc_sound_partial_ticks &= 0xFFFF;
     }
 
-    gs = gbc_sound_channel + 1;
-    if(gs->active_flag)
-    {
-      sound_status |= 0x02;
-      sample_data = gs->sample_data;
-      envelope_volume = gs->envelope_volume;
-      GBC_SOUND_RENDER_CHANNEL(samples, 8, envelope, nosweep);
-    }
+    if (gbc_sound_buffer_index >= sound_read_offset)
+    temp = gbc_sound_buffer_index - sound_read_offset;
+    else
+    temp = gbc_sound_buffer_index + (BUFFER_SIZE - sound_read_offset);
 
-    gs = gbc_sound_channel + 2;
-    if(gbc_sound_wave_update)
+    if (sound_on == 1)
     {
-      if(gs->wave_bank == 1)
-      {
-        GBC_SOUND_LOAD_WAVE_RAM(1);
-      }
-      else
+      gs = gbc_sound_channel + 0;
+      if (gs->active_flag)
       {
-        GBC_SOUND_LOAD_WAVE_RAM(0);
+        sound_status |= 0x01;
+        sample_data = gs->sample_data;
+        envelope_volume = gs->envelope_volume;
+        GBC_SOUND_RENDER_CHANNEL(SAMPLES, 8, ENVELOPE, SWEEP)
+        ;
       }
 
-      gbc_sound_wave_update = 0;
-    }
-
-    if((gs->active_flag) && (gs->master_enable))
-    {
-      sound_status |= 0x04;
-      sample_data = wave_samples;
-      if(gs->wave_type == 0)
+      gs = gbc_sound_channel + 1;
+      if (gs->active_flag)
       {
-        if(gs->wave_bank == 1)
-          sample_data += 32;
-
-        GBC_SOUND_RENDER_CHANNEL(samples, 32, noenvelope, nosweep);
+        sound_status |= 0x02;
+        sample_data = gs->sample_data;
+        envelope_volume = gs->envelope_volume;
+        GBC_SOUND_RENDER_CHANNEL(SAMPLES, 8, ENVELOPE, NOSWEEP)
+        ;
       }
-      else
+
+      gs = gbc_sound_channel + 2;
+      if (gbc_sound_wave_update)
       {
-        GBC_SOUND_RENDER_CHANNEL(samples, 64, noenvelope, nosweep);
+        GBC_SOUND_LOAD_WAVE_RAM(gs->wave_bank)
+        ;
+        gbc_sound_wave_update = 0;
       }
-    }
 
-    gs = gbc_sound_channel + 3;
-    if(gs->active_flag)
-    {
-      sound_status |= 0x08;
-      envelope_volume = gs->envelope_volume;
-
-      if(gs->noise_type == 1)
+      if ((gs->active_flag) && (gs->master_enable))
       {
-        GBC_SOUND_RENDER_CHANNEL(noise, half, envelope, nosweep);
+        sound_status |= 0x04;
+        sample_data = wave_samples;
+        if (gs->wave_type == 0)
+        {
+          if (gs->wave_bank == 1)
+            sample_data += 32;
+
+          GBC_SOUND_RENDER_CHANNEL(SAMPLES, 32, NOENVELOPE, NOSWEEP)
+          ;
+        }
+        else
+        {
+          GBC_SOUND_RENDER_CHANNEL(SAMPLES, 64, NOENVELOPE, NOSWEEP)
+          ;
+        }
       }
-      else
+
+      gs = gbc_sound_channel + 3;
+      if (gs->active_flag)
       {
-        GBC_SOUND_RENDER_CHANNEL(noise, full, envelope, nosweep);
+        sound_status |= 0x08;
+        envelope_volume = gs->envelope_volume;
+
+        if (gs->noise_type == 1)
+        {
+          GBC_SOUND_RENDER_CHANNEL(NOISE, HALF, ENVELOPE, NOSWEEP)
+          ;
+        }
+        else
+        {
+          GBC_SOUND_RENDER_CHANNEL(NOISE, FULL, ENVELOPE, NOSWEEP)
+          ;
+        }
       }
     }
-  }
-
-  ADDRESS16(io_registers, 0x84) = sound_status;
 
-  gbc_sound_last_cpu_ticks = cpu_ticks;
-  gbc_sound_buffer_index =
-   (gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
-}
+    ADDRESS16(io_registers, 0x84) = sound_status;
 
+    gbc_sound_last_cpu_ticks = cpu_ticks;
+    gbc_sound_buffer_index =(gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
+  }
 
-static int sound_update_thread(SceSize args, void *argp)
+void init_sound()
   {
-    return 0;
-  }
-/*--------------------------------------------------------
-  サウンド コールバック
---------------------------------------------------------*/
-void sound_callback(/*void *userdata, char *stream, int length*/)
-{
-/*  u32 sample_length = length / 2;
-  u32 _length;
-  u32 i;
-  s16 *stream_base = (s16 *)stream;
-  s16 *source;
-  s32 current_sample;
+    audio_buffer_size = SAMPLE_SIZE * (10 + audio_buffer_size_number);
 
-//  SDL_LockMutex(sound_mutex);
+    gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
 
-  while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) <
-   length)
-  {
-//    SDL_CondWait(sound_cv, sound_mutex);
-  }
+    init_noise_table(noise_table15, 32767, 14);
+    init_noise_table(noise_table7, 127, 6);
 
-  if(global_enable_audio)
-  {
-    if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
-    {
-      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
-      SOUND_COPY(sound_buffer_base, partial_length, normal);
-//      source = (s16 *)sound_buffer;
-      SOUND_COPY(0, length - partial_length, normal);
-      sound_buffer_base = (length - partial_length) / 2;
-    }
-    else
+    // 変数等の初期化
+    reset_sound();
+
+    // サウンド スレッドの作成
+    sound_thread = sceKernelCreateThread("Sound thread", sound_update_thread,
+        0x08, 3 * 1024, 0, NULL);
+    if (sound_thread < 0)
     {
-      SOUND_COPY(sound_buffer_base, length, normal);
-      sound_buffer_base += sample_length;
+      quit();
     }
+
+    //スレッドの開始
+    sceKernelStartThread(sound_thread, 0, 0);
+
   }
-  else
+
+void reset_sound()
   {
-    if((sound_buffer_base + sample_length) >= BUFFER_SIZE)
+    DIRECT_SOUND_STRUCT *ds = direct_sound_channel;
+    GBC_SOUND_STRUCT *gs = gbc_sound_channel;
+    u32 i;
+
+    sound_on = 0;
+    sound_buffer_base = 0;
+    sound_last_cpu_ticks = 0;
+    memset(sound_buffer, 0, BUFFER_SIZE * 2);
+
+    for (i = 0; i < 2; i++, ds++)
     {
-      u32 partial_length = (BUFFER_SIZE - sound_buffer_base) * 2;
-      SOUND_COPY_NULL(sound_buffer_base, partial_length);
-//      source = (s16 *)sound_buffer;
-      SOUND_COPY_NULL(0, length - partial_length);
-      sound_buffer_base = (length - partial_length) / 2;
+      ds->buffer_index = 0;
+      ds->status = DIRECT_SOUND_INACTIVE;
+      ds->fifo_top = 0;
+      ds->fifo_base = 0;
+      ds->fifo_fractional = 0;
+      ds->last_cpu_ticks = 0;
+      memset(ds->fifo, 0, 32);
     }
-    else
+
+    gbc_sound_buffer_index = 0;
+    gbc_sound_last_cpu_ticks = 0;
+    gbc_sound_partial_ticks = 0;
+    sound_read_offset = 0;
+
+    gbc_sound_master_volume_left = 0;
+    gbc_sound_master_volume_right = 0;
+    gbc_sound_master_volume = 0;
+    memset(wave_samples, 0, 64);
+
+    pause_sound(1);
+
+    for (i = 0; i < 4; i++, gs++)
     {
-      SOUND_COPY_NULL(sound_buffer_base, length);
-      sound_buffer_base += sample_length;
+      gs->status = GBC_SOUND_INACTIVE;
+      gs->sample_data = square_pattern_duty[2];
+      gs->active_flag = 0;
     }
   }
 
-//  SDL_CondSignal(sound_cv);
+void pause_sound(u32 flag)
+  {
+    pause_sound_flag = flag;
+    audio_buffer_size = SAMPLE_SIZE * (15 + audio_buffer_size_number);
+  }
 
-//  SDL_UnlockMutex(sound_mutex);
-*/
-}
+void sound_exit()
+  {
+    //  gbc_sound_buffer_index =
+    //   (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
+    //  SDL_PauseAudio(1);
+    //  SDL_CondSignal(sound_cv);
+  }
 
-// Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
-// on the forum at http://meridian.overclocked.org:
-// http://meridian.overclocked.org/cgi-bin/wwwthreads/showpost.pl?Board=merid
-// angeneraldiscussion&Number=2069&page=0&view=expanded&mode=threaded&sb=4
-// Hope you don't mind me borrowing it ^_-
+void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file)
+  sound_savestate_body(WRITE_MEM);
 
-void init_noise_table(u32 *table, u32 period, u32 bit_length)
-{
-  u32 shift_register = 0xFF;
-  u32 mask = ~(1 << bit_length);
-  s32 table_pos, bit_pos;
-  u32 current_entry;
-  u32 table_period = (period + 31) / 32;
+void sound_read_savestate(FILE_TAG_TYPE savestate_file)
+  sound_savestate_body(READ);
 
-  // Bits are stored in reverse order so they can be more easily moved to
-  // bit 31, for sign extended shift down.
+/******************************************************************************
+ * ローカル関数の定義
+ ******************************************************************************/
 
-  for(table_pos = 0; table_pos < table_period; table_pos++)
+/*--------------------------------------------------------
+ サウンド スレッド
+ --------------------------------------------------------*/
+static int sound_update_thread(SceSize args, void *argp)
   {
-    current_entry = 0;
-    for(bit_pos = 31; bit_pos >= 0; bit_pos--)
-    {
-      current_entry |= (shift_register & 0x01) << bit_pos;
-
-      shift_register =
-       ((1 & (shift_register ^ (shift_register >> 1))) << bit_length) |
-       ((shift_register >> 1) & mask);
-    }
+    int audio_handle; // オーディオチャンネルのハンドル。
+    s16 buffer[SAMPLE_SIZE];
+    u32 i;
 
-    table[table_pos] = current_entry;
-  }
-}
-
-void reset_sound()
-{
-  direct_sound_struct *ds = direct_sound_channel;
-  gbc_sound_struct *gs = gbc_sound_channel;
-  u32 i;
-
-  sound_on = 0;
-  sound_buffer_base = 0;
-  sound_last_cpu_ticks = 0;
-  memset(sound_buffer, 0, audio_buffer_size);
-
-  for(i = 0; i < 2; i++, ds++)
-  {
-    ds->buffer_index = 0;
-    ds->status = DIRECT_SOUND_INACTIVE;
-    ds->fifo_top = 0;
-    ds->fifo_base = 0;
-    ds->fifo_fractional = 0;
-    ds->last_cpu_ticks = 0;
-    memset(ds->fifo, 0, 32);
-  }
+    // オーディオチャンネルの取得。
+    audio_handle
+        = sceAudioChReserve( PSP_AUDIO_NEXT_CHANNEL, SAMPLE_COUNT, PSP_AUDIO_FORMAT_STEREO);
 
-  gbc_sound_buffer_index = 0;
-  gbc_sound_last_cpu_ticks = 0;
-  gbc_sound_partial_ticks = 0;
-
-  gbc_sound_master_volume_left = 0;
-  gbc_sound_master_volume_right = 0;
-  gbc_sound_master_volume = 0;
-  memset(wave_samples, 0, 64);
-
-  for(i = 0; i < 4; i++, gs++)
-  {
-    gs->status = GBC_SOUND_INACTIVE;
-    gs->sample_data = square_pattern_duty[2];
-    gs->active_flag = 0;
-  }
-}
+    // TODO:初期設定に移動
+    sound_read_offset = 0;
+    memset(buffer, 0, sizeof(buffer));
+    left_buffer = 0;
 
-void sound_exit()
-{
-//  gbc_sound_buffer_index =
-//   (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
-//  SDL_PauseAudio(1);
-//  SDL_CondSignal(sound_cv);
-}
+    while(!audio_thread_exit_flag)
+    {
 
-void init_sound()
-{
-  audio_buffer_size = (audio_buffer_size_number * 1024) + 2048;
-  audio_buffer_size_x2 = audio_buffer_size * 2;
+      while( (pause_sound_flag != 0) && (CHECK_BUFFER() < audio_buffer_size) )
+      {
+        sceKernelDelayThread(1);
+      }
 
-  gbc_sound_tick_step = FLOAT_TO_FP16_16(256.0 / SOUND_FREQUENCY);
+      while(CHECK_BUFFER() < SAMPLE_SIZE)
+      {
+        sceKernelDelayThread(0);
+      }
 
-  init_noise_table(noise_table15, 32767, 14);
-  init_noise_table(noise_table7, 127, 6);
+      left_buffer = CHECK_BUFFER() / SAMPLE_SIZE;
 
-  // 変数等の初期化
-  reset_sound();
+      for(i = 0; i < SAMPLE_SIZE; i++)
+      {
+        buffer[i] = sound_buffer[sound_read_offset] << 4;
+        sound_buffer[sound_read_offset] = 0;
+        sound_read_offset = (sound_read_offset + 1) % BUFFER_SIZE;
+      }
 
-  // オーディオチャンネルの設定
-  sound_handle = sceAudioChReserve(PSP_AUDIO_NEXT_CHANNEL, audio_buffer_size / 4, PSP_AUDIO_FORMAT_STEREO);
-  if (sound_handle < 0)
-  {
-    quit();
-  }
+      sceAudioOutputPannedBlocking(audio_handle, PSP_AUDIO_VOLUME_MAX, PSP_AUDIO_VOLUME_MAX, &buffer);
+    }
 
-  sound_thread = sceKernelCreateThread("Sound thread", sound_callback/*sound_update_thread*/, 0x08, 0x1000, 0, NULL);
-  if (sound_thread < 0)
-  {
-    sceAudioChRelease(sound_handle);
-    sound_handle = -1;
-    quit();
+    memset(buffer, 0, sizeof(buffer));
+    sceAudioOutputPannedBlocking(audio_handle, 0, 0, &buffer);
+    sceAudioChRelease(audio_handle);
+    sceKernelExitThread(0);
+    return 0;
   }
 
+  // Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
+  // on the forum at http://meridian.overclocked.org:
+  // http://meridian.overclocked.org/cgi-bin/wwwthreads/showpost.pl?Board=merid
+  // angeneraldiscussion&Number=2069&page=0&view=expanded&mode=threaded&sb=4
+  // Hope you don't mind me borrowing it ^_-
 
-  //スレッドの開始
-  sceKernelStartThread(sound_thread, 0, 0);
+void init_noise_table(u32 *table, u32 period, u32 bit_length)
+  {
+    u32 shift_register = 0xFF;
+    u32 mask = ~(1 << bit_length);
+    s32 table_pos, bit_pos;
+    u32 current_entry;
+    u32 table_period = (period + 31) / 32;
 
-}
+    // Bits are stored in reverse order so they can be more easily moved to
+    // bit 31, for sign extended shift down.
 
-#define sound_savestate_body(type)                                          \
-{                                                                           \
-  FILE_##type##_VARIABLE(savestate_file, sound_on);                         \
-  FILE_##type##_VARIABLE(savestate_file, sound_buffer_base);                \
-  FILE_##type##_VARIABLE(savestate_file, sound_last_cpu_ticks);             \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_buffer_index);           \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_last_cpu_ticks);         \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_partial_ticks);          \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume_left);     \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume_right);    \
-  FILE_##type##_VARIABLE(savestate_file, gbc_sound_master_volume);          \
-  FILE_##type##_ARRAY(savestate_file, wave_samples);                        \
-  FILE_##type##_ARRAY(savestate_file, direct_sound_channel);                \
-  FILE_##type##_ARRAY(savestate_file, gbc_sound_channel);                   \
-}                                                                           \
+    for (table_pos = 0; table_pos < table_period; table_pos++)
+    {
+      current_entry = 0;
+      for (bit_pos = 31; bit_pos >= 0; bit_pos--)
+      {
+        current_entry |= (shift_register & 0x01) << bit_pos;
 
-void sound_read_savestate(FILE_TAG_TYPE savestate_file)
-sound_savestate_body(READ);
+        shift_register =((1 & (shift_register ^ (shift_register >> 1)))
+            << bit_length) |((shift_register >> 1) & mask);
+      }
 
-void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file)
-sound_savestate_body(WRITE_MEM);
+      table[table_pos] = current_entry;
+    }
+  }
 
+void synchronize_sound()
+{
+  while( CHECK_BUFFER() >= audio_buffer_size ) // TODO:調整必要
+    ;
+}
diff -ru 30_orig/sound.h gpsp-kai-test/sound.h
--- 30_orig/sound.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/sound.h	2007-08-12 00:57:31.638760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -18,15 +19,17 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/******************************************************************************
+ * sound.h
+ * サウンド周りの処理
+ ******************************************************************************/
+
 #ifndef SOUND_H
 #define SOUND_H
 
-#define BUFFER_SIZE 65536
-
-// A lot of sound cards on PC can't handle such small buffers but this
-// seems to work well on PSP.
-
-#define SOUND_BUFFER_SIZE 4096
+/******************************************************************************
+ * マクロ等の定義
+ ******************************************************************************/
 
 typedef enum
 {
@@ -34,13 +37,21 @@
   DIRECT_SOUND_RIGHT,
   DIRECT_SOUND_LEFT,
   DIRECT_SOUND_LEFTRIGHT
-} direct_sound_status_type;
+} DIRECT_SOUND_STATUS_TYPE;
 
 typedef enum
 {
   DIRECT_SOUND_VOLUME_50,
   DIRECT_SOUND_VOLUME_100
-} direct_sound_volume_type;
+} DIRECT_SOUND_VOLUME_TYPE;
+
+typedef enum
+{
+  GBC_SOUND_INACTIVE,
+  GBC_SOUND_RIGHT,
+  GBC_SOUND_LEFT,
+  GBC_SOUND_LEFTRIGHT
+} GBC_SOUND_STATUS_TYPE;
 
 typedef struct
 {
@@ -51,19 +62,10 @@
   // The + 1 is to give some extra room for linear interpolation
   // when wrapping around.
   u32 buffer_index;
-  direct_sound_status_type status;
-  direct_sound_volume_type volume;
+  DIRECT_SOUND_STATUS_TYPE status;
+  DIRECT_SOUND_VOLUME_TYPE volume;
   u32 last_cpu_ticks;
-} direct_sound_struct;
-
-typedef enum
-{
-  GBC_SOUND_INACTIVE,
-  GBC_SOUND_RIGHT,
-  GBC_SOUND_LEFT,
-  GBC_SOUND_LEFTRIGHT
-} gbc_sound_status_type;
-
+} DIRECT_SOUND_STRUCT;
 
 typedef struct
 {
@@ -90,41 +92,17 @@
   u32 wave_type;
   u32 wave_bank;
   u32 wave_volume;
-  gbc_sound_status_type status;
+  GBC_SOUND_STATUS_TYPE status;
   u32 active_flag;
   u32 master_enable;
   s8 *sample_data;
-} gbc_sound_struct;
-
-extern direct_sound_struct direct_sound_channel[2];
-extern gbc_sound_struct gbc_sound_channel[4];
-extern s8 square_pattern_duty[4][8];
-extern u32 gbc_sound_master_volume_left;
-extern u32 gbc_sound_master_volume_right;
-extern u32 gbc_sound_master_volume;
-
-extern u32 sound_on;
+} GBC_SOUND_STRUCT;
 
-extern u32 global_enable_audio;
-extern u32 enable_low_pass_filter;
-extern u32 audio_buffer_size_number;
-
-//extern SDL_mutex *sound_mutex;
-//extern SDL_cond *sound_cv;
-
-void sound_timer_queue8(u32 channel, u8 value);
-void sound_timer_queue16(u32 channel, u16 value);
-void sound_timer_queue32(u32 channel, u32 value);
-void sound_timer(FIXED16_16 frequency_step, u32 channel);
-void sound_reset_fifo(u32 channel);
-void update_gbc_sound(u32 cpu_ticks);
-void init_sound();
-void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file);
-void sound_read_savestate(FILE_TAG_TYPE savestate_file);
+#define BUFFER_SIZE  65536                        // バッファのバイト数。
 
-#define SOUND_FREQUENCY 44100
+#define SOUND_FREQUENCY (44100.0)
 
-#define gbc_sound_tone_control_low(channel, address)                          \
+#define GBC_SOUND_TONE_CONTROL_LOW(channel, address)                          \
 {                                                                             \
   u32 initial_volume = (value >> 12) & 0x0F;                                  \
   u32 envelope_ticks = ((value >> 8) & 0x07) * 4;                             \
@@ -142,12 +120,12 @@
   ADDRESS16(io_registers, address) = value;                                   \
 }                                                                             \
 
-#define gbc_sound_tone_control_high(channel, address)                         \
+#define GBC_SOUND_TONE_CONTROL_HIGH(channel, address)                         \
 {                                                                             \
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[channel].rate = rate;                                     \
   gbc_sound_channel[channel].frequency_step =                                 \
-   FLOAT_TO_FP16_16(((131072.0 / (2048 - rate)) * 8.0) / SOUND_FREQUENCY);    \
+   FLOAT_TO_FP16_16(((131072.0 / (2048.0 - rate)) * 8.0) / SOUND_FREQUENCY);  \
   gbc_sound_channel[channel].length_status = (value >> 14) & 0x01;            \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -157,13 +135,15 @@
      gbc_sound_channel[channel].envelope_initial_ticks;                       \
     gbc_sound_channel[channel].envelope_volume =                              \
      gbc_sound_channel[channel].envelope_initial_volume;                      \
-  }                                                                           \
+    gbc_sound_channel[channel].sweep_ticks =                                  \
+     gbc_sound_channel[channel].sweep_initial_ticks;                          \
+}                                                                             \
                                                                               \
   gbc_sound_update = 1;                                                       \
   ADDRESS16(io_registers, address) = value;                                   \
 }                                                                             \
 
-#define gbc_sound_tone_control_sweep()                                        \
+#define GBC_SOUND_TONE_CONTROL_SWEEP()                                        \
 {                                                                             \
   u32 sweep_ticks = ((value >> 4) & 0x07) * 2;                                \
   gbc_sound_channel[0].sweep_shift = value & 0x07;                            \
@@ -175,7 +155,7 @@
   ADDRESS16(io_registers, 0x60) = value;                                      \
 }                                                                             \
 
-#define gbc_sound_wave_control()                                              \
+#define GBC_SOUND_WAVE_CONTROL()                                              \
 {                                                                             \
   gbc_sound_channel[2].wave_type = (value >> 5) & 0x01;                       \
   gbc_sound_channel[2].wave_bank = (value >> 6) & 0x01;                       \
@@ -192,9 +172,7 @@
   ADDRESS16(io_registers, 0x70) = value;                                      \
 }                                                                             \
 
-extern u32 gbc_sound_wave_volume[4];
-
-#define gbc_sound_tone_control_low_wave()                                     \
+#define GBC_SOUND_TONE_CONTROL_LOW_WAVE()                                     \
 {                                                                             \
   gbc_sound_channel[2].length_ticks = 256 - (value & 0xFF);                   \
   if((value >> 15) & 0x01)                                                    \
@@ -210,12 +188,12 @@
   ADDRESS16(io_registers, 0x72) = value;                                      \
 }                                                                             \
 
-#define gbc_sound_tone_control_high_wave()                                    \
+#define GBC_SOUND_TONE_CONTROL_HIGH_WAVE()                                    \
 {                                                                             \
   u32 rate = value & 0x7FF;                                                   \
   gbc_sound_channel[2].rate = rate;                                           \
   gbc_sound_channel[2].frequency_step =                                       \
-   FLOAT_TO_FP16_16((2097152.0 / (2048 - rate)) / SOUND_FREQUENCY);           \
+   FLOAT_TO_FP16_16((2097152.0 / (2048.0 - rate)) / SOUND_FREQUENCY);         \
   gbc_sound_channel[2].length_status = (value >> 14) & 0x01;                  \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -226,7 +204,7 @@
   ADDRESS16(io_registers, 0x74) = value;                                      \
 }                                                                             \
 
-#define gbc_sound_noise_control()                                             \
+#define GBC_SOUND_NOISE_CONTROL()                                             \
 {                                                                             \
   u32 dividing_ratio = value & 0x07;                                          \
   u32 frequency_shift = (value >> 4) & 0x0F;                                  \
@@ -257,27 +235,29 @@
   ADDRESS16(io_registers, 0x7C) = value;                                      \
 }                                                                             \
 
-#define gbc_trigger_sound_channel(channel)                                    \
-  gbc_sound_master_volume_right = value & 0x07;                               \
-  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
-  gbc_sound_channel[channel].status = ((value >> (channel + 8)) & 0x01) |     \
-   ((value >> (channel + 11)) & 0x03)                                         \
+#define GBC_TRIGGER_SOUND_CHANNEL(channel)                                    \
+  gbc_sound_channel[channel].status =                                         \
+   ((value >> (channel + 11)) & 0x02) | ((value >> (channel + 8)) & 0x01)      \
 
-#define gbc_trigger_sound()                                                   \
+#define GBC_TRIGGER_SOUND()                                                   \
 {                                                                             \
-  gbc_trigger_sound_channel(0);                                               \
-  gbc_trigger_sound_channel(1);                                               \
-  gbc_trigger_sound_channel(2);                                               \
-  gbc_trigger_sound_channel(3);                                               \
+  gbc_sound_master_volume_right = value & 0x07;                               \
+  gbc_sound_master_volume_left = (value >> 4) & 0x07;                         \
+                                                                              \
+  GBC_TRIGGER_SOUND_CHANNEL(0);                                               \
+  GBC_TRIGGER_SOUND_CHANNEL(1);                                               \
+  GBC_TRIGGER_SOUND_CHANNEL(2);                                               \
+  GBC_TRIGGER_SOUND_CHANNEL(3);                                               \
   ADDRESS16(io_registers, 0x80) = value;                                      \
 }                                                                             \
 
-#define trigger_sound()                                                       \
+#define TRIGGER_SOUND()                                                       \
 {                                                                             \
-  timer[0].direct_sound_channels = (((value >> 10) & 0x01) == 0) |            \
-   ((((value >> 14) & 0x01) == 0) << 1);                                      \
-  timer[1].direct_sound_channels = (((value >> 10) & 0x01) == 1) |            \
-   ((((value >> 14) & 0x01) == 1) << 1);                                      \
+  timer[0].direct_sound_channels =                                            \
+   ((~value >> 13) & 0x02) | ((~value >> 10) & 0x01);                         \
+  timer[1].direct_sound_channels =                                            \
+   ((value >> 13) & 0x02) | ((value >> 10) & 0x01);                           \
+                                                                              \
   direct_sound_channel[0].volume = (value >> 2) & 0x01;                       \
   direct_sound_channel[0].status = (value >> 8) & 0x03;                       \
   direct_sound_channel[1].volume = (value >> 3) & 0x01;                       \
@@ -291,14 +271,9 @@
   ADDRESS16(io_registers, 0x82) = value;                                      \
 }                                                                             \
 
-#define sound_on()                                                            \
+#define SOUND_ON()                                                            \
   if(value & 0x80)                                                            \
-  {                                                                           \
-    if(sound_on != 1)                                                         \
-    {                                                                         \
-      sound_on = 1;                                                           \
-    }                                                                         \
-  }                                                                           \
+    sound_on = 1;                                                           \
   else                                                                        \
   {                                                                           \
     u32 i;                                                                    \
@@ -311,11 +286,37 @@
   ADDRESS16(io_registers, 0x84) =                                             \
     (ADDRESS16(io_registers, 0x84) & 0x000F) | (value & 0xFFF0);              \
 
-#define sound_update_frequency_step(timer_number)                             \
+#define SOUND_UPDATE_FREQUENCY_STEP(timer_number)                             \
   timer[timer_number].frequency_step =                                        \
-   FLOAT_TO_FP16_16(16777216.0 / (timer_reload * SOUND_FREQUENCY))            \
+   FLOAT_TO_FP16_16(SYS_CLOCK / (timer_reload * SOUND_FREQUENCY))            \
 
+/******************************************************************************
+ * グローバル変数の宣言
+ ******************************************************************************/
+extern DIRECT_SOUND_STRUCT direct_sound_channel[2];
+extern GBC_SOUND_STRUCT gbc_sound_channel[4];
+extern s8 square_pattern_duty[4][8];
+extern u32 gbc_sound_master_volume_left;
+extern u32 gbc_sound_master_volume_right;
+extern u32 gbc_sound_master_volume;
+
+extern u32 sound_on;
+
+extern u32 global_enable_audio;
+extern u32 left_buffer;
+extern u32 audio_buffer_size_number;
+extern u32 gbc_sound_wave_volume[4];
+
+void sound_timer_queue32(u8 channel);
+void sound_timer(FIXED16_16 frequency_step, u32 channel);
+void sound_reset_fifo(u32 channel);
+void update_gbc_sound(u32 cpu_ticks);
+void init_sound();
+void sound_write_mem_savestate(FILE_TAG_TYPE savestate_file);
+void sound_read_savestate(FILE_TAG_TYPE savestate_file);
+void pause_sound(u32 flag);
 void reset_sound();
 void sound_exit();
+void synchronize_sound();
 
 #endif
diff -ru 30_orig/video.c gpsp-kai-test/video.c
--- 30_orig/video.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/video.c	2007-08-12 11:34:52.341760800 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -1450,7 +1451,6 @@
   else                                                                        \
     src_ptr = (u16 *)vram                                                     \
 
-
 #ifdef RENDER_COLOR16_NORMAL
 
 #define render_scanline_vram_setup_mode4()                                    \
@@ -2173,7 +2173,6 @@
     obj_attribute_0 = oam_ptr[0];
     obj_attribute_2 = oam_ptr[2];
     obj_size = obj_attribute_0 & 0xC000;
-    obj_priority = (obj_attribute_2 >> 10) & 0x03;
     obj_mode = (obj_attribute_0 >> 10) & 0x03;
 
     if(((obj_attribute_0 & 0x0300) != 0x0200) && (obj_size != 0xC000) &&
@@ -2186,6 +2185,7 @@
 
       obj_attribute_1 = oam_ptr[1];
       obj_size = ((obj_size >> 12) & 0x0C) | (obj_attribute_1 >> 14);
+      obj_priority = (obj_attribute_2 >> 10) & 0x03;
       obj_height = obj_height_table[obj_size];
       obj_width = obj_width_table[obj_size];
 
@@ -2422,32 +2422,8 @@
 
 // Blend top two pixels of scanline with each other.
 
-#ifdef RENDER_COLOR16_NORMAL
-
-void expand_normal(u16 *screen_ptr, u32 start, u32 end)
-{
-  u32 i, pixel_source;
-  screen_ptr += start;
-
-  return;
-
-  end -= start;
-
-  for(i = 0; i < end; i++)
-  {
-    pixel_source = *screen_ptr;
-    *screen_ptr = palette_ram_converted[pixel_source];
-
-    screen_ptr++;
-  }
-}
-
-#else
-
 #define expand_normal(screen_ptr, start, end)
 
-#endif
-
 void expand_blend(u32 *screen_src_ptr, u16 *screen_dest_ptr,
  u32 start, u32 end)
 {
@@ -3269,11 +3245,9 @@
 {
   u32 pitch = get_screen_pitch();
   u32 dispcnt = io_registers[REG_DISPCNT];
-//  u32 display_flags = (dispcnt >> 8) & 0x1F;
   u32 vcount = io_registers[REG_VCOUNT];
   u16 *screen_offset = get_screen_pixels() + (vcount * pitch);
   u32 video_mode = dispcnt & 0x07;
-//  u32 current_layer;
 
   // If OAM has been modified since the last scanline has been updated then
   // reorder and reprofile the OBJ lists.
@@ -3285,7 +3259,7 @@
 
   order_layers((dispcnt >> 8) & active_layers[video_mode]);
 
-  if(skip_next_frame)
+  if(skip_next_frame_flag)
     return;
 
   // If the screen is in in forced blank draw pure white.
@@ -3353,7 +3327,7 @@
 
 void update_screen()
 {
-  if(!skip_next_frame)
+  if(!skip_next_frame_flag)
     flip_screen();
 }
 
@@ -3399,16 +3373,16 @@
   gecb.finish_arg = NULL;
   gecbid = sceGeSetCallback(&gecb);
 
-  screen_vertex[0] = 0 + 0.5;
-  screen_vertex[1] = 0 + 0.5;
-  screen_vertex[2] = 0 + 0.5;
-  screen_vertex[3] = 0 + 0.5;
-  screen_vertex[4] = 0;
+  screen_vertex[0] = 0.0 + 0.5;
+  screen_vertex[1] = 0.0 + 0.5;
+  screen_vertex[2] = 0.0 + 0.5;
+  screen_vertex[3] = 0.0 + 0.5;
+  screen_vertex[4] = 0.0;
   screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
   screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
   screen_vertex[7] = PSP_SCREEN_WIDTH - 0.5;
   screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
-  screen_vertex[9] = 0;
+  screen_vertex[9] = 0.0;
 
   // Set framebuffer to PSP VRAM
   GE_CMD(FBP, ((u32)psp_gu_vram_base & 0x00FFFFFF));
@@ -3466,29 +3440,40 @@
 
 void set_gba_resolution(video_scale_type scale)
 {
-//  u32 filter_linear = 0;
   screen_scale = scale;
   switch(scale)
   {
     case unscaled:
-      screen_vertex[2] = 120 + 0.5;
-      screen_vertex[3] = 56 + 0.5;
-      screen_vertex[7] = GBA_SCREEN_WIDTH + 120 - 0.5;
-      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56 - 0.5;
+      screen_vertex[0] = 0.0;
+      screen_vertex[1] = 0.0;
+      screen_vertex[2] = 120.0;
+      screen_vertex[3] = 56.0;
+      screen_vertex[5] = (float)GBA_SCREEN_WIDTH;
+      screen_vertex[6] = (float)GBA_SCREEN_HEIGHT;
+      screen_vertex[7] = GBA_SCREEN_WIDTH + 120.0;
+      screen_vertex[8] = GBA_SCREEN_HEIGHT + 56.0;
       break;
 
     case scaled_aspect:
-      screen_vertex[2] = 36 + 0.5;
-      screen_vertex[3] = 0 + 0.5;
-      screen_vertex[7] = 408 + 36 - 0.5;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT - 0.5;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 36.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = 408.0 + 36.0;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
 
     case fullscreen:
-      screen_vertex[2] = 0;
-      screen_vertex[3] = 0;
-      screen_vertex[7] = PSP_SCREEN_WIDTH;
-      screen_vertex[8] = PSP_SCREEN_HEIGHT;
+      screen_vertex[0] = 0.0 + 0.5;
+      screen_vertex[1] = 0.0 + 0.5;
+      screen_vertex[2] = 0.0;
+      screen_vertex[3] = 0.0;
+      screen_vertex[5] = GBA_SCREEN_WIDTH - 0.5;
+      screen_vertex[6] = GBA_SCREEN_HEIGHT - 0.5;
+      screen_vertex[7] = (float)PSP_SCREEN_WIDTH;
+      screen_vertex[8] = (float)PSP_SCREEN_HEIGHT;
       break;
   }
 
Only in gpsp-kai-test/: zau_main.c
diff -ru 30_orig/zip.c gpsp-kai-test/zip.c
--- 30_orig/zip.c	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/zip.c	2007-08-10 05:18:35.594760800 +0900
@@ -3,6 +3,7 @@
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2006 SiberianSTAR
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -44,13 +45,13 @@
   s16 ExtraFieldLength;
 }  __attribute__((packed));
 
-u32 load_file_zip(char *filename)
+s32 load_file_zip(char *filename)
 {
   struct SZIPFileHeader data;
   char tmp[1024];
   s32 retval = -1;
   u8 *buffer = NULL;
-  u8 *cbuffer;
+//  u8 *cbuffer;
   char *ext;
   FILE_ID fd;
 
@@ -109,8 +110,7 @@
         {
           z_stream stream;
           s32 err;
-
-          cbuffer = malloc(ZIP_BUFFER_SIZE);
+          u8 cbuffer[ZIP_BUFFER_SIZE];
 
           stream.next_in = (Bytef*)cbuffer;
           stream.avail_in = (u32)ZIP_BUFFER_SIZE;
@@ -123,6 +123,7 @@
 
           stream.zalloc = (alloc_func)0;
           stream.zfree = (free_func)0;
+          stream.opaque = (voidpf)0;
 
           err = inflateInit2(&stream, -MAX_WBITS);
 
@@ -143,7 +144,6 @@
             err = Z_OK;
             inflateEnd(&stream);
           }
-          free(cbuffer);
           goto outcode;
         }
       }
diff -ru 30_orig/zip.h gpsp-kai-test/zip.h
--- 30_orig/zip.h	2007-08-06 01:50:58.000000000 +0900
+++ gpsp-kai-test/zip.h	2007-08-07 12:37:27.744400700 +0900
@@ -2,6 +2,7 @@
  *
  * Copyright (C) 2006 Exophase <exophase@gmail.com>
  * Copyright (C) 2007 takka <takka@tfact.net>
+ * Copyright (C) 2007 ????? <?????>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -21,7 +22,7 @@
 #ifndef ZIP_H
 #define ZIP_H
 
-u32 load_file_zip(char *filename);
+s32 load_file_zip(char *filename);
 
 #endif
 
